/**
 * bibtex-tidy v1.8.5
 * https://github.com/FlamingTempura/bibtex-tidy
 *
 * DO NOT EDIT THIS FILE. This file is automatically generated
 * using `npm run build`. Edit files in './src' then rebuild.
 **/ "use strict";
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self1 = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self1, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _iterableToArray(iter) {
  if ((typeof Symbol !== "undefined" && iter[Symbol.iterator] != null) || iter["@@iterator"] != null) return Array.from(iter);
}
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : (typeof Symbol !== "undefined" && arr[Symbol.iterator]) || arr["@@iterator"];
  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(n);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
var __generator =
  (this && this.__generator) ||
  function (thisArg, body) {
    var f,
      y,
      t,
      g,
      _ = {
        label: 0,
        sent: function () {
          if (t[0] & 1) throw t[1];
          return t[1];
        },
        trys: [],
        ops: [],
      };
    return (
      (g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2),
      }),
      typeof Symbol === "function" &&
        (g[Symbol.iterator] = function () {
          return this;
        }),
      g
    );
    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (_)
        try {
          if (((f = 1), y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)) return t;
          if (((y = 0), t)) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return {
                value: op[1],
                done: false,
              };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!((t = _.trys), (t = t.length > 0 && t[t.length - 1])) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true,
      };
    }
  };
(() => {
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) =>
    key in obj
      ? __defProp(obj, key, {
          enumerable: true,
          configurable: true,
          writable: true,
          value,
        })
      : (obj[key] = value);
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    var _iteratorNormalCompletion = true,
      _didIteratorError = false,
      _iteratorError = undefined;
    if (__getOwnPropSymbols)
      try {
        for (var _iterator = __getOwnPropSymbols(b)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var prop = _step.value;
          if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __name = (target, value) =>
    __defProp(target, "name", {
      value,
      configurable: true,
    });
  var __commonJS = (cb, mod) =>
    function __require() {
      return (
        mod ||
          (0, cb[__getOwnPropNames(cb)[0]])(
            (mod = {
              exports: {},
            }).exports,
            mod
          ),
        mod.exports
      );
    };
  // node_modules/core-js/internals/global.js
  var require_global = __commonJS({
    "node_modules/core-js/internals/global.js"(exports, module) {
      var check = /* @__PURE__ */ __name(function (it) {
        return it && it.Math == Math && it;
      }, "check");
      module.exports =
        check(typeof globalThis == "object" && globalThis) ||
        check(typeof window == "object" && window) ||
        check(typeof self == "object" && self) ||
        check(typeof global == "object" && global) ||
        (function () {
          return this;
        })() ||
        Function("return this")();
    },
  });
  // node_modules/core-js/internals/fails.js
  var require_fails = __commonJS({
    "node_modules/core-js/internals/fails.js"(exports, module) {
      module.exports = function (exec) {
        try {
          return !!exec();
        } catch (error) {
          return true;
        }
      };
    },
  });
  // node_modules/core-js/internals/descriptors.js
  var require_descriptors = __commonJS({
    "node_modules/core-js/internals/descriptors.js"(exports, module) {
      var fails = require_fails();
      module.exports = !fails(function () {
        return (
          Object.defineProperty({}, 1, {
            get: function get() {
              return 7;
            },
          })[1] != 7
        );
      });
    },
  });
  // node_modules/core-js/internals/function-bind-native.js
  var require_function_bind_native = __commonJS({
    "node_modules/core-js/internals/function-bind-native.js"(exports, module) {
      var fails = require_fails();
      module.exports = !fails(function () {
        var test = function () {}.bind();
        return typeof test != "function" || test.hasOwnProperty("prototype");
      });
    },
  });
  // node_modules/core-js/internals/function-call.js
  var require_function_call = __commonJS({
    "node_modules/core-js/internals/function-call.js"(exports, module) {
      var NATIVE_BIND = require_function_bind_native();
      var call = Function.prototype.call;
      module.exports = NATIVE_BIND
        ? call.bind(call)
        : function () {
            return call.apply(call, arguments);
          };
    },
  });
  // node_modules/core-js/internals/object-property-is-enumerable.js
  var require_object_property_is_enumerable = __commonJS({
    "node_modules/core-js/internals/object-property-is-enumerable.js"(exports) {
      "use strict";
      var $propertyIsEnumerable = {}.propertyIsEnumerable;
      var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var NASHORN_BUG =
        getOwnPropertyDescriptor &&
        !$propertyIsEnumerable.call(
          {
            1: 2,
          },
          1
        );
      exports.f = NASHORN_BUG
        ? /* @__PURE__ */ __name(function propertyIsEnumerable(V) {
            var descriptor = getOwnPropertyDescriptor(this, V);
            return !!descriptor && descriptor.enumerable;
          }, "propertyIsEnumerable")
        : $propertyIsEnumerable;
    },
  });
  // node_modules/core-js/internals/create-property-descriptor.js
  var require_create_property_descriptor = __commonJS({
    "node_modules/core-js/internals/create-property-descriptor.js"(exports, module) {
      module.exports = function (bitmap, value) {
        return {
          enumerable: !(bitmap & 1),
          configurable: !(bitmap & 2),
          writable: !(bitmap & 4),
          value,
        };
      };
    },
  });
  // node_modules/core-js/internals/function-uncurry-this.js
  var require_function_uncurry_this = __commonJS({
    "node_modules/core-js/internals/function-uncurry-this.js"(exports, module) {
      var NATIVE_BIND = require_function_bind_native();
      var FunctionPrototype = Function.prototype;
      var call = FunctionPrototype.call;
      var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
      module.exports = NATIVE_BIND
        ? uncurryThisWithBind
        : function (fn) {
            return function () {
              return call.apply(fn, arguments);
            };
          };
    },
  });
  // node_modules/core-js/internals/classof-raw.js
  var require_classof_raw = __commonJS({
    "node_modules/core-js/internals/classof-raw.js"(exports, module) {
      var uncurryThis = require_function_uncurry_this();
      var toString = uncurryThis({}.toString);
      var stringSlice = uncurryThis("".slice);
      module.exports = function (it) {
        return stringSlice(toString(it), 8, -1);
      };
    },
  });
  // node_modules/core-js/internals/indexed-object.js
  var require_indexed_object = __commonJS({
    "node_modules/core-js/internals/indexed-object.js"(exports, module) {
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var classof = require_classof_raw();
      var $Object = Object;
      var split = uncurryThis("".split);
      module.exports = fails(function () {
        return !$Object("z").propertyIsEnumerable(0);
      })
        ? function (it) {
            return classof(it) == "String" ? split(it, "") : $Object(it);
          }
        : $Object;
    },
  });
  // node_modules/core-js/internals/is-null-or-undefined.js
  var require_is_null_or_undefined = __commonJS({
    "node_modules/core-js/internals/is-null-or-undefined.js"(exports, module) {
      module.exports = function (it) {
        return it === null || it === void 0;
      };
    },
  });
  // node_modules/core-js/internals/require-object-coercible.js
  var require_require_object_coercible = __commonJS({
    "node_modules/core-js/internals/require-object-coercible.js"(exports, module) {
      var isNullOrUndefined = require_is_null_or_undefined();
      var $TypeError = TypeError;
      module.exports = function (it) {
        if (isNullOrUndefined(it)) throw $TypeError("Can't call method on " + it);
        return it;
      };
    },
  });
  // node_modules/core-js/internals/to-indexed-object.js
  var require_to_indexed_object = __commonJS({
    "node_modules/core-js/internals/to-indexed-object.js"(exports, module) {
      var IndexedObject = require_indexed_object();
      var requireObjectCoercible = require_require_object_coercible();
      module.exports = function (it) {
        return IndexedObject(requireObjectCoercible(it));
      };
    },
  });
  // node_modules/core-js/internals/document-all.js
  var require_document_all = __commonJS({
    "node_modules/core-js/internals/document-all.js"(exports, module) {
      var documentAll = typeof document == "object" && document.all;
      var IS_HTMLDDA = typeof documentAll == "undefined" && documentAll !== void 0;
      module.exports = {
        all: documentAll,
        IS_HTMLDDA,
      };
    },
  });
  // node_modules/core-js/internals/is-callable.js
  var require_is_callable = __commonJS({
    "node_modules/core-js/internals/is-callable.js"(exports, module) {
      var $documentAll = require_document_all();
      var documentAll = $documentAll.all;
      module.exports = $documentAll.IS_HTMLDDA
        ? function (argument) {
            return typeof argument == "function" || argument === documentAll;
          }
        : function (argument) {
            return typeof argument == "function";
          };
    },
  });
  // node_modules/core-js/internals/is-object.js
  var require_is_object = __commonJS({
    "node_modules/core-js/internals/is-object.js"(exports, module) {
      var isCallable = require_is_callable();
      var $documentAll = require_document_all();
      var documentAll = $documentAll.all;
      module.exports = $documentAll.IS_HTMLDDA
        ? function (it) {
            return typeof it == "object" ? it !== null : isCallable(it) || it === documentAll;
          }
        : function (it) {
            return typeof it == "object" ? it !== null : isCallable(it);
          };
    },
  });
  // node_modules/core-js/internals/get-built-in.js
  var require_get_built_in = __commonJS({
    "node_modules/core-js/internals/get-built-in.js"(exports, module) {
      var global2 = require_global();
      var isCallable = require_is_callable();
      var aFunction = /* @__PURE__ */ __name(function (argument) {
        return isCallable(argument) ? argument : void 0;
      }, "aFunction");
      module.exports = function (namespace, method) {
        return arguments.length < 2 ? aFunction(global2[namespace]) : global2[namespace] && global2[namespace][method];
      };
    },
  });
  // node_modules/core-js/internals/object-is-prototype-of.js
  var require_object_is_prototype_of = __commonJS({
    "node_modules/core-js/internals/object-is-prototype-of.js"(exports, module) {
      var uncurryThis = require_function_uncurry_this();
      module.exports = uncurryThis({}.isPrototypeOf);
    },
  });
  // node_modules/core-js/internals/engine-user-agent.js
  var require_engine_user_agent = __commonJS({
    "node_modules/core-js/internals/engine-user-agent.js"(exports, module) {
      var getBuiltIn = require_get_built_in();
      module.exports = getBuiltIn("navigator", "userAgent") || "";
    },
  });
  // node_modules/core-js/internals/engine-v8-version.js
  var require_engine_v8_version = __commonJS({
    "node_modules/core-js/internals/engine-v8-version.js"(exports, module) {
      var global2 = require_global();
      var userAgent = require_engine_user_agent();
      var process2 = global2.process;
      var Deno = global2.Deno;
      var versions = (process2 && process2.versions) || (Deno && Deno.version);
      var v8 = versions && versions.v8;
      var match;
      var version;
      if (v8) {
        match = v8.split(".");
        version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
      }
      if (!version && userAgent) {
        match = userAgent.match(/Edge\/(\d+)/);
        if (!match || match[1] >= 74) {
          match = userAgent.match(/Chrome\/(\d+)/);
          if (match) version = +match[1];
        }
      }
      module.exports = version;
    },
  });
  // node_modules/core-js/internals/symbol-constructor-detection.js
  var require_symbol_constructor_detection = __commonJS({
    "node_modules/core-js/internals/symbol-constructor-detection.js"(exports, module) {
      var V8_VERSION = require_engine_v8_version();
      var fails = require_fails();
      module.exports =
        !!Object.getOwnPropertySymbols &&
        !fails(function () {
          var symbol = Symbol();
          return !String(symbol) || !(Object(symbol) instanceof Symbol) || (!Symbol.sham && V8_VERSION && V8_VERSION < 41);
        });
    },
  });
  // node_modules/core-js/internals/use-symbol-as-uid.js
  var require_use_symbol_as_uid = __commonJS({
    "node_modules/core-js/internals/use-symbol-as-uid.js"(exports, module) {
      var NATIVE_SYMBOL = require_symbol_constructor_detection();
      module.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
    },
  });
  // node_modules/core-js/internals/is-symbol.js
  var require_is_symbol = __commonJS({
    "node_modules/core-js/internals/is-symbol.js"(exports, module) {
      var getBuiltIn = require_get_built_in();
      var isCallable = require_is_callable();
      var isPrototypeOf = require_object_is_prototype_of();
      var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
      var $Object = Object;
      module.exports = USE_SYMBOL_AS_UID
        ? function (it) {
            return typeof it == "symbol";
          }
        : function (it) {
            var $Symbol = getBuiltIn("Symbol");
            return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
          };
    },
  });
  // node_modules/core-js/internals/try-to-string.js
  var require_try_to_string = __commonJS({
    "node_modules/core-js/internals/try-to-string.js"(exports, module) {
      var $String = String;
      module.exports = function (argument) {
        try {
          return $String(argument);
        } catch (error) {
          return "Object";
        }
      };
    },
  });
  // node_modules/core-js/internals/a-callable.js
  var require_a_callable = __commonJS({
    "node_modules/core-js/internals/a-callable.js"(exports, module) {
      var isCallable = require_is_callable();
      var tryToString = require_try_to_string();
      var $TypeError = TypeError;
      module.exports = function (argument) {
        if (isCallable(argument)) return argument;
        throw $TypeError(tryToString(argument) + " is not a function");
      };
    },
  });
  // node_modules/core-js/internals/get-method.js
  var require_get_method = __commonJS({
    "node_modules/core-js/internals/get-method.js"(exports, module) {
      var aCallable2 = require_a_callable();
      var isNullOrUndefined = require_is_null_or_undefined();
      module.exports = function (V, P) {
        var func = V[P];
        return isNullOrUndefined(func) ? void 0 : aCallable2(func);
      };
    },
  });
  // node_modules/core-js/internals/ordinary-to-primitive.js
  var require_ordinary_to_primitive = __commonJS({
    "node_modules/core-js/internals/ordinary-to-primitive.js"(exports, module) {
      var call = require_function_call();
      var isCallable = require_is_callable();
      var isObject = require_is_object();
      var $TypeError = TypeError;
      module.exports = function (input, pref) {
        var fn, val;
        if (pref === "string" && isCallable((fn = input.toString)) && !isObject((val = call(fn, input)))) return val;
        if (isCallable((fn = input.valueOf)) && !isObject((val = call(fn, input)))) return val;
        if (pref !== "string" && isCallable((fn = input.toString)) && !isObject((val = call(fn, input)))) return val;
        throw $TypeError("Can't convert object to primitive value");
      };
    },
  });
  // node_modules/core-js/internals/is-pure.js
  var require_is_pure = __commonJS({
    "node_modules/core-js/internals/is-pure.js"(exports, module) {
      module.exports = false;
    },
  });
  // node_modules/core-js/internals/define-global-property.js
  var require_define_global_property = __commonJS({
    "node_modules/core-js/internals/define-global-property.js"(exports, module) {
      var global2 = require_global();
      var defineProperty = Object.defineProperty;
      module.exports = function (key, value) {
        try {
          defineProperty(global2, key, {
            value,
            configurable: true,
            writable: true,
          });
        } catch (error) {
          global2[key] = value;
        }
        return value;
      };
    },
  });
  // node_modules/core-js/internals/shared-store.js
  var require_shared_store = __commonJS({
    "node_modules/core-js/internals/shared-store.js"(exports, module) {
      var global2 = require_global();
      var defineGlobalProperty = require_define_global_property();
      var SHARED = "__core-js_shared__";
      var store = global2[SHARED] || defineGlobalProperty(SHARED, {});
      module.exports = store;
    },
  });
  // node_modules/core-js/internals/shared.js
  var require_shared = __commonJS({
    "node_modules/core-js/internals/shared.js"(exports, module) {
      var IS_PURE = require_is_pure();
      var store = require_shared_store();
      (module.exports = function (key, value) {
        return store[key] || (store[key] = value !== void 0 ? value : {});
      })("versions", []).push({
        version: "3.26.1",
        mode: IS_PURE ? "pure" : "global",
        copyright: "\xa9 2014-2022 Denis Pushkarev (zloirock.ru)",
        license: "https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE",
        source: "https://github.com/zloirock/core-js",
      });
    },
  });
  // node_modules/core-js/internals/to-object.js
  var require_to_object = __commonJS({
    "node_modules/core-js/internals/to-object.js"(exports, module) {
      var requireObjectCoercible = require_require_object_coercible();
      var $Object = Object;
      module.exports = function (argument) {
        return $Object(requireObjectCoercible(argument));
      };
    },
  });
  // node_modules/core-js/internals/has-own-property.js
  var require_has_own_property = __commonJS({
    "node_modules/core-js/internals/has-own-property.js"(exports, module) {
      var uncurryThis = require_function_uncurry_this();
      var toObject2 = require_to_object();
      var hasOwnProperty = uncurryThis({}.hasOwnProperty);
      module.exports =
        Object.hasOwn ||
        /* @__PURE__ */ __name(function hasOwn(it, key) {
          return hasOwnProperty(toObject2(it), key);
        }, "hasOwn");
    },
  });
  // node_modules/core-js/internals/uid.js
  var require_uid = __commonJS({
    "node_modules/core-js/internals/uid.js"(exports, module) {
      var uncurryThis = require_function_uncurry_this();
      var id = 0;
      var postfix = Math.random();
      var toString = uncurryThis((1).toString);
      module.exports = function (key) {
        return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString(++id + postfix, 36);
      };
    },
  });
  // node_modules/core-js/internals/well-known-symbol.js
  var require_well_known_symbol = __commonJS({
    "node_modules/core-js/internals/well-known-symbol.js"(exports, module) {
      var global2 = require_global();
      var shared = require_shared();
      var hasOwn = require_has_own_property();
      var uid = require_uid();
      var NATIVE_SYMBOL = require_symbol_constructor_detection();
      var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
      var WellKnownSymbolsStore = shared("wks");
      var Symbol2 = global2.Symbol;
      var symbolFor = Symbol2 && Symbol2["for"];
      var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2 : (Symbol2 && Symbol2.withoutSetter) || uid;
      module.exports = function (name2) {
        if (!hasOwn(WellKnownSymbolsStore, name2) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name2] == "string")) {
          var description = "Symbol." + name2;
          if (NATIVE_SYMBOL && hasOwn(Symbol2, name2)) {
            WellKnownSymbolsStore[name2] = Symbol2[name2];
          } else if (USE_SYMBOL_AS_UID && symbolFor) {
            WellKnownSymbolsStore[name2] = symbolFor(description);
          } else {
            WellKnownSymbolsStore[name2] = createWellKnownSymbol(description);
          }
        }
        return WellKnownSymbolsStore[name2];
      };
    },
  });
  // node_modules/core-js/internals/to-primitive.js
  var require_to_primitive = __commonJS({
    "node_modules/core-js/internals/to-primitive.js"(exports, module) {
      var call = require_function_call();
      var isObject = require_is_object();
      var isSymbol = require_is_symbol();
      var getMethod = require_get_method();
      var ordinaryToPrimitive = require_ordinary_to_primitive();
      var wellKnownSymbol = require_well_known_symbol();
      var $TypeError = TypeError;
      var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
      module.exports = function (input, pref) {
        if (!isObject(input) || isSymbol(input)) return input;
        var exoticToPrim = getMethod(input, TO_PRIMITIVE);
        var result;
        if (exoticToPrim) {
          if (pref === void 0) pref = "default";
          result = call(exoticToPrim, input, pref);
          if (!isObject(result) || isSymbol(result)) return result;
          throw $TypeError("Can't convert object to primitive value");
        }
        if (pref === void 0) pref = "number";
        return ordinaryToPrimitive(input, pref);
      };
    },
  });
  // node_modules/core-js/internals/to-property-key.js
  var require_to_property_key = __commonJS({
    "node_modules/core-js/internals/to-property-key.js"(exports, module) {
      var toPrimitive = require_to_primitive();
      var isSymbol = require_is_symbol();
      module.exports = function (argument) {
        var key = toPrimitive(argument, "string");
        return isSymbol(key) ? key : key + "";
      };
    },
  });
  // node_modules/core-js/internals/document-create-element.js
  var require_document_create_element = __commonJS({
    "node_modules/core-js/internals/document-create-element.js"(exports, module) {
      var global2 = require_global();
      var isObject = require_is_object();
      var document2 = global2.document;
      var EXISTS = isObject(document2) && isObject(document2.createElement);
      module.exports = function (it) {
        return EXISTS ? document2.createElement(it) : {};
      };
    },
  });
  // node_modules/core-js/internals/ie8-dom-define.js
  var require_ie8_dom_define = __commonJS({
    "node_modules/core-js/internals/ie8-dom-define.js"(exports, module) {
      var DESCRIPTORS = require_descriptors();
      var fails = require_fails();
      var createElement = require_document_create_element();
      module.exports =
        !DESCRIPTORS &&
        !fails(function () {
          return (
            Object.defineProperty(createElement("div"), "a", {
              get: function get() {
                return 7;
              },
            }).a != 7
          );
        });
    },
  });
  // node_modules/core-js/internals/object-get-own-property-descriptor.js
  var require_object_get_own_property_descriptor = __commonJS({
    "node_modules/core-js/internals/object-get-own-property-descriptor.js"(exports) {
      var DESCRIPTORS = require_descriptors();
      var call = require_function_call();
      var propertyIsEnumerableModule = require_object_property_is_enumerable();
      var createPropertyDescriptor = require_create_property_descriptor();
      var toIndexedObject = require_to_indexed_object();
      var toPropertyKey = require_to_property_key();
      var hasOwn = require_has_own_property();
      var IE8_DOM_DEFINE = require_ie8_dom_define();
      var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      exports.f = DESCRIPTORS
        ? $getOwnPropertyDescriptor
        : /* @__PURE__ */ __name(function getOwnPropertyDescriptor(O, P) {
            O = toIndexedObject(O);
            P = toPropertyKey(P);
            if (IE8_DOM_DEFINE)
              try {
                return $getOwnPropertyDescriptor(O, P);
              } catch (error) {}
            if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
          }, "getOwnPropertyDescriptor");
    },
  });
  // node_modules/core-js/internals/v8-prototype-define-bug.js
  var require_v8_prototype_define_bug = __commonJS({
    "node_modules/core-js/internals/v8-prototype-define-bug.js"(exports, module) {
      var DESCRIPTORS = require_descriptors();
      var fails = require_fails();
      module.exports =
        DESCRIPTORS &&
        fails(function () {
          return (
            Object.defineProperty(function () {}, "prototype", {
              value: 42,
              writable: false,
            }).prototype != 42
          );
        });
    },
  });
  // node_modules/core-js/internals/an-object.js
  var require_an_object = __commonJS({
    "node_modules/core-js/internals/an-object.js"(exports, module) {
      var isObject = require_is_object();
      var $String = String;
      var $TypeError = TypeError;
      module.exports = function (argument) {
        if (isObject(argument)) return argument;
        throw $TypeError($String(argument) + " is not an object");
      };
    },
  });
  // node_modules/core-js/internals/object-define-property.js
  var require_object_define_property = __commonJS({
    "node_modules/core-js/internals/object-define-property.js"(exports) {
      var DESCRIPTORS = require_descriptors();
      var IE8_DOM_DEFINE = require_ie8_dom_define();
      var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
      var anObject = require_an_object();
      var toPropertyKey = require_to_property_key();
      var $TypeError = TypeError;
      var $defineProperty = Object.defineProperty;
      var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var ENUMERABLE = "enumerable";
      var CONFIGURABLE = "configurable";
      var WRITABLE = "writable";
      exports.f = DESCRIPTORS
        ? V8_PROTOTYPE_DEFINE_BUG
          ? /* @__PURE__ */ __name(function defineProperty(O, P, Attributes) {
              anObject(O);
              P = toPropertyKey(P);
              anObject(Attributes);
              if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
                var current = $getOwnPropertyDescriptor(O, P);
                if (current && current[WRITABLE]) {
                  O[P] = Attributes.value;
                  Attributes = {
                    configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
                    enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
                    writable: false,
                  };
                }
              }
              return $defineProperty(O, P, Attributes);
            }, "defineProperty")
          : $defineProperty
        : /* @__PURE__ */ __name(function defineProperty(O, P, Attributes) {
            anObject(O);
            P = toPropertyKey(P);
            anObject(Attributes);
            if (IE8_DOM_DEFINE)
              try {
                return $defineProperty(O, P, Attributes);
              } catch (error) {}
            if ("get" in Attributes || "set" in Attributes) throw $TypeError("Accessors not supported");
            if ("value" in Attributes) O[P] = Attributes.value;
            return O;
          }, "defineProperty");
    },
  });
  // node_modules/core-js/internals/create-non-enumerable-property.js
  var require_create_non_enumerable_property = __commonJS({
    "node_modules/core-js/internals/create-non-enumerable-property.js"(exports, module) {
      var DESCRIPTORS = require_descriptors();
      var definePropertyModule = require_object_define_property();
      var createPropertyDescriptor = require_create_property_descriptor();
      module.exports = DESCRIPTORS
        ? function (object, key, value) {
            return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
          }
        : function (object, key, value) {
            object[key] = value;
            return object;
          };
    },
  });
  // node_modules/core-js/internals/function-name.js
  var require_function_name = __commonJS({
    "node_modules/core-js/internals/function-name.js"(exports, module) {
      var DESCRIPTORS = require_descriptors();
      var hasOwn = require_has_own_property();
      var FunctionPrototype = Function.prototype;
      var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
      var EXISTS = hasOwn(FunctionPrototype, "name");
      var PROPER = EXISTS && /* @__PURE__ */ __name(function something() {}, "something").name === "something";
      var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable));
      module.exports = {
        EXISTS,
        PROPER,
        CONFIGURABLE,
      };
    },
  });
  // node_modules/core-js/internals/inspect-source.js
  var require_inspect_source = __commonJS({
    "node_modules/core-js/internals/inspect-source.js"(exports, module) {
      var uncurryThis = require_function_uncurry_this();
      var isCallable = require_is_callable();
      var store = require_shared_store();
      var functionToString = uncurryThis(Function.toString);
      if (!isCallable(store.inspectSource)) {
        store.inspectSource = function (it) {
          return functionToString(it);
        };
      }
      module.exports = store.inspectSource;
    },
  });
  // node_modules/core-js/internals/weak-map-basic-detection.js
  var require_weak_map_basic_detection = __commonJS({
    "node_modules/core-js/internals/weak-map-basic-detection.js"(exports, module) {
      var global2 = require_global();
      var isCallable = require_is_callable();
      var WeakMap2 = global2.WeakMap;
      module.exports = isCallable(WeakMap2) && /native code/.test(String(WeakMap2));
    },
  });
  // node_modules/core-js/internals/shared-key.js
  var require_shared_key = __commonJS({
    "node_modules/core-js/internals/shared-key.js"(exports, module) {
      var shared = require_shared();
      var uid = require_uid();
      var keys = shared("keys");
      module.exports = function (key) {
        return keys[key] || (keys[key] = uid(key));
      };
    },
  });
  // node_modules/core-js/internals/hidden-keys.js
  var require_hidden_keys = __commonJS({
    "node_modules/core-js/internals/hidden-keys.js"(exports, module) {
      module.exports = {};
    },
  });
  // node_modules/core-js/internals/internal-state.js
  var require_internal_state = __commonJS({
    "node_modules/core-js/internals/internal-state.js"(exports, module) {
      var NATIVE_WEAK_MAP = require_weak_map_basic_detection();
      var global2 = require_global();
      var isObject = require_is_object();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var hasOwn = require_has_own_property();
      var shared = require_shared_store();
      var sharedKey = require_shared_key();
      var hiddenKeys = require_hidden_keys();
      var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
      var TypeError2 = global2.TypeError;
      var WeakMap2 = global2.WeakMap;
      var set;
      var get;
      var has;
      var enforce = /* @__PURE__ */ __name(function (it) {
        return has(it) ? get(it) : set(it, {});
      }, "enforce");
      var getterFor = /* @__PURE__ */ __name(function (TYPE) {
        return function (it) {
          var state;
          if (!isObject(it) || (state = get(it)).type !== TYPE) {
            throw TypeError2("Incompatible receiver, " + TYPE + " required");
          }
          return state;
        };
      }, "getterFor");
      if (NATIVE_WEAK_MAP || shared.state) {
        store = shared.state || (shared.state = new WeakMap2());
        store.get = store.get;
        store.has = store.has;
        store.set = store.set;
        set = /* @__PURE__ */ __name(function (it, metadata) {
          if (store.has(it)) throw TypeError2(OBJECT_ALREADY_INITIALIZED);
          metadata.facade = it;
          store.set(it, metadata);
          return metadata;
        }, "set");
        get = /* @__PURE__ */ __name(function (it) {
          return store.get(it) || {};
        }, "get");
        has = /* @__PURE__ */ __name(function (it) {
          return store.has(it);
        }, "has");
      } else {
        STATE = sharedKey("state");
        hiddenKeys[STATE] = true;
        set = /* @__PURE__ */ __name(function (it, metadata) {
          if (hasOwn(it, STATE)) throw TypeError2(OBJECT_ALREADY_INITIALIZED);
          metadata.facade = it;
          createNonEnumerableProperty(it, STATE, metadata);
          return metadata;
        }, "set");
        get = /* @__PURE__ */ __name(function (it) {
          return hasOwn(it, STATE) ? it[STATE] : {};
        }, "get");
        has = /* @__PURE__ */ __name(function (it) {
          return hasOwn(it, STATE);
        }, "has");
      }
      var store;
      var STATE;
      module.exports = {
        set,
        get,
        has,
        enforce,
        getterFor,
      };
    },
  });
  // node_modules/core-js/internals/make-built-in.js
  var require_make_built_in = __commonJS({
    "node_modules/core-js/internals/make-built-in.js"(exports, module) {
      var fails = require_fails();
      var isCallable = require_is_callable();
      var hasOwn = require_has_own_property();
      var DESCRIPTORS = require_descriptors();
      var CONFIGURABLE_FUNCTION_NAME = require_function_name().CONFIGURABLE;
      var inspectSource = require_inspect_source();
      var InternalStateModule = require_internal_state();
      var enforceInternalState = InternalStateModule.enforce;
      var getInternalState = InternalStateModule.get;
      var defineProperty = Object.defineProperty;
      var CONFIGURABLE_LENGTH =
        DESCRIPTORS &&
        !fails(function () {
          return (
            defineProperty(function () {}, "length", {
              value: 8,
            }).length !== 8
          );
        });
      var TEMPLATE = String(String).split("String");
      var makeBuiltIn = (module.exports = function makeBuiltIn(value, name2, options) {
        if (String(name2).slice(0, 7) === "Symbol(") {
          name2 = "[" + String(name2).replace(/^Symbol\(([^)]*)\)/, "$1") + "]";
        }
        if (options && options.getter) name2 = "get " + name2;
        if (options && options.setter) name2 = "set " + name2;
        if (!hasOwn(value, "name") || (CONFIGURABLE_FUNCTION_NAME && value.name !== name2)) {
          if (DESCRIPTORS)
            defineProperty(value, "name", {
              value: name2,
              configurable: true,
            });
          else value.name = name2;
        }
        if (CONFIGURABLE_LENGTH && options && hasOwn(options, "arity") && value.length !== options.arity) {
          defineProperty(value, "length", {
            value: options.arity,
          });
        }
        try {
          if (options && hasOwn(options, "constructor") && options.constructor) {
            if (DESCRIPTORS)
              defineProperty(value, "prototype", {
                writable: false,
              });
          } else if (value.prototype) value.prototype = void 0;
        } catch (error) {}
        var state = enforceInternalState(value);
        if (!hasOwn(state, "source")) {
          state.source = TEMPLATE.join(typeof name2 == "string" ? name2 : "");
        }
        return value;
      });
      Function.prototype.toString = makeBuiltIn(
        /* @__PURE__ */ __name(function toString() {
          return (isCallable(this) && getInternalState(this).source) || inspectSource(this);
        }, "toString"),
        "toString"
      );
    },
  });
  // node_modules/core-js/internals/define-built-in.js
  var require_define_built_in = __commonJS({
    "node_modules/core-js/internals/define-built-in.js"(exports, module) {
      var isCallable = require_is_callable();
      var definePropertyModule = require_object_define_property();
      var makeBuiltIn = require_make_built_in();
      var defineGlobalProperty = require_define_global_property();
      module.exports = function (O, key, value, options) {
        if (!options) options = {};
        var simple = options.enumerable;
        var name2 = options.name !== void 0 ? options.name : key;
        if (isCallable(value)) makeBuiltIn(value, name2, options);
        if (options.global) {
          if (simple) O[key] = value;
          else defineGlobalProperty(key, value);
        } else {
          try {
            if (!options.unsafe) delete O[key];
            else if (O[key]) simple = true;
          } catch (error) {}
          if (simple) O[key] = value;
          else
            definePropertyModule.f(O, key, {
              value,
              enumerable: false,
              configurable: !options.nonConfigurable,
              writable: !options.nonWritable,
            });
        }
        return O;
      };
    },
  });
  // node_modules/core-js/internals/math-trunc.js
  var require_math_trunc = __commonJS({
    "node_modules/core-js/internals/math-trunc.js"(exports, module) {
      var ceil = Math.ceil;
      var floor = Math.floor;
      module.exports =
        Math.trunc ||
        /* @__PURE__ */ __name(function trunc(x) {
          var n = +x;
          return (n > 0 ? floor : ceil)(n);
        }, "trunc");
    },
  });
  // node_modules/core-js/internals/to-integer-or-infinity.js
  var require_to_integer_or_infinity = __commonJS({
    "node_modules/core-js/internals/to-integer-or-infinity.js"(exports, module) {
      var trunc = require_math_trunc();
      module.exports = function (argument) {
        var number2 = +argument;
        return number2 !== number2 || number2 === 0 ? 0 : trunc(number2);
      };
    },
  });
  // node_modules/core-js/internals/to-absolute-index.js
  var require_to_absolute_index = __commonJS({
    "node_modules/core-js/internals/to-absolute-index.js"(exports, module) {
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var max = Math.max;
      var min = Math.min;
      module.exports = function (index, length) {
        var integer = toIntegerOrInfinity(index);
        return integer < 0 ? max(integer + length, 0) : min(integer, length);
      };
    },
  });
  // node_modules/core-js/internals/to-length.js
  var require_to_length = __commonJS({
    "node_modules/core-js/internals/to-length.js"(exports, module) {
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var min = Math.min;
      module.exports = function (argument) {
        return argument > 0 ? min(toIntegerOrInfinity(argument), 9007199254740991) : 0;
      };
    },
  });
  // node_modules/core-js/internals/length-of-array-like.js
  var require_length_of_array_like = __commonJS({
    "node_modules/core-js/internals/length-of-array-like.js"(exports, module) {
      var toLength = require_to_length();
      module.exports = function (obj) {
        return toLength(obj.length);
      };
    },
  });
  // node_modules/core-js/internals/array-includes.js
  var require_array_includes = __commonJS({
    "node_modules/core-js/internals/array-includes.js"(exports, module) {
      var toIndexedObject = require_to_indexed_object();
      var toAbsoluteIndex = require_to_absolute_index();
      var lengthOfArrayLike2 = require_length_of_array_like();
      var createMethod = /* @__PURE__ */ __name(function (IS_INCLUDES) {
        return function ($this, el, fromIndex) {
          var O = toIndexedObject($this);
          var length = lengthOfArrayLike2(O);
          var index = toAbsoluteIndex(fromIndex, length);
          var value;
          if (IS_INCLUDES && el != el)
            while (length > index) {
              value = O[index++];
              if (value != value) return true;
            }
          else
            for (; length > index; index++) {
              if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
            }
          return !IS_INCLUDES && -1;
        };
      }, "createMethod");
      module.exports = {
        includes: createMethod(true),
        indexOf: createMethod(false),
      };
    },
  });
  // node_modules/core-js/internals/object-keys-internal.js
  var require_object_keys_internal = __commonJS({
    "node_modules/core-js/internals/object-keys-internal.js"(exports, module) {
      var uncurryThis = require_function_uncurry_this();
      var hasOwn = require_has_own_property();
      var toIndexedObject = require_to_indexed_object();
      var indexOf = require_array_includes().indexOf;
      var hiddenKeys = require_hidden_keys();
      var push = uncurryThis([].push);
      module.exports = function (object, names) {
        var O = toIndexedObject(object);
        var i = 0;
        var result = [];
        var key;
        for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
        while (names.length > i)
          if (hasOwn(O, (key = names[i++]))) {
            ~indexOf(result, key) || push(result, key);
          }
        return result;
      };
    },
  });
  // node_modules/core-js/internals/enum-bug-keys.js
  var require_enum_bug_keys = __commonJS({
    "node_modules/core-js/internals/enum-bug-keys.js"(exports, module) {
      module.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
    },
  });
  // node_modules/core-js/internals/object-get-own-property-names.js
  var require_object_get_own_property_names = __commonJS({
    "node_modules/core-js/internals/object-get-own-property-names.js"(exports) {
      var internalObjectKeys = require_object_keys_internal();
      var enumBugKeys = require_enum_bug_keys();
      var hiddenKeys = enumBugKeys.concat("length", "prototype");
      exports.f =
        Object.getOwnPropertyNames ||
        /* @__PURE__ */ __name(function getOwnPropertyNames(O) {
          return internalObjectKeys(O, hiddenKeys);
        }, "getOwnPropertyNames");
    },
  });
  // node_modules/core-js/internals/object-get-own-property-symbols.js
  var require_object_get_own_property_symbols = __commonJS({
    "node_modules/core-js/internals/object-get-own-property-symbols.js"(exports) {
      exports.f = Object.getOwnPropertySymbols;
    },
  });
  // node_modules/core-js/internals/own-keys.js
  var require_own_keys = __commonJS({
    "node_modules/core-js/internals/own-keys.js"(exports, module) {
      var getBuiltIn = require_get_built_in();
      var uncurryThis = require_function_uncurry_this();
      var getOwnPropertyNamesModule = require_object_get_own_property_names();
      var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
      var anObject = require_an_object();
      var concat = uncurryThis([].concat);
      module.exports =
        getBuiltIn("Reflect", "ownKeys") ||
        /* @__PURE__ */ __name(function ownKeys(it) {
          var keys = getOwnPropertyNamesModule.f(anObject(it));
          var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
          return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
        }, "ownKeys");
    },
  });
  // node_modules/core-js/internals/copy-constructor-properties.js
  var require_copy_constructor_properties = __commonJS({
    "node_modules/core-js/internals/copy-constructor-properties.js"(exports, module) {
      var hasOwn = require_has_own_property();
      var ownKeys = require_own_keys();
      var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
      var definePropertyModule = require_object_define_property();
      module.exports = function (target, source, exceptions) {
        var keys = ownKeys(source);
        var defineProperty = definePropertyModule.f;
        var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
            defineProperty(target, key, getOwnPropertyDescriptor(source, key));
          }
        }
      };
    },
  });
  // node_modules/core-js/internals/is-forced.js
  var require_is_forced = __commonJS({
    "node_modules/core-js/internals/is-forced.js"(exports, module) {
      var fails = require_fails();
      var isCallable = require_is_callable();
      var replacement = /#|\.prototype\./;
      var isForced = /* @__PURE__ */ __name(function (feature, detection) {
        var value = data[normalize(feature)];
        return value == POLYFILL ? true : value == NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
      }, "isForced");
      var normalize = (isForced.normalize = function normalize(string2) {
        return String(string2).replace(replacement, ".").toLowerCase();
      });
      var data = (isForced.data = {});
      var NATIVE = (isForced.NATIVE = "N");
      var POLYFILL = (isForced.POLYFILL = "P");
      module.exports = isForced;
    },
  });
  // node_modules/core-js/internals/export.js
  var require_export = __commonJS({
    "node_modules/core-js/internals/export.js"(exports, module) {
      var global2 = require_global();
      var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var defineBuiltIn = require_define_built_in();
      var defineGlobalProperty = require_define_global_property();
      var copyConstructorProperties = require_copy_constructor_properties();
      var isForced = require_is_forced();
      module.exports = function (options, source) {
        var TARGET = options.target;
        var GLOBAL = options.global;
        var STATIC = options.stat;
        var FORCED, target, key, targetProperty, sourceProperty, descriptor;
        if (GLOBAL) {
          target = global2;
        } else if (STATIC) {
          target = global2[TARGET] || defineGlobalProperty(TARGET, {});
        } else {
          target = (global2[TARGET] || {}).prototype;
        }
        if (target)
          for (key in source) {
            sourceProperty = source[key];
            if (options.dontCallGetSet) {
              descriptor = getOwnPropertyDescriptor(target, key);
              targetProperty = descriptor && descriptor.value;
            } else targetProperty = target[key];
            FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
            if (!FORCED && targetProperty !== void 0) {
              if (typeof sourceProperty == typeof targetProperty) continue;
              copyConstructorProperties(sourceProperty, targetProperty);
            }
            if (options.sham || (targetProperty && targetProperty.sham)) {
              createNonEnumerableProperty(sourceProperty, "sham", true);
            }
            defineBuiltIn(target, key, sourceProperty, options);
          }
      };
    },
  });
  // node_modules/core-js/internals/is-array.js
  var require_is_array = __commonJS({
    "node_modules/core-js/internals/is-array.js"(exports, module) {
      var classof = require_classof_raw();
      module.exports =
        Array.isArray ||
        /* @__PURE__ */ __name(function isArray(argument) {
          return classof(argument) == "Array";
        }, "isArray");
    },
  });
  // node_modules/core-js/internals/does-not-exceed-safe-integer.js
  var require_does_not_exceed_safe_integer = __commonJS({
    "node_modules/core-js/internals/does-not-exceed-safe-integer.js"(exports, module) {
      var $TypeError = TypeError;
      var MAX_SAFE_INTEGER = 9007199254740991;
      module.exports = function (it) {
        if (it > MAX_SAFE_INTEGER) throw $TypeError("Maximum allowed index exceeded");
        return it;
      };
    },
  });
  // node_modules/core-js/internals/function-uncurry-this-clause.js
  var require_function_uncurry_this_clause = __commonJS({
    "node_modules/core-js/internals/function-uncurry-this-clause.js"(exports, module) {
      var classofRaw = require_classof_raw();
      var uncurryThis = require_function_uncurry_this();
      module.exports = function (fn) {
        if (classofRaw(fn) === "Function") return uncurryThis(fn);
      };
    },
  });
  // node_modules/core-js/internals/function-bind-context.js
  var require_function_bind_context = __commonJS({
    "node_modules/core-js/internals/function-bind-context.js"(exports, module) {
      var uncurryThis = require_function_uncurry_this_clause();
      var aCallable2 = require_a_callable();
      var NATIVE_BIND = require_function_bind_native();
      var bind2 = uncurryThis(uncurryThis.bind);
      module.exports = function (fn, that) {
        aCallable2(fn);
        return that === void 0
          ? fn
          : NATIVE_BIND
          ? bind2(fn, that)
          : function () {
              return fn.apply(that, arguments);
            };
      };
    },
  });
  // node_modules/core-js/internals/flatten-into-array.js
  var require_flatten_into_array = __commonJS({
    "node_modules/core-js/internals/flatten-into-array.js"(exports, module) {
      "use strict";
      var isArray = require_is_array();
      var lengthOfArrayLike2 = require_length_of_array_like();
      var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();
      var bind2 = require_function_bind_context();
      var flattenIntoArray2 = /* @__PURE__ */ __name(function (target, original, source, sourceLen, start, depth, mapper, thisArg) {
        var targetIndex = start;
        var sourceIndex = 0;
        var mapFn = mapper ? bind2(mapper, thisArg) : false;
        var element2, elementLen;
        while (sourceIndex < sourceLen) {
          if (sourceIndex in source) {
            element2 = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
            if (depth > 0 && isArray(element2)) {
              elementLen = lengthOfArrayLike2(element2);
              targetIndex = flattenIntoArray2(target, original, element2, elementLen, targetIndex, depth - 1) - 1;
            } else {
              doesNotExceedSafeInteger(targetIndex + 1);
              target[targetIndex] = element2;
            }
            targetIndex++;
          }
          sourceIndex++;
        }
        return targetIndex;
      }, "flattenIntoArray");
      module.exports = flattenIntoArray2;
    },
  });
  // node_modules/core-js/internals/to-string-tag-support.js
  var require_to_string_tag_support = __commonJS({
    "node_modules/core-js/internals/to-string-tag-support.js"(exports, module) {
      var wellKnownSymbol = require_well_known_symbol();
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var test = {};
      test[TO_STRING_TAG] = "z";
      module.exports = String(test) === "[object z]";
    },
  });
  // node_modules/core-js/internals/classof.js
  var require_classof = __commonJS({
    "node_modules/core-js/internals/classof.js"(exports, module) {
      var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
      var isCallable = require_is_callable();
      var classofRaw = require_classof_raw();
      var wellKnownSymbol = require_well_known_symbol();
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var $Object = Object;
      var CORRECT_ARGUMENTS =
        classofRaw(
          (function () {
            return arguments;
          })()
        ) == "Arguments";
      var tryGet = /* @__PURE__ */ __name(function (it, key) {
        try {
          return it[key];
        } catch (error) {}
      }, "tryGet");
      module.exports = TO_STRING_TAG_SUPPORT
        ? classofRaw
        : function (it) {
            var O, tag, result;
            return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet((O = $Object(it)), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && isCallable(O.callee) ? "Arguments" : result;
          };
    },
  });
  // node_modules/core-js/internals/is-constructor.js
  var require_is_constructor = __commonJS({
    "node_modules/core-js/internals/is-constructor.js"(exports, module) {
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var isCallable = require_is_callable();
      var classof = require_classof();
      var getBuiltIn = require_get_built_in();
      var inspectSource = require_inspect_source();
      var noop2 = /* @__PURE__ */ __name(function () {}, "noop");
      var empty2 = [];
      var construct = getBuiltIn("Reflect", "construct");
      var constructorRegExp = /^\s*(?:class|function)\b/;
      var exec = uncurryThis(constructorRegExp.exec);
      var INCORRECT_TO_STRING = !constructorRegExp.exec(noop2);
      var isConstructorModern = /* @__PURE__ */ __name(function isConstructor(argument) {
        if (!isCallable(argument)) return false;
        try {
          construct(noop2, empty2, argument);
          return true;
        } catch (error) {
          return false;
        }
      }, "isConstructor");
      var isConstructorLegacy = /* @__PURE__ */ __name(function isConstructor(argument) {
        if (!isCallable(argument)) return false;
        switch (classof(argument)) {
          case "AsyncFunction":
          case "GeneratorFunction":
          case "AsyncGeneratorFunction":
            return false;
        }
        try {
          return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
        } catch (error) {
          return true;
        }
      }, "isConstructor");
      isConstructorLegacy.sham = true;
      module.exports =
        !construct ||
        fails(function () {
          var called;
          return (
            isConstructorModern(isConstructorModern.call) ||
            !isConstructorModern(Object) ||
            !isConstructorModern(function () {
              called = true;
            }) ||
            called
          );
        })
          ? isConstructorLegacy
          : isConstructorModern;
    },
  });
  // node_modules/core-js/internals/array-species-constructor.js
  var require_array_species_constructor = __commonJS({
    "node_modules/core-js/internals/array-species-constructor.js"(exports, module) {
      var isArray = require_is_array();
      var isConstructor = require_is_constructor();
      var isObject = require_is_object();
      var wellKnownSymbol = require_well_known_symbol();
      var SPECIES = wellKnownSymbol("species");
      var $Array = Array;
      module.exports = function (originalArray) {
        var C2;
        if (isArray(originalArray)) {
          C2 = originalArray.constructor;
          if (isConstructor(C2) && (C2 === $Array || isArray(C2.prototype))) C2 = void 0;
          else if (isObject(C2)) {
            C2 = C2[SPECIES];
            if (C2 === null) C2 = void 0;
          }
        }
        return C2 === void 0 ? $Array : C2;
      };
    },
  });
  // node_modules/core-js/internals/array-species-create.js
  var require_array_species_create = __commonJS({
    "node_modules/core-js/internals/array-species-create.js"(exports, module) {
      var arraySpeciesConstructor = require_array_species_constructor();
      module.exports = function (originalArray, length) {
        return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
      };
    },
  });
  // node_modules/core-js/internals/iterators.js
  var require_iterators = __commonJS({
    "node_modules/core-js/internals/iterators.js"(exports, module) {
      module.exports = {};
    },
  });
  // node_modules/core-js/internals/is-array-iterator-method.js
  var require_is_array_iterator_method = __commonJS({
    "node_modules/core-js/internals/is-array-iterator-method.js"(exports, module) {
      var wellKnownSymbol = require_well_known_symbol();
      var Iterators = require_iterators();
      var ITERATOR = wellKnownSymbol("iterator");
      var ArrayPrototype = Array.prototype;
      module.exports = function (it) {
        return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
      };
    },
  });
  // node_modules/core-js/internals/get-iterator-method.js
  var require_get_iterator_method = __commonJS({
    "node_modules/core-js/internals/get-iterator-method.js"(exports, module) {
      var classof = require_classof();
      var getMethod = require_get_method();
      var isNullOrUndefined = require_is_null_or_undefined();
      var Iterators = require_iterators();
      var wellKnownSymbol = require_well_known_symbol();
      var ITERATOR = wellKnownSymbol("iterator");
      module.exports = function (it) {
        if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR) || getMethod(it, "@@iterator") || Iterators[classof(it)];
      };
    },
  });
  // node_modules/core-js/internals/get-iterator.js
  var require_get_iterator = __commonJS({
    "node_modules/core-js/internals/get-iterator.js"(exports, module) {
      var call = require_function_call();
      var aCallable2 = require_a_callable();
      var anObject = require_an_object();
      var tryToString = require_try_to_string();
      var getIteratorMethod = require_get_iterator_method();
      var $TypeError = TypeError;
      module.exports = function (argument, usingIterator) {
        var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
        if (aCallable2(iteratorMethod)) return anObject(call(iteratorMethod, argument));
        throw $TypeError(tryToString(argument) + " is not iterable");
      };
    },
  });
  // node_modules/core-js/internals/iterator-close.js
  var require_iterator_close = __commonJS({
    "node_modules/core-js/internals/iterator-close.js"(exports, module) {
      var call = require_function_call();
      var anObject = require_an_object();
      var getMethod = require_get_method();
      module.exports = function (iterator, kind, value) {
        var innerResult, innerError;
        anObject(iterator);
        try {
          innerResult = getMethod(iterator, "return");
          if (!innerResult) {
            if (kind === "throw") throw value;
            return value;
          }
          innerResult = call(innerResult, iterator);
        } catch (error) {
          innerError = true;
          innerResult = error;
        }
        if (kind === "throw") throw value;
        if (innerError) throw innerResult;
        anObject(innerResult);
        return value;
      };
    },
  });
  // node_modules/core-js/internals/iterate.js
  var require_iterate = __commonJS({
    "node_modules/core-js/internals/iterate.js"(exports, module) {
      var bind2 = require_function_bind_context();
      var call = require_function_call();
      var anObject = require_an_object();
      var tryToString = require_try_to_string();
      var isArrayIteratorMethod = require_is_array_iterator_method();
      var lengthOfArrayLike2 = require_length_of_array_like();
      var isPrototypeOf = require_object_is_prototype_of();
      var getIterator = require_get_iterator();
      var getIteratorMethod = require_get_iterator_method();
      var iteratorClose = require_iterator_close();
      var $TypeError = TypeError;
      var Result = /* @__PURE__ */ __name(function (stopped, result) {
        this.stopped = stopped;
        this.result = result;
      }, "Result");
      var ResultPrototype = Result.prototype;
      module.exports = function (iterable, unboundFunction, options) {
        var that = options && options.that;
        var AS_ENTRIES = !!(options && options.AS_ENTRIES);
        var IS_RECORD = !!(options && options.IS_RECORD);
        var IS_ITERATOR = !!(options && options.IS_ITERATOR);
        var INTERRUPTED = !!(options && options.INTERRUPTED);
        var fn = bind2(unboundFunction, that);
        var iterator, iterFn, index, length, result, next, step;
        var stop = /* @__PURE__ */ __name(function (condition) {
          if (iterator) iteratorClose(iterator, "normal", condition);
          return new Result(true, condition);
        }, "stop");
        var callFn = /* @__PURE__ */ __name(function (value) {
          if (AS_ENTRIES) {
            anObject(value);
            return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
          }
          return INTERRUPTED ? fn(value, stop) : fn(value);
        }, "callFn");
        if (IS_RECORD) {
          iterator = iterable.iterator;
        } else if (IS_ITERATOR) {
          iterator = iterable;
        } else {
          iterFn = getIteratorMethod(iterable);
          if (!iterFn) throw $TypeError(tryToString(iterable) + " is not iterable");
          if (isArrayIteratorMethod(iterFn)) {
            for (index = 0, length = lengthOfArrayLike2(iterable); length > index; index++) {
              result = callFn(iterable[index]);
              if (result && isPrototypeOf(ResultPrototype, result)) return result;
            }
            return new Result(false);
          }
          iterator = getIterator(iterable, iterFn);
        }
        next = IS_RECORD ? iterable.next : iterator.next;
        while (!(step = call(next, iterator)).done) {
          try {
            result = callFn(step.value);
          } catch (error) {
            iteratorClose(iterator, "throw", error);
          }
          if (typeof result == "object" && result && isPrototypeOf(ResultPrototype, result)) return result;
        }
        return new Result(false);
      };
    },
  });
  // node_modules/core-js/internals/create-property.js
  var require_create_property = __commonJS({
    "node_modules/core-js/internals/create-property.js"(exports, module) {
      "use strict";
      var toPropertyKey = require_to_property_key();
      var definePropertyModule = require_object_define_property();
      var createPropertyDescriptor = require_create_property_descriptor();
      module.exports = function (object, key, value) {
        var propertyKey = toPropertyKey(key);
        if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
        else object[propertyKey] = value;
      };
    },
  });
  // node_modules/core-js/internals/to-string.js
  var require_to_string = __commonJS({
    "node_modules/core-js/internals/to-string.js"(exports, module) {
      var classof = require_classof();
      var $String = String;
      module.exports = function (argument) {
        if (classof(argument) === "Symbol") throw TypeError("Cannot convert a Symbol value to a string");
        return $String(argument);
      };
    },
  });
  // node_modules/core-js/internals/whitespaces.js
  var require_whitespaces = __commonJS({
    "node_modules/core-js/internals/whitespaces.js"(exports, module) {
      module.exports = "	\n\v\f\r \xa0\u2028\u2029\uFEFF";
    },
  });
  // node_modules/core-js/internals/string-trim.js
  var require_string_trim = __commonJS({
    "node_modules/core-js/internals/string-trim.js"(exports, module) {
      var uncurryThis = require_function_uncurry_this();
      var requireObjectCoercible = require_require_object_coercible();
      var toString = require_to_string();
      var whitespaces = require_whitespaces();
      var replace = uncurryThis("".replace);
      var whitespace = "[" + whitespaces + "]";
      var ltrim = RegExp("^" + whitespace + whitespace + "*");
      var rtrim = RegExp(whitespace + whitespace + "*$");
      var createMethod = /* @__PURE__ */ __name(function (TYPE) {
        return function ($this) {
          var string2 = toString(requireObjectCoercible($this));
          if (TYPE & 1) string2 = replace(string2, ltrim, "");
          if (TYPE & 2) string2 = replace(string2, rtrim, "");
          return string2;
        };
      }, "createMethod");
      module.exports = {
        start: createMethod(1),
        end: createMethod(2),
        trim: createMethod(3),
      };
    },
  });
  // node_modules/core-js/internals/string-trim-forced.js
  var require_string_trim_forced = __commonJS({
    "node_modules/core-js/internals/string-trim-forced.js"(exports, module) {
      var PROPER_FUNCTION_NAME = require_function_name().PROPER;
      var fails = require_fails();
      var whitespaces = require_whitespaces();
      var non = "\x85";
      module.exports = function (METHOD_NAME) {
        return fails(function () {
          return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || (PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME);
        });
      };
    },
  });
  // node_modules/core-js/internals/string-trim-end.js
  var require_string_trim_end = __commonJS({
    "node_modules/core-js/internals/string-trim-end.js"(exports, module) {
      "use strict";
      var $trimEnd = require_string_trim().end;
      var forcedStringTrimMethod = require_string_trim_forced();
      module.exports = forcedStringTrimMethod("trimEnd")
        ? /* @__PURE__ */ __name(function trimEnd2() {
            return $trimEnd(this);
          }, "trimEnd")
        : "".trimEnd;
    },
  });
  // node_modules/core-js/modules/es.string.trim-right.js
  var require_es_string_trim_right = __commonJS({
    "node_modules/core-js/modules/es.string.trim-right.js"() {
      var $4 = require_export();
      var trimEnd2 = require_string_trim_end();
      $4(
        {
          target: "String",
          proto: true,
          name: "trimEnd",
          forced: "".trimRight !== trimEnd2,
        },
        {
          trimRight: trimEnd2,
        }
      );
    },
  });
  // node_modules/core-js/internals/object-keys.js
  var require_object_keys = __commonJS({
    "node_modules/core-js/internals/object-keys.js"(exports, module) {
      var internalObjectKeys = require_object_keys_internal();
      var enumBugKeys = require_enum_bug_keys();
      module.exports =
        Object.keys ||
        /* @__PURE__ */ __name(function keys(O) {
          return internalObjectKeys(O, enumBugKeys);
        }, "keys");
    },
  });
  // node_modules/core-js/internals/object-define-properties.js
  var require_object_define_properties = __commonJS({
    "node_modules/core-js/internals/object-define-properties.js"(exports) {
      var DESCRIPTORS = require_descriptors();
      var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
      var definePropertyModule = require_object_define_property();
      var anObject = require_an_object();
      var toIndexedObject = require_to_indexed_object();
      var objectKeys = require_object_keys();
      exports.f =
        DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG
          ? Object.defineProperties
          : /* @__PURE__ */ __name(function defineProperties(O, Properties) {
              anObject(O);
              var props = toIndexedObject(Properties);
              var keys = objectKeys(Properties);
              var length = keys.length;
              var index = 0;
              var key;
              while (length > index) definePropertyModule.f(O, (key = keys[index++]), props[key]);
              return O;
            }, "defineProperties");
    },
  });
  // node_modules/core-js/internals/html.js
  var require_html = __commonJS({
    "node_modules/core-js/internals/html.js"(exports, module) {
      var getBuiltIn = require_get_built_in();
      module.exports = getBuiltIn("document", "documentElement");
    },
  });
  // node_modules/core-js/internals/object-create.js
  var require_object_create = __commonJS({
    "node_modules/core-js/internals/object-create.js"(exports, module) {
      var anObject = require_an_object();
      var definePropertiesModule = require_object_define_properties();
      var enumBugKeys = require_enum_bug_keys();
      var hiddenKeys = require_hidden_keys();
      var html = require_html();
      var documentCreateElement = require_document_create_element();
      var sharedKey = require_shared_key();
      var GT = ">";
      var LT = "<";
      var PROTOTYPE = "prototype";
      var SCRIPT = "script";
      var IE_PROTO = sharedKey("IE_PROTO");
      var EmptyConstructor = /* @__PURE__ */ __name(function () {}, "EmptyConstructor");
      var scriptTag = /* @__PURE__ */ __name(function (content2) {
        return LT + SCRIPT + GT + content2 + LT + "/" + SCRIPT + GT;
      }, "scriptTag");
      var NullProtoObjectViaActiveX = /* @__PURE__ */ __name(function (activeXDocument2) {
        activeXDocument2.write(scriptTag(""));
        activeXDocument2.close();
        var temp = activeXDocument2.parentWindow.Object;
        activeXDocument2 = null;
        return temp;
      }, "NullProtoObjectViaActiveX");
      var NullProtoObjectViaIFrame = /* @__PURE__ */ __name(function () {
        var iframe = documentCreateElement("iframe");
        var JS = "java" + SCRIPT + ":";
        var iframeDocument;
        iframe.style.display = "none";
        html.appendChild(iframe);
        iframe.src = String(JS);
        iframeDocument = iframe.contentWindow.document;
        iframeDocument.open();
        iframeDocument.write(scriptTag("document.F=Object"));
        iframeDocument.close();
        return iframeDocument.F;
      }, "NullProtoObjectViaIFrame");
      var activeXDocument;
      var NullProtoObject = /* @__PURE__ */ __name(function () {
        try {
          activeXDocument = new ActiveXObject("htmlfile");
        } catch (error) {}
        NullProtoObject = typeof document != "undefined" ? (document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame()) : NullProtoObjectViaActiveX(activeXDocument);
        var length = enumBugKeys.length;
        while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
        return NullProtoObject();
      }, "NullProtoObject");
      hiddenKeys[IE_PROTO] = true;
      module.exports =
        Object.create ||
        /* @__PURE__ */ __name(function create(O, Properties) {
          var result;
          if (O !== null) {
            EmptyConstructor[PROTOTYPE] = anObject(O);
            result = new EmptyConstructor();
            EmptyConstructor[PROTOTYPE] = null;
            result[IE_PROTO] = O;
          } else result = NullProtoObject();
          return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
        }, "create");
    },
  });
  // node_modules/core-js/internals/add-to-unscopables.js
  var require_add_to_unscopables = __commonJS({
    "node_modules/core-js/internals/add-to-unscopables.js"(exports, module) {
      var wellKnownSymbol = require_well_known_symbol();
      var create = require_object_create();
      var defineProperty = require_object_define_property().f;
      var UNSCOPABLES = wellKnownSymbol("unscopables");
      var ArrayPrototype = Array.prototype;
      if (ArrayPrototype[UNSCOPABLES] == void 0) {
        defineProperty(ArrayPrototype, UNSCOPABLES, {
          configurable: true,
          value: create(null),
        });
      }
      module.exports = function (key) {
        ArrayPrototype[UNSCOPABLES][key] = true;
      };
    },
  });
  // node_modules/core-js/internals/correct-prototype-getter.js
  var require_correct_prototype_getter = __commonJS({
    "node_modules/core-js/internals/correct-prototype-getter.js"(exports, module) {
      var fails = require_fails();
      module.exports = !fails(function () {
        function F() {}
        __name(F, "F");
        F.prototype.constructor = null;
        return Object.getPrototypeOf(new F()) !== F.prototype;
      });
    },
  });
  // node_modules/core-js/internals/object-get-prototype-of.js
  var require_object_get_prototype_of = __commonJS({
    "node_modules/core-js/internals/object-get-prototype-of.js"(exports, module) {
      var hasOwn = require_has_own_property();
      var isCallable = require_is_callable();
      var toObject2 = require_to_object();
      var sharedKey = require_shared_key();
      var CORRECT_PROTOTYPE_GETTER = require_correct_prototype_getter();
      var IE_PROTO = sharedKey("IE_PROTO");
      var $Object = Object;
      var ObjectPrototype = $Object.prototype;
      module.exports = CORRECT_PROTOTYPE_GETTER
        ? $Object.getPrototypeOf
        : function (O) {
            var object = toObject2(O);
            if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
            var constructor = object.constructor;
            if (isCallable(constructor) && object instanceof constructor) {
              return constructor.prototype;
            }
            return object instanceof $Object ? ObjectPrototype : null;
          };
    },
  });
  // node_modules/core-js/internals/iterators-core.js
  var require_iterators_core = __commonJS({
    "node_modules/core-js/internals/iterators-core.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      var isCallable = require_is_callable();
      var isObject = require_is_object();
      var create = require_object_create();
      var getPrototypeOf = require_object_get_prototype_of();
      var defineBuiltIn = require_define_built_in();
      var wellKnownSymbol = require_well_known_symbol();
      var IS_PURE = require_is_pure();
      var ITERATOR = wellKnownSymbol("iterator");
      var BUGGY_SAFARI_ITERATORS = false;
      var IteratorPrototype;
      var PrototypeOfArrayIteratorPrototype;
      var arrayIterator;
      if ([].keys) {
        arrayIterator = [].keys();
        if (!("next" in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
        else {
          PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
          if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
        }
      }
      var NEW_ITERATOR_PROTOTYPE =
        !isObject(IteratorPrototype) ||
        fails(function () {
          var test = {};
          return IteratorPrototype[ITERATOR].call(test) !== test;
        });
      if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
      else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);
      if (!isCallable(IteratorPrototype[ITERATOR])) {
        defineBuiltIn(IteratorPrototype, ITERATOR, function () {
          return this;
        });
      }
      module.exports = {
        IteratorPrototype,
        BUGGY_SAFARI_ITERATORS,
      };
    },
  });
  // node_modules/core-js/internals/set-to-string-tag.js
  var require_set_to_string_tag = __commonJS({
    "node_modules/core-js/internals/set-to-string-tag.js"(exports, module) {
      var defineProperty = require_object_define_property().f;
      var hasOwn = require_has_own_property();
      var wellKnownSymbol = require_well_known_symbol();
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      module.exports = function (target, TAG, STATIC) {
        if (target && !STATIC) target = target.prototype;
        if (target && !hasOwn(target, TO_STRING_TAG)) {
          defineProperty(target, TO_STRING_TAG, {
            configurable: true,
            value: TAG,
          });
        }
      };
    },
  });
  // node_modules/core-js/internals/iterator-create-constructor.js
  var require_iterator_create_constructor = __commonJS({
    "node_modules/core-js/internals/iterator-create-constructor.js"(exports, module) {
      "use strict";
      var IteratorPrototype = require_iterators_core().IteratorPrototype;
      var create = require_object_create();
      var createPropertyDescriptor = require_create_property_descriptor();
      var setToStringTag = require_set_to_string_tag();
      var Iterators = require_iterators();
      var returnThis = /* @__PURE__ */ __name(function () {
        return this;
      }, "returnThis");
      module.exports = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
        var TO_STRING_TAG = NAME + " Iterator";
        IteratorConstructor.prototype = create(IteratorPrototype, {
          next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next),
        });
        setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
        Iterators[TO_STRING_TAG] = returnThis;
        return IteratorConstructor;
      };
    },
  });
  // node_modules/core-js/internals/a-possible-prototype.js
  var require_a_possible_prototype = __commonJS({
    "node_modules/core-js/internals/a-possible-prototype.js"(exports, module) {
      var isCallable = require_is_callable();
      var $String = String;
      var $TypeError = TypeError;
      module.exports = function (argument) {
        if (typeof argument == "object" || isCallable(argument)) return argument;
        throw $TypeError("Can't set " + $String(argument) + " as a prototype");
      };
    },
  });
  // node_modules/core-js/internals/object-set-prototype-of.js
  var require_object_set_prototype_of = __commonJS({
    "node_modules/core-js/internals/object-set-prototype-of.js"(exports, module) {
      var uncurryThis = require_function_uncurry_this();
      var anObject = require_an_object();
      var aPossiblePrototype = require_a_possible_prototype();
      module.exports =
        Object.setPrototypeOf ||
        ("__proto__" in {}
          ? (function () {
              var CORRECT_SETTER = false;
              var test = {};
              var setter;
              try {
                setter = uncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set);
                setter(test, []);
                CORRECT_SETTER = test instanceof Array;
              } catch (error) {}
              return /* @__PURE__ */ __name(function setPrototypeOf(O, proto) {
                anObject(O);
                aPossiblePrototype(proto);
                if (CORRECT_SETTER) setter(O, proto);
                else O.__proto__ = proto;
                return O;
              }, "setPrototypeOf");
            })()
          : void 0);
    },
  });
  // node_modules/core-js/internals/iterator-define.js
  var require_iterator_define = __commonJS({
    "node_modules/core-js/internals/iterator-define.js"(exports, module) {
      "use strict";
      var $4 = require_export();
      var call = require_function_call();
      var IS_PURE = require_is_pure();
      var FunctionName = require_function_name();
      var isCallable = require_is_callable();
      var createIteratorConstructor = require_iterator_create_constructor();
      var getPrototypeOf = require_object_get_prototype_of();
      var setPrototypeOf = require_object_set_prototype_of();
      var setToStringTag = require_set_to_string_tag();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var defineBuiltIn = require_define_built_in();
      var wellKnownSymbol = require_well_known_symbol();
      var Iterators = require_iterators();
      var IteratorsCore = require_iterators_core();
      var PROPER_FUNCTION_NAME = FunctionName.PROPER;
      var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
      var IteratorPrototype = IteratorsCore.IteratorPrototype;
      var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
      var ITERATOR = wellKnownSymbol("iterator");
      var KEYS = "keys";
      var VALUES = "values";
      var ENTRIES = "entries";
      var returnThis = /* @__PURE__ */ __name(function () {
        return this;
      }, "returnThis");
      module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
        createIteratorConstructor(IteratorConstructor, NAME, next);
        var getIterationMethod = /* @__PURE__ */ __name(function (KIND) {
          if (KIND === DEFAULT && defaultIterator) return defaultIterator;
          if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
          switch (KIND) {
            case KEYS:
              return /* @__PURE__ */ __name(function keys() {
                return new IteratorConstructor(this, KIND);
              }, "keys");
            case VALUES:
              return /* @__PURE__ */ __name(function values() {
                return new IteratorConstructor(this, KIND);
              }, "values");
            case ENTRIES:
              return /* @__PURE__ */ __name(function entries() {
                return new IteratorConstructor(this, KIND);
              }, "entries");
          }
          return function () {
            return new IteratorConstructor(this);
          };
        }, "getIterationMethod");
        var TO_STRING_TAG = NAME + " Iterator";
        var INCORRECT_VALUES_NAME = false;
        var IterablePrototype = Iterable.prototype;
        var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || (DEFAULT && IterablePrototype[DEFAULT]);
        var defaultIterator = (!BUGGY_SAFARI_ITERATORS && nativeIterator) || getIterationMethod(DEFAULT);
        var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
        var CurrentIteratorPrototype, methods, KEY;
        if (anyNativeIterator) {
          CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
          if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
            if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
              if (setPrototypeOf) {
                setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
              } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
                defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
              }
            }
            setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
            if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
          }
        }
        if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
          if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
            createNonEnumerableProperty(IterablePrototype, "name", VALUES);
          } else {
            INCORRECT_VALUES_NAME = true;
            defaultIterator = /* @__PURE__ */ __name(function values() {
              return call(nativeIterator, this);
            }, "values");
          }
        }
        if (DEFAULT) {
          methods = {
            values: getIterationMethod(VALUES),
            keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
            entries: getIterationMethod(ENTRIES),
          };
          if (FORCED)
            for (KEY in methods) {
              if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
              }
            }
          else
            $4(
              {
                target: NAME,
                proto: true,
                forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME,
              },
              methods
            );
        }
        if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
          defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, {
            name: DEFAULT,
          });
        }
        Iterators[NAME] = defaultIterator;
        return methods;
      };
    },
  });
  // node_modules/core-js/internals/create-iter-result-object.js
  var require_create_iter_result_object = __commonJS({
    "node_modules/core-js/internals/create-iter-result-object.js"(exports, module) {
      module.exports = function (value, done) {
        return {
          value,
          done,
        };
      };
    },
  });
  // node_modules/core-js/modules/es.array.iterator.js
  var require_es_array_iterator = __commonJS({
    "node_modules/core-js/modules/es.array.iterator.js"(exports, module) {
      "use strict";
      var toIndexedObject = require_to_indexed_object();
      var addToUnscopables = require_add_to_unscopables();
      var Iterators = require_iterators();
      var InternalStateModule = require_internal_state();
      var defineProperty = require_object_define_property().f;
      var defineIterator = require_iterator_define();
      var createIterResultObject = require_create_iter_result_object();
      var IS_PURE = require_is_pure();
      var DESCRIPTORS = require_descriptors();
      var ARRAY_ITERATOR = "Array Iterator";
      var setInternalState = InternalStateModule.set;
      var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
      module.exports = defineIterator(
        Array,
        "Array",
        function (iterated, kind) {
          setInternalState(this, {
            type: ARRAY_ITERATOR,
            target: toIndexedObject(iterated),
            index: 0,
            kind,
          });
        },
        function () {
          var state = getInternalState(this);
          var target = state.target;
          var kind = state.kind;
          var index = state.index++;
          if (!target || index >= target.length) {
            state.target = void 0;
            return createIterResultObject(void 0, true);
          }
          if (kind == "keys") return createIterResultObject(index, false);
          if (kind == "values") return createIterResultObject(target[index], false);
          return createIterResultObject([index, target[index]], false);
        },
        "values"
      );
      var values = (Iterators.Arguments = Iterators.Array);
      addToUnscopables("keys");
      addToUnscopables("values");
      addToUnscopables("entries");
      if (!IS_PURE && DESCRIPTORS && values.name !== "values")
        try {
          defineProperty(values, "name", {
            value: "values",
          });
        } catch (error) {}
    },
  });
  // node_modules/core-js/internals/url-constructor-detection.js
  var require_url_constructor_detection = __commonJS({
    "node_modules/core-js/internals/url-constructor-detection.js"(exports, module) {
      var fails = require_fails();
      var wellKnownSymbol = require_well_known_symbol();
      var IS_PURE = require_is_pure();
      var ITERATOR = wellKnownSymbol("iterator");
      module.exports = !fails(function () {
        var url = new URL("b?a=1&b=2&c=3", "http://a");
        var searchParams = url.searchParams;
        var result = "";
        url.pathname = "c%20d";
        searchParams.forEach(function (value, key) {
          searchParams["delete"]("b");
          result += key + value;
        });
        return (
          (IS_PURE && !url.toJSON) ||
          !searchParams.sort ||
          url.href !== "http://a/c%20d?a=1&c=3" ||
          searchParams.get("c") !== "3" ||
          String(new URLSearchParams("?a=1")) !== "a=1" ||
          !searchParams[ITERATOR] ||
          new URL("https://a@b").username !== "a" ||
          new URLSearchParams(new URLSearchParams("a=b")).get("a") !== "b" ||
          new URL("http://").host !== "xn--e1aybc" ||
          new URL("http://a#").hash !== "#%D0%B1" ||
          result !== "a1c3" ||
          new URL("http://x", void 0).host !== "x"
        );
      });
    },
  });
  // node_modules/core-js/internals/define-built-ins.js
  var require_define_built_ins = __commonJS({
    "node_modules/core-js/internals/define-built-ins.js"(exports, module) {
      var defineBuiltIn = require_define_built_in();
      module.exports = function (target, src, options) {
        for (var key in src) defineBuiltIn(target, key, src[key], options);
        return target;
      };
    },
  });
  // node_modules/core-js/internals/an-instance.js
  var require_an_instance = __commonJS({
    "node_modules/core-js/internals/an-instance.js"(exports, module) {
      var isPrototypeOf = require_object_is_prototype_of();
      var $TypeError = TypeError;
      module.exports = function (it, Prototype) {
        if (isPrototypeOf(Prototype, it)) return it;
        throw $TypeError("Incorrect invocation");
      };
    },
  });
  // node_modules/core-js/internals/validate-arguments-length.js
  var require_validate_arguments_length = __commonJS({
    "node_modules/core-js/internals/validate-arguments-length.js"(exports, module) {
      var $TypeError = TypeError;
      module.exports = function (passed, required) {
        if (passed < required) throw $TypeError("Not enough arguments");
        return passed;
      };
    },
  });
  // node_modules/core-js/internals/array-slice-simple.js
  var require_array_slice_simple = __commonJS({
    "node_modules/core-js/internals/array-slice-simple.js"(exports, module) {
      var toAbsoluteIndex = require_to_absolute_index();
      var lengthOfArrayLike2 = require_length_of_array_like();
      var createProperty2 = require_create_property();
      var $Array = Array;
      var max = Math.max;
      module.exports = function (O, start, end) {
        var length = lengthOfArrayLike2(O);
        var k = toAbsoluteIndex(start, length);
        var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
        var result = $Array(max(fin - k, 0));
        for (var n = 0; k < fin; k++, n++) createProperty2(result, n, O[k]);
        result.length = n;
        return result;
      };
    },
  });
  // node_modules/core-js/internals/array-sort.js
  var require_array_sort = __commonJS({
    "node_modules/core-js/internals/array-sort.js"(exports, module) {
      var arraySlice = require_array_slice_simple();
      var floor = Math.floor;
      var mergeSort = /* @__PURE__ */ __name(function (array, comparefn) {
        var length = array.length;
        var middle = floor(length / 2);
        return length < 8 ? insertionSort(array, comparefn) : merge(array, mergeSort(arraySlice(array, 0, middle), comparefn), mergeSort(arraySlice(array, middle), comparefn), comparefn);
      }, "mergeSort");
      var insertionSort = /* @__PURE__ */ __name(function (array, comparefn) {
        var length = array.length;
        var i = 1;
        var element2, j;
        while (i < length) {
          j = i;
          element2 = array[i];
          while (j && comparefn(array[j - 1], element2) > 0) {
            array[j] = array[--j];
          }
          if (j !== i++) array[j] = element2;
        }
        return array;
      }, "insertionSort");
      var merge = /* @__PURE__ */ __name(function (array, left, right, comparefn) {
        var llength = left.length;
        var rlength = right.length;
        var lindex = 0;
        var rindex = 0;
        while (lindex < llength || rindex < rlength) {
          array[lindex + rindex] = lindex < llength && rindex < rlength ? (comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]) : lindex < llength ? left[lindex++] : right[rindex++];
        }
        return array;
      }, "merge");
      module.exports = mergeSort;
    },
  });
  // node_modules/core-js/modules/web.url-search-params.constructor.js
  var require_web_url_search_params_constructor = __commonJS({
    "node_modules/core-js/modules/web.url-search-params.constructor.js"(exports, module) {
      "use strict";
      require_es_array_iterator();
      var $4 = require_export();
      var global2 = require_global();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var DESCRIPTORS = require_descriptors();
      var USE_NATIVE_URL = require_url_constructor_detection();
      var defineBuiltIn = require_define_built_in();
      var defineBuiltIns = require_define_built_ins();
      var setToStringTag = require_set_to_string_tag();
      var createIteratorConstructor = require_iterator_create_constructor();
      var InternalStateModule = require_internal_state();
      var anInstance = require_an_instance();
      var isCallable = require_is_callable();
      var hasOwn = require_has_own_property();
      var bind2 = require_function_bind_context();
      var classof = require_classof();
      var anObject = require_an_object();
      var isObject = require_is_object();
      var $toString = require_to_string();
      var create = require_object_create();
      var createPropertyDescriptor = require_create_property_descriptor();
      var getIterator = require_get_iterator();
      var getIteratorMethod = require_get_iterator_method();
      var validateArgumentsLength = require_validate_arguments_length();
      var wellKnownSymbol = require_well_known_symbol();
      var arraySort = require_array_sort();
      var ITERATOR = wellKnownSymbol("iterator");
      var URL_SEARCH_PARAMS = "URLSearchParams";
      var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + "Iterator";
      var setInternalState = InternalStateModule.set;
      var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);
      var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);
      var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var safeGetBuiltIn = /* @__PURE__ */ __name(function (name2) {
        if (!DESCRIPTORS) return global2[name2];
        var descriptor = getOwnPropertyDescriptor(global2, name2);
        return descriptor && descriptor.value;
      }, "safeGetBuiltIn");
      var nativeFetch = safeGetBuiltIn("fetch");
      var NativeRequest = safeGetBuiltIn("Request");
      var Headers = safeGetBuiltIn("Headers");
      var RequestPrototype = NativeRequest && NativeRequest.prototype;
      var HeadersPrototype = Headers && Headers.prototype;
      var RegExp2 = global2.RegExp;
      var TypeError2 = global2.TypeError;
      var decodeURIComponent = global2.decodeURIComponent;
      var encodeURIComponent2 = global2.encodeURIComponent;
      var charAt = uncurryThis("".charAt);
      var join = uncurryThis([].join);
      var push = uncurryThis([].push);
      var replace = uncurryThis("".replace);
      var shift2 = uncurryThis([].shift);
      var splice = uncurryThis([].splice);
      var split = uncurryThis("".split);
      var stringSlice = uncurryThis("".slice);
      var plus = /\+/g;
      var sequences = Array(4);
      var percentSequence = /* @__PURE__ */ __name(function (bytes) {
        return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp2("((?:%[\\da-f]{2}){" + bytes + "})", "gi"));
      }, "percentSequence");
      var percentDecode = /* @__PURE__ */ __name(function (sequence) {
        try {
          return decodeURIComponent(sequence);
        } catch (error) {
          return sequence;
        }
      }, "percentDecode");
      var deserialize = /* @__PURE__ */ __name(function (it) {
        var result = replace(it, plus, " ");
        var bytes = 4;
        try {
          return decodeURIComponent(result);
        } catch (error) {
          while (bytes) {
            result = replace(result, percentSequence(bytes--), percentDecode);
          }
          return result;
        }
      }, "deserialize");
      var find2 = /[!'()~]|%20/g;
      var replacements = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
      };
      var replacer = /* @__PURE__ */ __name(function (match) {
        return replacements[match];
      }, "replacer");
      var serialize = /* @__PURE__ */ __name(function (it) {
        return replace(encodeURIComponent2(it), find2, replacer);
      }, "serialize");
      var URLSearchParamsIterator = createIteratorConstructor(
        /* @__PURE__ */ __name(function Iterator(params, kind) {
          setInternalState(this, {
            type: URL_SEARCH_PARAMS_ITERATOR,
            iterator: getIterator(getInternalParamsState(params).entries),
            kind,
          });
        }, "Iterator"),
        "Iterator",
        /* @__PURE__ */ __name(function next() {
          var state = getInternalIteratorState(this);
          var kind = state.kind;
          var step = state.iterator.next();
          var entry = step.value;
          if (!step.done) {
            step.value = kind === "keys" ? entry.key : kind === "values" ? entry.value : [entry.key, entry.value];
          }
          return step;
        }, "next"),
        true
      );
      var URLSearchParamsState = /* @__PURE__ */ __name(function (init2) {
        this.entries = [];
        this.url = null;
        if (init2 !== void 0) {
          if (isObject(init2)) this.parseObject(init2);
          else this.parseQuery(typeof init2 == "string" ? (charAt(init2, 0) === "?" ? stringSlice(init2, 1) : init2) : $toString(init2));
        }
      }, "URLSearchParamsState");
      URLSearchParamsState.prototype = {
        type: URL_SEARCH_PARAMS,
        bindURL: function bindURL(url) {
          this.url = url;
          this.update();
        },
        parseObject: function parseObject(object) {
          var iteratorMethod = getIteratorMethod(object);
          var iterator, next, step, entryIterator, entryNext, first, second;
          if (iteratorMethod) {
            iterator = getIterator(object, iteratorMethod);
            next = iterator.next;
            while (!(step = call(next, iterator)).done) {
              entryIterator = getIterator(anObject(step.value));
              entryNext = entryIterator.next;
              if ((first = call(entryNext, entryIterator)).done || (second = call(entryNext, entryIterator)).done || !call(entryNext, entryIterator).done) throw TypeError2("Expected sequence with length 2");
              push(this.entries, {
                key: $toString(first.value),
                value: $toString(second.value),
              });
            }
          } else
            for (var key in object)
              if (hasOwn(object, key)) {
                push(this.entries, {
                  key,
                  value: $toString(object[key]),
                });
              }
        },
        parseQuery: function parseQuery(query) {
          if (query) {
            var attributes = split(query, "&");
            var index = 0;
            var attribute, entry;
            while (index < attributes.length) {
              attribute = attributes[index++];
              if (attribute.length) {
                entry = split(attribute, "=");
                push(this.entries, {
                  key: deserialize(shift2(entry)),
                  value: deserialize(join(entry, "=")),
                });
              }
            }
          }
        },
        serialize: function serialize1() {
          var entries = this.entries;
          var result = [];
          var index = 0;
          var entry;
          while (index < entries.length) {
            entry = entries[index++];
            push(result, serialize(entry.key) + "=" + serialize(entry.value));
          }
          return join(result, "&");
        },
        update: function update() {
          this.entries.length = 0;
          this.parseQuery(this.url.query);
        },
        updateURL: function updateURL() {
          if (this.url) this.url.update();
        },
      };
      var URLSearchParamsConstructor = /* @__PURE__ */ __name(function URLSearchParams2() {
        anInstance(this, URLSearchParamsPrototype);
        var init2 = arguments.length > 0 ? arguments[0] : void 0;
        setInternalState(this, new URLSearchParamsState(init2));
      }, "URLSearchParams");
      var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;
      defineBuiltIns(
        URLSearchParamsPrototype,
        {
          append: /* @__PURE__ */ __name(function append2(name2, value) {
            validateArgumentsLength(arguments.length, 2);
            var state = getInternalParamsState(this);
            push(state.entries, {
              key: $toString(name2),
              value: $toString(value),
            });
            state.updateURL();
          }, "append"),
          delete: function (name2) {
            validateArgumentsLength(arguments.length, 1);
            var state = getInternalParamsState(this);
            var entries = state.entries;
            var key = $toString(name2);
            var index = 0;
            while (index < entries.length) {
              if (entries[index].key === key) splice(entries, index, 1);
              else index++;
            }
            state.updateURL();
          },
          get: /* @__PURE__ */ __name(function get(name2) {
            validateArgumentsLength(arguments.length, 1);
            var entries = getInternalParamsState(this).entries;
            var key = $toString(name2);
            var index = 0;
            for (; index < entries.length; index++) {
              if (entries[index].key === key) return entries[index].value;
            }
            return null;
          }, "get"),
          getAll: /* @__PURE__ */ __name(function getAll(name2) {
            validateArgumentsLength(arguments.length, 1);
            var entries = getInternalParamsState(this).entries;
            var key = $toString(name2);
            var result = [];
            var index = 0;
            for (; index < entries.length; index++) {
              if (entries[index].key === key) push(result, entries[index].value);
            }
            return result;
          }, "getAll"),
          has: /* @__PURE__ */ __name(function has(name2) {
            validateArgumentsLength(arguments.length, 1);
            var entries = getInternalParamsState(this).entries;
            var key = $toString(name2);
            var index = 0;
            while (index < entries.length) {
              if (entries[index++].key === key) return true;
            }
            return false;
          }, "has"),
          set: /* @__PURE__ */ __name(function set(name2, value) {
            validateArgumentsLength(arguments.length, 1);
            var state = getInternalParamsState(this);
            var entries = state.entries;
            var found = false;
            var key = $toString(name2);
            var val = $toString(value);
            var index = 0;
            var entry;
            for (; index < entries.length; index++) {
              entry = entries[index];
              if (entry.key === key) {
                if (found) splice(entries, index--, 1);
                else {
                  found = true;
                  entry.value = val;
                }
              }
            }
            if (!found)
              push(entries, {
                key,
                value: val,
              });
            state.updateURL();
          }, "set"),
          sort: /* @__PURE__ */ __name(function sort() {
            var state = getInternalParamsState(this);
            arraySort(state.entries, function (a, b) {
              return a.key > b.key ? 1 : -1;
            });
            state.updateURL();
          }, "sort"),
          forEach: /* @__PURE__ */ __name(function forEach(callback) {
            var entries = getInternalParamsState(this).entries;
            var boundFunction = bind2(callback, arguments.length > 1 ? arguments[1] : void 0);
            var index = 0;
            var entry;
            while (index < entries.length) {
              entry = entries[index++];
              boundFunction(entry.value, entry.key, this);
            }
          }, "forEach"),
          keys: /* @__PURE__ */ __name(function keys() {
            return new URLSearchParamsIterator(this, "keys");
          }, "keys"),
          values: /* @__PURE__ */ __name(function values() {
            return new URLSearchParamsIterator(this, "values");
          }, "values"),
          entries: /* @__PURE__ */ __name(function entries() {
            return new URLSearchParamsIterator(this, "entries");
          }, "entries"),
        },
        {
          enumerable: true,
        }
      );
      defineBuiltIn(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries, {
        name: "entries",
      });
      defineBuiltIn(
        URLSearchParamsPrototype,
        "toString",
        /* @__PURE__ */ __name(function toString() {
          return getInternalParamsState(this).serialize();
        }, "toString"),
        {
          enumerable: true,
        }
      );
      setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);
      $4(
        {
          global: true,
          constructor: true,
          forced: !USE_NATIVE_URL,
        },
        {
          URLSearchParams: URLSearchParamsConstructor,
        }
      );
      if (!USE_NATIVE_URL && isCallable(Headers)) {
        headersHas = uncurryThis(HeadersPrototype.has);
        headersSet = uncurryThis(HeadersPrototype.set);
        wrapRequestOptions = /* @__PURE__ */ __name(function (init2) {
          if (isObject(init2)) {
            var body = init2.body;
            var headers;
            if (classof(body) === URL_SEARCH_PARAMS) {
              headers = init2.headers ? new Headers(init2.headers) : new Headers();
              if (!headersHas(headers, "content-type")) {
                headersSet(headers, "content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
              return create(init2, {
                body: createPropertyDescriptor(0, $toString(body)),
                headers: createPropertyDescriptor(0, headers),
              });
            }
          }
          return init2;
        }, "wrapRequestOptions");
        if (isCallable(nativeFetch)) {
          $4(
            {
              global: true,
              enumerable: true,
              dontCallGetSet: true,
              forced: true,
            },
            {
              fetch: /* @__PURE__ */ __name(function fetch(input) {
                return nativeFetch(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
              }, "fetch"),
            }
          );
        }
        if (isCallable(NativeRequest)) {
          RequestConstructor = /* @__PURE__ */ __name(function Request(input) {
            anInstance(this, RequestPrototype);
            return new NativeRequest(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
          }, "Request");
          RequestPrototype.constructor = RequestConstructor;
          RequestConstructor.prototype = RequestPrototype;
          $4(
            {
              global: true,
              constructor: true,
              dontCallGetSet: true,
              forced: true,
            },
            {
              Request: RequestConstructor,
            }
          );
        }
      }
      var headersHas;
      var headersSet;
      var wrapRequestOptions;
      var RequestConstructor;
      module.exports = {
        URLSearchParams: URLSearchParamsConstructor,
        getState: getInternalParamsState,
      };
    },
  });
  // node_modules/core-js/modules/es.array.flat-map.js
  var $ = require_export();
  var flattenIntoArray = require_flatten_into_array();
  var aCallable = require_a_callable();
  var toObject = require_to_object();
  var lengthOfArrayLike = require_length_of_array_like();
  var arraySpeciesCreate = require_array_species_create();
  $(
    {
      target: "Array",
      proto: true,
    },
    {
      flatMap: /* @__PURE__ */ __name(function flatMap(callbackfn) {
        var O = toObject(this);
        var sourceLen = lengthOfArrayLike(O);
        var A;
        aCallable(callbackfn);
        A = arraySpeciesCreate(O, 0);
        A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        return A;
      }, "flatMap"),
    }
  );
  // node_modules/core-js/modules/es.object.from-entries.js
  var $2 = require_export();
  var iterate = require_iterate();
  var createProperty = require_create_property();
  $2(
    {
      target: "Object",
      stat: true,
    },
    {
      fromEntries: /* @__PURE__ */ __name(function fromEntries(iterable) {
        var obj = {};
        iterate(
          iterable,
          function (k, v) {
            createProperty(obj, k, v);
          },
          {
            AS_ENTRIES: true,
          }
        );
        return obj;
      }, "fromEntries"),
    }
  );
  // node_modules/core-js/modules/es.string.trim-end.js
  require_es_string_trim_right();
  var $3 = require_export();
  var trimEnd = require_string_trim_end();
  $3(
    {
      target: "String",
      proto: true,
      name: "trimEnd",
      forced: "".trimEnd !== trimEnd,
    },
    {
      trimEnd,
    }
  );
  // node_modules/core-js/modules/web.url-search-params.js
  require_web_url_search_params_constructor();
  // node_modules/svelte/internal/index.mjs
  function noop() {}
  __name(noop, "noop");
  function assign(tar, src) {
    for (var k in src) tar[k] = src[k];
    return tar;
  }
  __name(assign, "assign");
  function run(fn) {
    return fn();
  }
  __name(run, "run");
  function blank_object() {
    return /* @__PURE__ */ Object.create(null);
  }
  __name(blank_object, "blank_object");
  function run_all(fns) {
    fns.forEach(run);
  }
  __name(run_all, "run_all");
  function is_function(thing) {
    return typeof thing === "function";
  }
  __name(is_function, "is_function");
  function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || (a && typeof a === "object") || typeof a === "function";
  }
  __name(safe_not_equal, "safe_not_equal");
  function is_empty(obj) {
    return Object.keys(obj).length === 0;
  }
  __name(is_empty, "is_empty");
  function create_slot(definition, ctx, $$scope, fn) {
    if (definition) {
      var slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
      return definition[0](slot_ctx);
    }
  }
  __name(create_slot, "create_slot");
  function get_slot_context(definition, ctx, $$scope, fn) {
    return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
  }
  __name(get_slot_context, "get_slot_context");
  function get_slot_changes(definition, $$scope, dirty, fn) {
    if (definition[2] && fn) {
      var lets = definition[2](fn(dirty));
      if ($$scope.dirty === void 0) {
        return lets;
      }
      if (typeof lets === "object") {
        var merged = [];
        var len = Math.max($$scope.dirty.length, lets.length);
        for (var i = 0; i < len; i += 1) {
          merged[i] = $$scope.dirty[i] | lets[i];
        }
        return merged;
      }
      return $$scope.dirty | lets;
    }
    return $$scope.dirty;
  }
  __name(get_slot_changes, "get_slot_changes");
  function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
    if (slot_changes) {
      var slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
      slot.p(slot_context, slot_changes);
    }
  }
  __name(update_slot_base, "update_slot_base");
  function get_all_dirty_from_scope($$scope) {
    if ($$scope.ctx.length > 32) {
      var dirty = [];
      var length = $$scope.ctx.length / 32;
      for (var i = 0; i < length; i++) {
        dirty[i] = -1;
      }
      return dirty;
    }
    return -1;
  }
  __name(get_all_dirty_from_scope, "get_all_dirty_from_scope");
  function compute_slots(slots) {
    var result = {};
    for (var key in slots) {
      result[key] = true;
    }
    return result;
  }
  __name(compute_slots, "compute_slots");
  var is_hydrating = false;
  function start_hydrating() {
    is_hydrating = true;
  }
  __name(start_hydrating, "start_hydrating");
  function end_hydrating() {
    is_hydrating = false;
  }
  __name(end_hydrating, "end_hydrating");
  function append(target, node) {
    target.appendChild(node);
  }
  __name(append, "append");
  function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
  }
  __name(insert, "insert");
  function detach(node) {
    if (node.parentNode) {
      node.parentNode.removeChild(node);
    }
  }
  __name(detach, "detach");
  function destroy_each(iterations, detaching) {
    for (var i = 0; i < iterations.length; i += 1) {
      if (iterations[i]) iterations[i].d(detaching);
    }
  }
  __name(destroy_each, "destroy_each");
  function element(name2) {
    return document.createElement(name2);
  }
  __name(element, "element");
  function svg_element(name2) {
    return document.createElementNS("http://www.w3.org/2000/svg", name2);
  }
  __name(svg_element, "svg_element");
  function text(data) {
    return document.createTextNode(data);
  }
  __name(text, "text");
  function space() {
    return text(" ");
  }
  __name(space, "space");
  function empty() {
    return text("");
  }
  __name(empty, "empty");
  function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
  }
  __name(listen, "listen");
  function attr(node, attribute, value) {
    if (value == null) node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
  }
  __name(attr, "attr");
  function to_number(value) {
    return value === "" ? null : +value;
  }
  __name(to_number, "to_number");
  function children(element2) {
    return Array.from(element2.childNodes);
  }
  __name(children, "children");
  function set_data(text2, data) {
    data = "" + data;
    if (text2.wholeText !== data) text2.data = data;
  }
  __name(set_data, "set_data");
  function set_input_value(input, value) {
    input.value = value == null ? "" : value;
  }
  __name(set_input_value, "set_input_value");
  function toggle_class(element2, name2, toggle) {
    element2.classList[toggle ? "add" : "remove"](name2);
  }
  __name(toggle_class, "toggle_class");
  function custom_event(type, detail) {
    var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
      _ref_bubbles = _ref.bubbles,
      bubbles = _ref_bubbles === void 0 ? false : _ref_bubbles,
      _ref_cancelable = _ref.cancelable,
      cancelable = _ref_cancelable === void 0 ? false : _ref_cancelable;
    var e = document.createEvent("CustomEvent");
    e.initCustomEvent(type, bubbles, cancelable, detail);
    return e;
  }
  __name(custom_event, "custom_event");
  var current_component;
  function set_current_component(component) {
    current_component = component;
  }
  __name(set_current_component, "set_current_component");
  function get_current_component() {
    if (!current_component) throw new Error("Function called outside component initialization");
    return current_component;
  }
  __name(get_current_component, "get_current_component");
  function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
  }
  __name(onMount, "onMount");
  function createEventDispatcher() {
    var component = get_current_component();
    return function (type, detail) {
      var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
        _ref_cancelable = _ref.cancelable,
        cancelable = _ref_cancelable === void 0 ? false : _ref_cancelable;
      var callbacks = component.$$.callbacks[type];
      if (callbacks) {
        var event = custom_event(type, detail, {
          cancelable,
        });
        callbacks.slice().forEach((fn) => {
          fn.call(component, event);
        });
        return !event.defaultPrevented;
      }
      return true;
    };
  }
  __name(createEventDispatcher, "createEventDispatcher");
  var dirty_components = [];
  var binding_callbacks = [];
  var render_callbacks = [];
  var flush_callbacks = [];
  var resolved_promise = Promise.resolve();
  var update_scheduled = false;
  function schedule_update() {
    if (!update_scheduled) {
      update_scheduled = true;
      resolved_promise.then(flush);
    }
  }
  __name(schedule_update, "schedule_update");
  function add_render_callback(fn) {
    render_callbacks.push(fn);
  }
  __name(add_render_callback, "add_render_callback");
  function add_flush_callback(fn) {
    flush_callbacks.push(fn);
  }
  __name(add_flush_callback, "add_flush_callback");
  var seen_callbacks = /* @__PURE__ */ new Set();
  var flushidx = 0;
  function flush() {
    var saved_component = current_component;
    do {
      while (flushidx < dirty_components.length) {
        var component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
      set_current_component(null);
      dirty_components.length = 0;
      flushidx = 0;
      while (binding_callbacks.length) binding_callbacks.pop()();
      for (var i = 0; i < render_callbacks.length; i += 1) {
        var callback = render_callbacks[i];
        if (!seen_callbacks.has(callback)) {
          seen_callbacks.add(callback);
          callback();
        }
      }
      render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
      flush_callbacks.pop()();
    }
    update_scheduled = false;
    seen_callbacks.clear();
    set_current_component(saved_component);
  }
  __name(flush, "flush");
  function update($$) {
    if ($$.fragment !== null) {
      $$.update();
      run_all($$.before_update);
      var dirty = $$.dirty;
      $$.dirty = [-1];
      $$.fragment && $$.fragment.p($$.ctx, dirty);
      $$.after_update.forEach(add_render_callback);
    }
  }
  __name(update, "update");
  var outroing = /* @__PURE__ */ new Set();
  var outros;
  function group_outros() {
    outros = {
      r: 0,
      c: [],
      p: outros,
    };
  }
  __name(group_outros, "group_outros");
  function check_outros() {
    if (!outros.r) {
      run_all(outros.c);
    }
    outros = outros.p;
  }
  __name(check_outros, "check_outros");
  function transition_in(block, local) {
    if (block && block.i) {
      outroing.delete(block);
      block.i(local);
    }
  }
  __name(transition_in, "transition_in");
  function transition_out(block, local, detach2, callback) {
    if (block && block.o) {
      if (outroing.has(block)) return;
      outroing.add(block);
      outros.c.push(() => {
        outroing.delete(block);
        if (callback) {
          if (detach2) block.d(1);
          callback();
        }
      });
      block.o(local);
    } else if (callback) {
      callback();
    }
  }
  __name(transition_out, "transition_out");
  var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
  function bind(component, name2, callback) {
    var index = component.$$.props[name2];
    if (index !== void 0) {
      component.$$.bound[index] = callback;
      callback(component.$$.ctx[index]);
    }
  }
  __name(bind, "bind");
  function create_component(block) {
    block && block.c();
  }
  __name(create_component, "create_component");
  function mount_component(component, target, anchor, customElement) {
    var _component_$$ = component.$$,
      fragment = _component_$$.fragment,
      after_update = _component_$$.after_update;
    fragment && fragment.m(target, anchor);
    if (!customElement) {
      add_render_callback(() => {
        var new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
        if (component.$$.on_destroy) {
          component.$$.on_destroy.push(...new_on_destroy);
        } else {
          run_all(new_on_destroy);
        }
        component.$$.on_mount = [];
      });
    }
    after_update.forEach(add_render_callback);
  }
  __name(mount_component, "mount_component");
  function destroy_component(component, detaching) {
    var $$ = component.$$;
    if ($$.fragment !== null) {
      run_all($$.on_destroy);
      $$.fragment && $$.fragment.d(detaching);
      $$.on_destroy = $$.fragment = null;
      $$.ctx = [];
    }
  }
  __name(destroy_component, "destroy_component");
  function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
      dirty_components.push(component);
      schedule_update();
      component.$$.dirty.fill(0);
    }
    component.$$.dirty[(i / 31) | 0] |= 1 << i % 31;
  }
  __name(make_dirty, "make_dirty");
  function init(component, options, instance21, create_fragment21, not_equal, props, append_styles) {
    var dirty = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : [-1];
    var parent_component = current_component;
    set_current_component(component);
    var $$ = (component.$$ = {
      fragment: null,
      ctx: [],
      props,
      update: noop,
      not_equal,
      bound: blank_object(),
      on_mount: [],
      on_destroy: [],
      on_disconnect: [],
      before_update: [],
      after_update: [],
      context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
      callbacks: blank_object(),
      dirty,
      skip_bound: false,
      root: options.target || parent_component.$$.root,
    });
    append_styles && append_styles($$.root);
    var ready = false;
    $$.ctx = instance21
      ? instance21(component, options.props || {}, function (i, ret) {
          for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            rest[_key - 2] = arguments[_key];
          }
          var value = rest.length ? rest[0] : ret;
          if ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {
            if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
            if (ready) make_dirty(component, i);
          }
          return ret;
        })
      : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    $$.fragment = create_fragment21 ? create_fragment21($$.ctx) : false;
    if (options.target) {
      if (options.hydrate) {
        start_hydrating();
        var nodes = children(options.target);
        $$.fragment && $$.fragment.l(nodes);
        nodes.forEach(detach);
      } else {
        $$.fragment && $$.fragment.c();
      }
      if (options.intro) transition_in(component.$$.fragment);
      mount_component(component, options.target, options.anchor, options.customElement);
      end_hydrating();
      flush();
    }
    set_current_component(parent_component);
  }
  __name(init, "init");
  var SvelteElement;
  if (typeof HTMLElement === "function") {
    SvelteElement = /* @__PURE__ */ __name(
      class extends HTMLElement {
        connectedCallback() {
          var on_mount = this.$$.on_mount;
          this.$$.on_disconnect = on_mount.map(run).filter(is_function);
          for (var key in this.$$.slotted) {
            this.appendChild(this.$$.slotted[key]);
          }
        }
        attributeChangedCallback(attr2, _oldValue, newValue) {
          this[attr2] = newValue;
        }
        disconnectedCallback() {
          run_all(this.$$.on_disconnect);
        }
        $destroy() {
          destroy_component(this, 1);
          this.$destroy = noop;
        }
        $on(type, callback) {
          if (!is_function(callback)) {
            return noop;
          }
          var callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
          callbacks.push(callback);
          return () => {
            var index = callbacks.indexOf(callback);
            if (index !== -1) callbacks.splice(index, 1);
          };
        }
        $set($$props) {
          if (this.$$set && !is_empty($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
          }
        }
        constructor() {
          super();
          this.attachShadow({
            mode: "open",
          });
        }
      },
      "SvelteElement"
    );
  }
  var SvelteComponent = class SvelteComponent {
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      if (!is_function(callback)) {
        return noop;
      }
      var callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        var index = callbacks.indexOf(callback);
        if (index !== -1) callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
  __name(SvelteComponent, "SvelteComponent");
  // src/bibtex-parser.ts
  var RootNode = class RootNode {
    constructor(ref) {
      var children2 = ref === void 0 ? [] : ref;
      this.children = children2;
      this.type = "root";
    }
  };
  __name(RootNode, "RootNode");
  var TextNode = class TextNode {
    constructor(parent, text2) {
      this.parent = parent;
      this.text = text2;
      this.type = "text";
      parent.children.push(this);
    }
  };
  __name(TextNode, "TextNode");
  var BlockNode = class BlockNode {
    constructor(parent) {
      this.parent = parent;
      this.type = "block";
      this.command = "";
      parent.children.push(this);
    }
  };
  __name(BlockNode, "BlockNode");
  var CommentNode = class CommentNode {
    constructor(parent, raw, braces, parens) {
      this.parent = parent;
      this.raw = raw;
      this.braces = braces;
      this.parens = parens;
      this.type = "comment";
      parent.block = this;
    }
  };
  __name(CommentNode, "CommentNode");
  var PreambleNode = class PreambleNode {
    constructor(parent, raw, braces, parens) {
      this.parent = parent;
      this.raw = raw;
      this.braces = braces;
      this.parens = parens;
      this.type = "preamble";
      parent.block = this;
    }
  };
  __name(PreambleNode, "PreambleNode");
  var StringNode = class StringNode {
    constructor(parent, raw, braces, parens) {
      this.parent = parent;
      this.raw = raw;
      this.braces = braces;
      this.parens = parens;
      this.type = "string";
      parent.block = this;
    }
  };
  __name(StringNode, "StringNode");
  var EntryNode = class EntryNode {
    constructor(parent, wrapType) {
      this.parent = parent;
      this.wrapType = wrapType;
      this.type = "entry";
      parent.block = this;
      this.fields = [];
    }
  };
  __name(EntryNode, "EntryNode");
  var FieldNode = class FieldNode {
    constructor(parent, ref) {
      var name2 = ref === void 0 ? "" : ref;
      this.parent = parent;
      this.name = name2;
      this.type = "field";
      this.value = new ConcatNode(this);
    }
  };
  __name(FieldNode, "FieldNode");
  var ConcatNode = class ConcatNode {
    constructor(parent) {
      this.parent = parent;
      this.type = "concat";
      this.canConsumeValue = true;
      this.concat = [];
    }
  };
  __name(ConcatNode, "ConcatNode");
  var LiteralNode = class LiteralNode {
    constructor(parent, value) {
      this.parent = parent;
      this.value = value;
      this.type = "literal";
      parent.concat.push(this);
    }
  };
  __name(LiteralNode, "LiteralNode");
  var BracedNode = class BracedNode {
    constructor(parent) {
      this.parent = parent;
      this.type = "braced";
      this.value = "";
      this.depth = 0;
      parent.concat.push(this);
    }
  };
  __name(BracedNode, "BracedNode");
  var QuotedNode = class QuotedNode {
    constructor(parent) {
      this.parent = parent;
      this.type = "quoted";
      this.value = "";
      this.depth = 0;
      parent.concat.push(this);
    }
  };
  __name(QuotedNode, "QuotedNode");
  function generateAST(input) {
    var _a2;
    var rootNode = new RootNode();
    var node = rootNode;
    var line = 1;
    var column = 0;
    for (var i = 0; i < input.length; i++) {
      var char = input[i];
      var prev = input[i - 1];
      if (char === "\n") {
        line++;
        column = 0;
      }
      column++;
      switch (node.type) {
        case "root": {
          node = char === "@" ? new BlockNode(node) : new TextNode(node, char);
          break;
        }
        case "text": {
          if (char === "@" && /[\s\r\n}]/.test(prev)) {
            node = new BlockNode(node.parent);
          } else {
            node.text += char;
          }
          break;
        }
        case "block": {
          if (char === "@") {
            var prevNode = node.parent.children[node.parent.children.length - 2];
            if ((prevNode == null ? void 0 : prevNode.type) === "text") {
              prevNode.text += "@" + node.command;
            } else {
              node.parent.children.pop();
              new TextNode(node.parent, "@" + node.command);
              node.parent.children.push(node);
            }
            node.command = "";
          } else if (char === "{" || char === "(") {
            var commandTrimmed = node.command.trim();
            if (commandTrimmed === "" || /\s/.test(commandTrimmed)) {
              node.parent.children.pop();
              node = new TextNode(node.parent, "@" + node.command + char);
            } else {
              node.command = commandTrimmed;
              var command = node.command.toLowerCase();
              var _ref = _slicedToArray(char === "{" ? [1, 0] : [0, 1], 2),
                braces = _ref[0],
                parens = _ref[1];
              var raw = "@" + command + char;
              switch (command) {
                case "string":
                  node = new StringNode(node, raw, braces, parens);
                  break;
                case "preamble":
                  node = new PreambleNode(node, raw, braces, parens);
                  break;
                case "comment":
                  node = new CommentNode(node, raw, braces, parens);
                  break;
                default:
                  node = new EntryNode(node, char);
                  break;
              }
            }
          } else if (char.match(/[=#,})[\]]/)) {
            node.parent.children.pop();
            node = new TextNode(node.parent, "@" + node.command + char);
          } else {
            node.command += char;
          }
          break;
        }
        case "comment":
        case "string":
        case "preamble":
          if (char === "{") {
            node.braces++;
          } else if (char === "}") {
            node.braces--;
          } else if (char === "(") {
            node.parens++;
          } else if (char === ")") {
            node.parens--;
          }
          node.raw += char;
          if (node.braces === 0 && node.parens === 0) {
            node = node.parent.parent;
          }
          break;
        case "entry": {
          if (isWhitespace(char)) {
            if (!node.key) {
            } else {
              node.keyEnded = true;
            }
          } else if (char === ",") {
            node = new FieldNode(node);
          } else if ((node.wrapType === "{" && char === "}") || (node.wrapType === "(" && char === ")")) {
            node = node.parent.parent;
          } else if (char === "=" && node.key && isValidFieldName(node.key)) {
            var field = new FieldNode(node, node.key);
            node.fields.push(field);
            node.key = void 0;
            node = field.value;
          } else if (node.keyEnded) {
            throw new BibTeXSyntaxError(input, node, i, line, column, "The entry key cannot contain whitespace");
          } else if (!isValidKeyCharacter(char)) {
            throw new BibTeXSyntaxError(input, node, i, line, column, "The entry key cannot contain the character (".concat(char, ")"));
          } else {
            node.key = ((_a2 = node.key) != null ? _a2 : "") + char;
          }
          break;
        }
        case "field": {
          if (char === "}" || char === ")") {
            node.name = node.name.trim();
            node = node.parent.parent.parent;
          } else if (char === "=") {
            node.name = node.name.trim();
            node = node.value;
          } else if (char === ",") {
            node.name = node.name.trim();
            node = new FieldNode(node.parent);
          } else if (!isValidFieldName(char)) {
            throw new BibTeXSyntaxError(input, node, i, line, column);
          } else if (!node.name) {
            if (!isWhitespace(char)) {
              node.parent.fields.push(node);
              node.name = char;
            } else {
            }
          } else {
            node.name += char;
          }
          break;
        }
        case "concat": {
          if (isWhitespace(char)) {
            break;
          } else if (node.canConsumeValue) {
            if (/[#=,}()[\]]/.test(char)) {
              throw new BibTeXSyntaxError(input, node, i, line, column);
            } else {
              node.canConsumeValue = false;
              if (char === "{") {
                node = new BracedNode(node);
              } else if (char === '"') {
                node = new QuotedNode(node);
              } else {
                node = new LiteralNode(node, char);
              }
            }
          } else {
            if (char === ",") {
              node = new FieldNode(node.parent.parent);
            } else if (char === "}" || char === ")") {
              node = node.parent.parent.parent.parent;
            } else if (char === "#") {
              node.canConsumeValue = true;
            } else {
              throw new BibTeXSyntaxError(input, node, i, line, column);
            }
          }
          break;
        }
        case "literal":
          if (isWhitespace(char)) {
            node = node.parent;
          } else if (char === ",") {
            node = new FieldNode(node.parent.parent.parent);
          } else if (char === "}") {
            node = node.parent.parent.parent.parent.parent;
          } else if (char === "#") {
            node = node.parent;
            node.canConsumeValue = true;
          } else {
            node.value += char;
          }
          break;
        case "braced":
          if (char === "}" && node.depth === 0) {
            node = node.parent;
            break;
          } else if (char === "{") {
            node.depth++;
          } else if (char === "}") {
            node.depth--;
          }
          node.value += char;
          break;
        case "quoted":
          if (char === '"' && node.depth === 0) {
            node = node.parent;
            break;
          } else if (char === "{") {
            node.depth++;
          } else if (char === "}") {
            node.depth--;
            if (node.depth < 0) {
              throw new BibTeXSyntaxError(input, node, i, line, column);
            }
          }
          node.value += char;
          break;
      }
    }
    return rootNode;
  }
  __name(generateAST, "generateAST");
  function isWhitespace(string2) {
    return /^[ \t\n\r]*$/.test(string2);
  }
  __name(isWhitespace, "isWhitespace");
  function isValidKeyCharacter(char) {
    return !/[#%{}~$,]/.test(char);
  }
  __name(isValidKeyCharacter, "isValidKeyCharacter");
  function isValidFieldName(char) {
    return !/[=,{}()[\]]/.test(char);
  }
  __name(isValidFieldName, "isValidFieldName");
  var BibTeXSyntaxError = class BibTeXSyntaxError extends Error {
    constructor(input, node, pos, line, column, hint) {
      super("Line ".concat(line, ":").concat(column, ": Syntax Error in ").concat(node.type, " (").concat(hint, ")\n") + input.slice(Math.max(0, pos - 20), pos) + ">>" + input[pos] + "<<" + input.slice(pos + 1, pos + 20));
      this.node = node;
      this.line = line;
      this.column = column;
      this.hint = hint;
      this.name = "Syntax Error";
      this.char = input[pos];
    }
  };
  __name(BibTeXSyntaxError, "BibTeXSyntaxError");
  // src/latexParser.ts
  var BlockNode2 = class BlockNode21 {
    constructor(kind, parent, ref) {
      var children2 = ref === void 0 ? [] : ref;
      this.kind = kind;
      this.parent = parent;
      this.children = children2;
      this.type = "block";
      if (parent instanceof BlockNode2) {
        parent.children.push(this);
      } else if (parent instanceof CommandNode) {
        parent.args.push(this);
      }
    }
  };
  __name(BlockNode2, "BlockNode");
  var TextNode2 = class TextNode2 {
    constructor(parent, ref) {
      var text2 = ref === void 0 ? "" : ref;
      this.parent = parent;
      this.text = text2;
      this.type = "text";
      parent.children.push(this);
    }
  };
  __name(TextNode2, "TextNode");
  var CommandNode = class CommandNode {
    constructor(parent, ref, ref1) {
      var command = ref === void 0 ? "" : ref,
        args = ref1 === void 0 ? [] : ref1;
      this.parent = parent;
      this.command = command;
      this.args = args;
      this.type = "command";
      parent.children.push(this);
    }
  };
  __name(CommandNode, "CommandNode");
  function parseLaTeX(input) {
    var rootNode = new BlockNode2("root");
    var node = rootNode;
    for (var i = 0; i < input.length; i++) {
      var char = input[i];
      switch (node.type) {
        case "block": {
          if (char === "\\") {
            node = new CommandNode(node);
          } else if (char === "{") {
            node = new BlockNode2("curly", node);
          } else if (((char === "}" && node.kind === "curly") || (char === "]" && node.kind === "square")) && node.parent) {
            node = node.parent;
          } else {
            node = new TextNode2(node, char);
          }
          break;
        }
        case "text": {
          if (char === "\\" || char === "{") {
            node = node.parent;
            i--;
          } else if ((char === "}" && node.parent.kind === "curly") || (char === "]" && node.parent.kind === "square")) {
            node = node.parent;
            i--;
          } else {
            if (char === "}") {
              console.log(node.parent);
            }
            node.text += char;
          }
          break;
        }
        case "command": {
          if (char === "{") {
            node = new BlockNode2("curly", node);
          } else if (char === "[") {
            node = new BlockNode2("square", node);
          } else if (node.args.length === 0) {
            node.command += char;
          } else {
            node = node.parent;
            i--;
          }
        }
      }
    }
    return rootNode;
  }
  __name(parseLaTeX, "parseLaTeX");
  function stringifyLaTeX(ast) {
    return stringifyBlock(ast);
  }
  __name(stringifyLaTeX, "stringifyLaTeX");
  function stringifyBlock(block) {
    var content2 = block.children
      .map((node) => {
        switch (node.type) {
          case "block":
            return stringifyBlock(node);
          case "command":
            return stringifyCommand(node);
          case "text":
            return node.text;
        }
      })
      .join("");
    switch (block.kind) {
      case "root":
        return content2;
      case "curly":
        return "{" + content2 + "}";
      case "square":
        return "[" + content2 + "]";
    }
  }
  __name(stringifyBlock, "stringifyBlock");
  function stringifyCommand(node) {
    return "\\" + node.command + node.args.map(stringifyBlock).join("");
  }
  __name(stringifyCommand, "stringifyCommand");
  function flattenLaTeX(block) {
    var newBlock = __spreadProps(__spreadValues({}, block), {
      children: [],
    });
    var _iteratorNormalCompletion = true,
      _didIteratorError = false,
      _iteratorError = undefined;
    try {
      for (var _iterator = block.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var child = _step.value;
        if (child.type === "block" && child.kind === "curly") {
          var newChild = flattenLaTeX(child);
          newBlock.children.push(...newChild.children);
        } else {
          newBlock.children.push(child);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    return newBlock;
  }
  __name(flattenLaTeX, "flattenLaTeX");
  // src/unicode.ts
  var specialCharacters = /* @__PURE__ */ new Map([
    ["0023", "\\#"],
    ["0024", "\\$"],
    ["0025", "\\%"],
    ["0026", "\\&"],
    ["0027", "'"],
    ["0040", "\\@"],
    ["002a", "\\textasteriskcentered"],
    ["005f", "\\_"],
    ["007c", "\\vert{}"],
    ["00a0", "~"],
    ["00a1", "\\textexclamdown{}"],
    ["00a2", "\\textcent{}"],
    ["00a3", "\\textsterling{}"],
    ["00a4", "\\textcurrency{}"],
    ["00a5", "\\textyen{}"],
    ["00a6", "\\textbrokenbar{}"],
    ["00a7", "\\textsection{}"],
    ["00a8", "\\textasciidieresis{}"],
    ["00a9", "\\textcopyright{}"],
    ["00aa", "\\textordfeminine{}"],
    ["00ab", "\\guillemotleft{}"],
    ["00ac", "\\lnot{}"],
    ["00ad", "\\-"],
    ["00ae", "\\textregistered{}"],
    ["00af", "\\textasciimacron{}"],
    ["00b0", "\\textdegree{}"],
    ["00b1", "\\pm{}"],
    ["00b2", "\\ensuremath{^2}"],
    ["00b3", "\\ensuremath{^3}"],
    ["00b4", "\\textasciiacute{}"],
    ["00b5", "\\mathrm{\\mu}"],
    ["00b6", "\\textparagraph{}"],
    ["00b7", "\\cdot{}"],
    ["00b8", "\\c{}"],
    ["00b9", "\\ensuremath{^1}"],
    ["00ba", "\\textordmasculine{}"],
    ["00bb", "\\guillemotright{}"],
    ["00bc", "\\textonequarter{}"],
    ["00bd", "\\textonehalf{}"],
    ["00be", "\\textthreequarters{}"],
    ["00bf", "\\textquestiondown{}"],
    ["00c0", "\\`{A}"],
    ["00c1", "\\'{A}"],
    ["00c2", "\\^{A}"],
    ["00c3", "\\~{A}"],
    ["00c4", '\\"{A}'],
    ["00c5", "\\AA{}"],
    ["00c6", "\\AE{}"],
    ["00c7", "\\c{C}"],
    ["00c8", "\\`{E}"],
    ["00c9", "\\'{E}"],
    ["00ca", "\\^{E}"],
    ["00cb", '\\"{E}'],
    ["00cc", "\\`{I}"],
    ["00cd", "\\'{I}"],
    ["00ce", "\\^{I}"],
    ["00cf", '\\"{I}'],
    ["00d0", "\\DH{}"],
    ["00d1", "\\~{N}"],
    ["00d2", "\\`{O}"],
    ["00d3", "\\'{O}"],
    ["00d4", "\\^{O}"],
    ["00d5", "\\~{O}"],
    ["00d6", '\\"{O}'],
    ["00d7", "\\texttimes{}"],
    ["00d8", "\\O{}"],
    ["00d9", "\\`{U}"],
    ["00da", "\\'{U}"],
    ["00db", "\\^{U}"],
    ["00dc", '\\"{U}'],
    ["00dd", "\\'{Y}"],
    ["00de", "\\TH{}"],
    ["00df", "\\ss{}"],
    ["00e0", "\\`{a}"],
    ["00e1", "\\'{a}"],
    ["00e2", "\\^{a}"],
    ["00e3", "\\~{a}"],
    ["00e4", '\\"{a}'],
    ["00e5", "\\aa{}"],
    ["00e6", "\\ae{}"],
    ["00e7", "\\c{c}"],
    ["00e8", "\\`{e}"],
    ["00e9", "\\'{e}"],
    ["00ea", "\\^{e}"],
    ["00eb", '\\"{e}'],
    ["00ec", "\\`{\\i}"],
    ["00ed", "\\'{\\i}"],
    ["00ee", "\\^{\\i}"],
    ["00ef", '\\"{\\i}'],
    ["00f0", "\\dh{}"],
    ["00f1", "\\~{n}"],
    ["00f2", "\\`{o}"],
    ["00f3", "\\'{o}"],
    ["00f4", "\\^{o}"],
    ["00f5", "\\~{o}"],
    ["00f6", '\\"{o}'],
    ["00f7", "\\div{}"],
    ["00f8", "\\o{}"],
    ["00f9", "\\`{u}"],
    ["00fa", "\\'{u}"],
    ["00fb", "\\^{u}"],
    ["00fc", '\\"{u}'],
    ["00fd", "\\'{y}"],
    ["00fe", "\\th{}"],
    ["00ff", '\\"{y}'],
    ["0100", "\\={A}"],
    ["0101", "\\={a}"],
    ["0102", "\\u{A}"],
    ["0103", "\\u{a}"],
    ["0104", "\\k{A}"],
    ["0105", "\\k{a}"],
    ["0106", "\\'{C}"],
    ["0107", "\\'{c}"],
    ["0108", "\\^{C}"],
    ["0109", "\\^{c}"],
    ["010a", "\\.{C}"],
    ["010b", "\\.{c}"],
    ["010c", "\\v{C}"],
    ["010d", "\\v{c}"],
    ["010e", "\\v{D}"],
    ["010f", "\\v{d}"],
    ["0110", "\\DJ{}"],
    ["0111", "\\dj{}"],
    ["0112", "\\={E}"],
    ["0113", "\\={e}"],
    ["0114", "\\u{E}"],
    ["0115", "\\u{e}"],
    ["0116", "\\.{E}"],
    ["0117", "\\.{e}"],
    ["0118", "\\k{E}"],
    ["0119", "\\k{e}"],
    ["011a", "\\v{E}"],
    ["011b", "\\v{e}"],
    ["011c", "\\^{G}"],
    ["011d", "\\^{g}"],
    ["011e", "\\u{G}"],
    ["011f", "\\u{g}"],
    ["0120", "\\.{G}"],
    ["0121", "\\.{g}"],
    ["0122", "\\c{G}"],
    ["0123", "\\c{g}"],
    ["0124", "\\^{H}"],
    ["0125", "\\^{h}"],
    ["0126", "{\\fontencoding{LELA}\\selectfont\\char40}"],
    ["0127", "\\Elzxh{}"],
    ["0128", "\\~{I}"],
    ["0129", "\\~{\\i}"],
    ["012a", "\\={I}"],
    ["012b", "\\={\\i}"],
    ["012c", "\\u{I}"],
    ["012d", "\\u{\\i}"],
    ["012e", "\\k{I}"],
    ["012f", "\\k{i}"],
    ["0130", "\\.{I}"],
    ["0131", "\\i{}"],
    ["0132", "IJ"],
    ["0133", "ij"],
    ["0134", "\\^{J}"],
    ["0135", "\\^{\\j}"],
    ["0136", "\\c{K}"],
    ["0137", "\\c{k}"],
    ["0138", "{\\fontencoding{LELA}\\selectfont\\char91}"],
    ["0139", "\\'{L}"],
    ["013a", "\\'{l}"],
    ["013b", "\\c{L}"],
    ["013c", "\\c{l}"],
    ["013d", "\\v{L}"],
    ["013e", "\\v{l}"],
    ["013f", "{\\fontencoding{LELA}\\selectfont\\char201}"],
    ["0140", "{\\fontencoding{LELA}\\selectfont\\char202}"],
    ["0141", "\\L{}"],
    ["0142", "\\l{}"],
    ["0143", "\\'{N}"],
    ["0144", "\\'{n}"],
    ["0145", "\\c{N}"],
    ["0146", "\\c{n}"],
    ["0147", "\\v{N}"],
    ["0148", "\\v{n}"],
    ["0149", "'n"],
    ["014a", "\\NG{}"],
    ["014b", "\\ng{}"],
    ["014c", "\\={O}"],
    ["014d", "\\={o}"],
    ["014e", "\\u{O}"],
    ["014f", "\\u{o}"],
    ["0150", "\\H{O}"],
    ["0151", "\\H{o}"],
    ["0152", "\\OE{}"],
    ["0153", "\\oe{}"],
    ["0154", "\\'{R}"],
    ["0155", "\\'{r}"],
    ["0156", "\\c{R}"],
    ["0157", "\\c{r}"],
    ["0158", "\\v{R}"],
    ["0159", "\\v{r}"],
    ["015a", "\\'{S}"],
    ["015b", "\\'{s}"],
    ["015c", "\\^{S}"],
    ["015d", "\\^{s}"],
    ["015e", "\\c{S}"],
    ["015f", "\\c{s}"],
    ["0160", "\\v{S}"],
    ["0161", "\\v{s}"],
    ["0162", "\\c{T}"],
    ["0163", "\\c{t}"],
    ["0164", "\\v{T}"],
    ["0165", "\\v{t}"],
    ["0166", "{\\fontencoding{LELA}\\selectfont\\char47}"],
    ["0167", "{\\fontencoding{LELA}\\selectfont\\char63}"],
    ["0168", "\\~{U}"],
    ["0169", "\\~{u}"],
    ["016a", "\\={U}"],
    ["016b", "\\={u}"],
    ["016c", "\\u{U}"],
    ["016d", "\\u{u}"],
    ["016e", "\\r{U}"],
    ["016f", "\\r{u}"],
    ["0170", "\\H{U}"],
    ["0171", "\\H{u}"],
    ["0172", "\\k{U}"],
    ["0173", "\\k{u}"],
    ["0174", "\\^{W}"],
    ["0175", "\\^{w}"],
    ["0176", "\\^{Y}"],
    ["0177", "\\^{y}"],
    ["0178", '\\"{Y}'],
    ["0179", "\\'{Z}"],
    ["017a", "\\'{z}"],
    ["017b", "\\.{Z}"],
    ["017c", "\\.{z}"],
    ["017d", "\\v{Z}"],
    ["017e", "\\v{z}"],
    ["0195", "\\texthvlig{}"],
    ["019e", "\\textnrleg{}"],
    ["01aa", "\\eth{}"],
    ["01ba", "{\\fontencoding{LELA}\\selectfont\\char195}"],
    ["01c2", "\\textdoublepipe{}"],
    ["01f5", "\\'{g}"],
    ["0250", "\\Elztrna{}"],
    ["0252", "\\Elztrnsa{}"],
    ["0254", "\\Elzopeno{}"],
    ["0256", "\\Elzrtld{}"],
    ["0258", "{\\fontencoding{LEIP}\\selectfont\\char61}"],
    ["0259", "\\Elzschwa{}"],
    ["025b", "\\varepsilon{}"],
    ["0263", "\\Elzpgamma{}"],
    ["0264", "\\Elzpbgam{}"],
    ["0265", "\\Elztrnh{}"],
    ["026c", "\\Elzbtdl{}"],
    ["026d", "\\Elzrtll{}"],
    ["026f", "\\Elztrnm{}"],
    ["0270", "\\Elztrnmlr{}"],
    ["0271", "\\Elzltlmr{}"],
    ["0272", "\\Elzltln{}"],
    ["0273", "\\Elzrtln{}"],
    ["0277", "\\Elzclomeg{}"],
    ["0278", "\\textphi{}"],
    ["0279", "\\Elztrnr{}"],
    ["027a", "\\Elztrnrl{}"],
    ["027b", "\\Elzrttrnr{}"],
    ["027c", "\\Elzrl{}"],
    ["027d", "\\Elzrtlr{}"],
    ["027e", "\\Elzfhr{}"],
    ["027f", "{\\fontencoding{LEIP}\\selectfont\\char202}"],
    ["0282", "\\Elzrtls{}"],
    ["0283", "\\Elzesh{}"],
    ["0287", "\\Elztrnt{}"],
    ["0288", "\\Elzrtlt{}"],
    ["028a", "\\Elzpupsil{}"],
    ["028b", "\\Elzpscrv{}"],
    ["028c", "\\Elzinvv{}"],
    ["028d", "\\Elzinvw{}"],
    ["028e", "\\Elztrny{}"],
    ["0290", "\\Elzrtlz{}"],
    ["0292", "\\Elzyogh{}"],
    ["0294", "\\Elzglst{}"],
    ["0295", "\\Elzreglst{}"],
    ["0296", "\\Elzinglst{}"],
    ["029e", "\\textturnk{}"],
    ["02a4", "\\Elzdyogh{}"],
    ["02a7", "\\Elztesh{}"],
    ["02c7", "\\textasciicaron{}"],
    ["02c8", "\\Elzverts{}"],
    ["02cc", "\\Elzverti{}"],
    ["02d0", "\\Elzlmrk{}"],
    ["02d1", "\\Elzhlmrk{}"],
    ["02d2", "\\Elzsbrhr{}"],
    ["02d3", "\\Elzsblhr{}"],
    ["02d4", "\\Elzrais{}"],
    ["02d5", "\\Elzlow{}"],
    ["02d8", "\\textasciibreve{}"],
    ["02d9", "\\textperiodcentered{}"],
    ["02da", "\\r{}"],
    ["02db", "\\k{}"],
    ["02dc", "\\texttildelow{}"],
    ["02dd", "\\H{}"],
    ["02e5", "\\tone{55}"],
    ["02e6", "\\tone{44}"],
    ["02e7", "\\tone{33}"],
    ["02e8", "\\tone{22}"],
    ["02e9", "\\tone{11}"],
    ["0300", "\\`"],
    ["0301", "\\'"],
    ["0302", "\\^"],
    ["0303", "\\~"],
    ["0304", "\\="],
    ["0306", "\\u"],
    ["0307", "\\."],
    ["0308", '\\"'],
    ["030a", "\\r"],
    ["030b", "\\H"],
    ["030c", "\\v"],
    ["030f", "\\cyrchar\\C"],
    ["0311", "{\\fontencoding{LECO}\\selectfont\\char177}"],
    ["0318", "{\\fontencoding{LECO}\\selectfont\\char184}"],
    ["0319", "{\\fontencoding{LECO}\\selectfont\\char185}"],
    ["0321", "\\Elzpalh{}"],
    ["0322", "\\Elzrh{}"],
    ["0327", "\\c"],
    ["0328", "\\k"],
    ["032a", "\\Elzsbbrg{}"],
    ["032b", "{\\fontencoding{LECO}\\selectfont\\char203}"],
    ["032f", "{\\fontencoding{LECO}\\selectfont\\char207}"],
    ["0335", "\\Elzxl{}"],
    ["0336", "\\Elzbar{}"],
    ["0337", "{\\fontencoding{LECO}\\selectfont\\char215}"],
    ["0338", "{\\fontencoding{LECO}\\selectfont\\char216}"],
    ["033a", "{\\fontencoding{LECO}\\selectfont\\char218}"],
    ["033b", "{\\fontencoding{LECO}\\selectfont\\char219}"],
    ["033c", "{\\fontencoding{LECO}\\selectfont\\char220}"],
    ["033d", "{\\fontencoding{LECO}\\selectfont\\char221}"],
    ["0361", "{\\fontencoding{LECO}\\selectfont\\char225}"],
    ["0386", "\\'{A}"],
    ["0388", "\\'{E}"],
    ["0389", "\\'{H}"],
    ["038a", "\\'{}{I}"],
    ["038c", "\\'{}O"],
    ["038e", "\\mathrm{'Y}"],
    ["038f", "\\mathrm{'\\Omega}"],
    ["0390", "\\acute{\\ddot{\\iota}}"],
    ["0391", "\\ensuremath{\\Alpha}"],
    ["0392", "\\ensuremath{\\Beta}"],
    ["0393", "\\ensuremath{\\Gamma}"],
    ["0394", "\\ensuremath{\\Delta}"],
    ["0395", "\\ensuremath{\\Epsilon}"],
    ["0396", "\\ensuremath{\\Zeta}"],
    ["0397", "\\ensuremath{\\Eta}"],
    ["0398", "\\ensuremath{\\Theta}"],
    ["0399", "\\ensuremath{\\Iota}"],
    ["039a", "\\ensuremath{\\Kappa}"],
    ["039b", "\\ensuremath{\\Lambda}"],
    ["039e", "\\ensuremath{\\Xi}"],
    ["03a0", "\\ensuremath{\\Pi}"],
    ["03a1", "\\ensuremath{\\Rho}"],
    ["03a3", "\\ensuremath{\\Sigma}"],
    ["03a4", "\\ensuremath{\\Tau}"],
    ["03a5", "\\ensuremath{\\Upsilon}"],
    ["03a6", "\\ensuremath{\\Phi}"],
    ["03a7", "\\ensuremath{\\Chi}"],
    ["03a8", "\\ensuremath{\\Psi}"],
    ["03a9", "\\ensuremath{\\Omega}"],
    ["03aa", "\\mathrm{\\ddot{I}}"],
    ["03ab", "\\mathrm{\\ddot{Y}}"],
    ["03ac", "\\'{$\\alpha$}"],
    ["03ad", "\\acute{\\epsilon}"],
    ["03ae", "\\acute{\\eta}"],
    ["03af", "\\acute{\\iota}"],
    ["03b0", "\\acute{\\ddot{\\upsilon}}"],
    ["03b1", "\\ensuremath{\\alpha}"],
    ["03b2", "\\ensuremath{\\beta}"],
    ["03b3", "\\ensuremath{\\gamma}"],
    ["03b4", "\\ensuremath{\\delta}"],
    ["03b5", "\\ensuremath{\\epsilon}"],
    ["03b6", "\\ensuremath{\\zeta}"],
    ["03b7", "\\ensuremath{\\eta}"],
    ["03b8", "\\texttheta{}"],
    ["03b9", "\\ensuremath{\\iota}"],
    ["03ba", "\\ensuremath{\\kappa}"],
    ["03bb", "\\ensuremath{\\lambda}"],
    ["03bc", "\\ensuremath{\\mu}"],
    ["03bd", "\\ensuremath{\\nu}"],
    ["03be", "\\ensuremath{\\xi}"],
    ["03c0", "\\ensuremath{\\pi}"],
    ["03c1", "\\ensuremath{\\rho}"],
    ["03c2", "\\ensuremath{\\varsigma}"],
    ["03c3", "\\ensuremath{\\sigma}"],
    ["03c4", "\\ensuremath{\\tau}"],
    ["03c5", "\\ensuremath{\\upsilon}"],
    ["03c6", "\\ensuremath{\\varphi}"],
    ["03c7", "\\ensuremath{\\chi}"],
    ["03c8", "\\ensuremath{\\psi}"],
    ["03c9", "\\ensuremath{\\omega}"],
    ["03ca", "\\ensuremath{\\ddot{\\iota}}"],
    ["03cb", "\\ensuremath{\\ddot{\\upsilon}}"],
    ["03cc", "\\'{o}"],
    ["03cd", "\\acute{\\upsilon}"],
    ["03ce", "\\acute{\\omega}"],
    ["03d0", "\\Pisymbol{ppi022}{87}"],
    ["03d1", "\\textvartheta{}"],
    ["03d2", "\\ensuremath{\\Upsilon}"],
    ["03d5", "\\ensuremath{\\phi}"],
    ["03d6", "\\ensuremath{\\varpi}"],
    ["03da", "\\Stigma{}"],
    ["03dc", "\\Digamma{}"],
    ["03dd", "\\digamma{}"],
    ["03de", "\\Koppa{}"],
    ["03e0", "\\Sampi{}"],
    ["03f0", "\\varkappa{}"],
    ["03f1", "\\varrho{}"],
    ["03f4", "\\textTheta{}"],
    ["03f6", "\\backepsilon{}"],
    ["0401", "\\cyrchar\\CYRYO{}"],
    ["0402", "\\cyrchar\\CYRDJE{}"],
    ["0403", "\\cyrchar{\\'\\CYRG}"],
    ["0404", "\\cyrchar\\CYRIE{}"],
    ["0405", "\\cyrchar\\CYRDZE{}"],
    ["0406", "\\cyrchar\\CYRII{}"],
    ["0407", "\\cyrchar\\CYRYI{}"],
    ["0408", "\\cyrchar\\CYRJE{}"],
    ["0409", "\\cyrchar\\CYRLJE{}"],
    ["040a", "\\cyrchar\\CYRNJE{}"],
    ["040b", "\\cyrchar\\CYRTSHE{}"],
    ["040c", "\\cyrchar{\\'\\CYRK}"],
    ["040e", "\\cyrchar\\CYRUSHRT{}"],
    ["040f", "\\cyrchar\\CYRDZHE{}"],
    ["0410", "\\cyrchar\\CYRA{}"],
    ["0411", "\\cyrchar\\CYRB{}"],
    ["0412", "\\cyrchar\\CYRV{}"],
    ["0413", "\\cyrchar\\CYRG{}"],
    ["0414", "\\cyrchar\\CYRD{}"],
    ["0415", "\\cyrchar\\CYRE{}"],
    ["0416", "\\cyrchar\\CYRZH{}"],
    ["0417", "\\cyrchar\\CYRZ{}"],
    ["0418", "\\cyrchar\\CYRI{}"],
    ["0419", "\\cyrchar\\CYRISHRT{}"],
    ["041a", "\\cyrchar\\CYRK{}"],
    ["041b", "\\cyrchar\\CYRL{}"],
    ["041c", "\\cyrchar\\CYRM{}"],
    ["041d", "\\cyrchar\\CYRN{}"],
    ["041e", "\\cyrchar\\CYRO{}"],
    ["041f", "\\cyrchar\\CYRP{}"],
    ["0420", "\\cyrchar\\CYRR{}"],
    ["0421", "\\cyrchar\\CYRS{}"],
    ["0422", "\\cyrchar\\CYRT{}"],
    ["0423", "\\cyrchar\\CYRU{}"],
    ["0424", "\\cyrchar\\CYRF{}"],
    ["0425", "\\cyrchar\\CYRH{}"],
    ["0426", "\\cyrchar\\CYRC{}"],
    ["0427", "\\cyrchar\\CYRCH{}"],
    ["0428", "\\cyrchar\\CYRSH{}"],
    ["0429", "\\cyrchar\\CYRSHCH{}"],
    ["042a", "\\cyrchar\\CYRHRDSN{}"],
    ["042b", "\\cyrchar\\CYRERY{}"],
    ["042c", "\\cyrchar\\CYRSFTSN{}"],
    ["042d", "\\cyrchar\\CYREREV{}"],
    ["042e", "\\cyrchar\\CYRYU{}"],
    ["042f", "\\cyrchar\\CYRYA{}"],
    ["0430", "\\cyrchar\\cyra{}"],
    ["0431", "\\cyrchar\\cyrb{}"],
    ["0432", "\\cyrchar\\cyrv{}"],
    ["0433", "\\cyrchar\\cyrg{}"],
    ["0434", "\\cyrchar\\cyrd{}"],
    ["0435", "\\cyrchar\\cyre{}"],
    ["0436", "\\cyrchar\\cyrzh{}"],
    ["0437", "\\cyrchar\\cyrz{}"],
    ["0438", "\\cyrchar\\cyri{}"],
    ["0439", "\\cyrchar\\cyrishrt{}"],
    ["043a", "\\cyrchar\\cyrk{}"],
    ["043b", "\\cyrchar\\cyrl{}"],
    ["043c", "\\cyrchar\\cyrm{}"],
    ["043d", "\\cyrchar\\cyrn{}"],
    ["043e", "\\cyrchar\\cyro{}"],
    ["043f", "\\cyrchar\\cyrp{}"],
    ["0440", "\\cyrchar\\cyrr{}"],
    ["0441", "\\cyrchar\\cyrs{}"],
    ["0442", "\\cyrchar\\cyrt{}"],
    ["0443", "\\cyrchar\\cyru{}"],
    ["0444", "\\cyrchar\\cyrf{}"],
    ["0445", "\\cyrchar\\cyrh{}"],
    ["0446", "\\cyrchar\\cyrc{}"],
    ["0447", "\\cyrchar\\cyrch{}"],
    ["0448", "\\cyrchar\\cyrsh{}"],
    ["0449", "\\cyrchar\\cyrshch{}"],
    ["044a", "\\cyrchar\\cyrhrdsn{}"],
    ["044b", "\\cyrchar\\cyrery{}"],
    ["044c", "\\cyrchar\\cyrsftsn{}"],
    ["044d", "\\cyrchar\\cyrerev{}"],
    ["044e", "\\cyrchar\\cyryu{}"],
    ["044f", "\\cyrchar\\cyrya{}"],
    ["0451", "\\cyrchar\\cyryo{}"],
    ["0452", "\\cyrchar\\cyrdje{}"],
    ["0453", "\\cyrchar{\\'\\cyrg}"],
    ["0454", "\\cyrchar\\cyrie{}"],
    ["0455", "\\cyrchar\\cyrdze{}"],
    ["0456", "\\cyrchar\\cyrii{}"],
    ["0457", "\\cyrchar\\cyryi{}"],
    ["0458", "\\cyrchar\\cyrje{}"],
    ["0459", "\\cyrchar\\cyrlje{}"],
    ["045a", "\\cyrchar\\cyrnje{}"],
    ["045b", "\\cyrchar\\cyrtshe{}"],
    ["045c", "\\cyrchar{\\'\\cyrk}"],
    ["045e", "\\cyrchar\\cyrushrt{}"],
    ["045f", "\\cyrchar\\cyrdzhe{}"],
    ["0460", "\\cyrchar\\CYROMEGA{}"],
    ["0461", "\\cyrchar\\cyromega{}"],
    ["0462", "\\cyrchar\\CYRYAT{}"],
    ["0464", "\\cyrchar\\CYRIOTE{}"],
    ["0465", "\\cyrchar\\cyriote{}"],
    ["0466", "\\cyrchar\\CYRLYUS{}"],
    ["0467", "\\cyrchar\\cyrlyus{}"],
    ["0468", "\\cyrchar\\CYRIOTLYUS{}"],
    ["0469", "\\cyrchar\\cyriotlyus{}"],
    ["046a", "\\cyrchar\\CYRBYUS{}"],
    ["046c", "\\cyrchar\\CYRIOTBYUS{}"],
    ["046d", "\\cyrchar\\cyriotbyus{}"],
    ["046e", "\\cyrchar\\CYRKSI{}"],
    ["046f", "\\cyrchar\\cyrksi{}"],
    ["0470", "\\cyrchar\\CYRPSI{}"],
    ["0471", "\\cyrchar\\cyrpsi{}"],
    ["0472", "\\cyrchar\\CYRFITA{}"],
    ["0474", "\\cyrchar\\CYRIZH{}"],
    ["0478", "\\cyrchar\\CYRUK{}"],
    ["0479", "\\cyrchar\\cyruk{}"],
    ["047a", "\\cyrchar\\CYROMEGARND{}"],
    ["047b", "\\cyrchar\\cyromegarnd{}"],
    ["047c", "\\cyrchar\\CYROMEGATITLO{}"],
    ["047d", "\\cyrchar\\cyromegatitlo{}"],
    ["047e", "\\cyrchar\\CYROT{}"],
    ["047f", "\\cyrchar\\cyrot{}"],
    ["0480", "\\cyrchar\\CYRKOPPA{}"],
    ["0481", "\\cyrchar\\cyrkoppa{}"],
    ["0482", "\\cyrchar\\cyrthousands{}"],
    ["0488", "\\cyrchar\\cyrhundredthousands{}"],
    ["0489", "\\cyrchar\\cyrmillions{}"],
    ["048c", "\\cyrchar\\CYRSEMISFTSN{}"],
    ["048d", "\\cyrchar\\cyrsemisftsn{}"],
    ["048e", "\\cyrchar\\CYRRTICK{}"],
    ["048f", "\\cyrchar\\cyrrtick{}"],
    ["0490", "\\cyrchar\\CYRGUP{}"],
    ["0491", "\\cyrchar\\cyrgup{}"],
    ["0492", "\\cyrchar\\CYRGHCRS{}"],
    ["0493", "\\cyrchar\\cyrghcrs{}"],
    ["0494", "\\cyrchar\\CYRGHK{}"],
    ["0495", "\\cyrchar\\cyrghk{}"],
    ["0496", "\\cyrchar\\CYRZHDSC{}"],
    ["0497", "\\cyrchar\\cyrzhdsc{}"],
    ["0498", "\\cyrchar\\CYRZDSC{}"],
    ["0499", "\\cyrchar\\cyrzdsc{}"],
    ["049a", "\\cyrchar\\CYRKDSC{}"],
    ["049b", "\\cyrchar\\cyrkdsc{}"],
    ["049c", "\\cyrchar\\CYRKVCRS{}"],
    ["049d", "\\cyrchar\\cyrkvcrs{}"],
    ["049e", "\\cyrchar\\CYRKHCRS{}"],
    ["049f", "\\cyrchar\\cyrkhcrs{}"],
    ["04a0", "\\cyrchar\\CYRKBEAK{}"],
    ["04a1", "\\cyrchar\\cyrkbeak{}"],
    ["04a2", "\\cyrchar\\CYRNDSC{}"],
    ["04a3", "\\cyrchar\\cyrndsc{}"],
    ["04a4", "\\cyrchar\\CYRNG{}"],
    ["04a5", "\\cyrchar\\cyrng{}"],
    ["04a6", "\\cyrchar\\CYRPHK{}"],
    ["04a7", "\\cyrchar\\cyrphk{}"],
    ["04a8", "\\cyrchar\\CYRABHHA{}"],
    ["04a9", "\\cyrchar\\cyrabhha{}"],
    ["04aa", "\\cyrchar\\CYRSDSC{}"],
    ["04ab", "\\cyrchar\\cyrsdsc{}"],
    ["04ac", "\\cyrchar\\CYRTDSC{}"],
    ["04ad", "\\cyrchar\\cyrtdsc{}"],
    ["04ae", "\\cyrchar\\CYRY{}"],
    ["04af", "\\cyrchar\\cyry{}"],
    ["04b0", "\\cyrchar\\CYRYHCRS{}"],
    ["04b1", "\\cyrchar\\cyryhcrs{}"],
    ["04b2", "\\cyrchar\\CYRHDSC{}"],
    ["04b3", "\\cyrchar\\cyrhdsc{}"],
    ["04b4", "\\cyrchar\\CYRTETSE{}"],
    ["04b5", "\\cyrchar\\cyrtetse{}"],
    ["04b6", "\\cyrchar\\CYRCHRDSC{}"],
    ["04b7", "\\cyrchar\\cyrchrdsc{}"],
    ["04b8", "\\cyrchar\\CYRCHVCRS{}"],
    ["04b9", "\\cyrchar\\cyrchvcrs{}"],
    ["04ba", "\\cyrchar\\CYRSHHA{}"],
    ["04bb", "\\cyrchar\\cyrshha{}"],
    ["04bc", "\\cyrchar\\CYRABHCH{}"],
    ["04bd", "\\cyrchar\\cyrabhch{}"],
    ["04be", "\\cyrchar\\CYRABHCHDSC{}"],
    ["04bf", "\\cyrchar\\cyrabhchdsc{}"],
    ["04c0", "\\cyrchar\\CYRpalochka{}"],
    ["04c3", "\\cyrchar\\CYRKHK{}"],
    ["04c4", "\\cyrchar\\cyrkhk{}"],
    ["04c7", "\\cyrchar\\CYRNHK{}"],
    ["04c8", "\\cyrchar\\cyrnhk{}"],
    ["04cb", "\\cyrchar\\CYRCHLDSC{}"],
    ["04cc", "\\cyrchar\\cyrchldsc{}"],
    ["04d4", "\\cyrchar\\CYRAE{}"],
    ["04d5", "\\cyrchar\\cyrae{}"],
    ["04d8", "\\cyrchar\\CYRSCHWA{}"],
    ["04d9", "\\cyrchar\\cyrschwa{}"],
    ["04e0", "\\cyrchar\\CYRABHDZE{}"],
    ["04e1", "\\cyrchar\\cyrabhdze{}"],
    ["04e8", "\\cyrchar\\CYROTLD{}"],
    ["04e9", "\\cyrchar\\cyrotld{}"],
    ["2002", "\\hspace{0.6em}"],
    ["2003", "\\hspace{1em}"],
    ["2004", "\\hspace{0.33em}"],
    ["2005", "\\hspace{0.25em}"],
    ["2006", "\\hspace{0.166em}"],
    ["2007", "\\hphantom{0}"],
    ["2008", "\\hphantom{,}"],
    ["2009", "\\hspace{0.167em}"],
    ["200a", "\\mkern1mu{}"],
    ["2010", "-"],
    ["2014", "--"],
    ["2015", "\\rule{1em}{1pt}"],
    ["2016", "\\Vert{}"],
    ["2018", "`"],
    ["2019", "'"],
    ["201b", "\\Elzreapos{}"],
    ["201c", "``"],
    ["201d", "''"],
    ["201e", ",,"],
    ["2020", "\\textdagger{}"],
    ["2021", "\\textdaggerdbl{}"],
    ["2022", "\\textbullet{}"],
    ["2025", ".."],
    ["2026", "\\ldots{}"],
    ["2030", "\\textperthousand{}"],
    ["2031", "\\textpertenthousand{}"],
    ["2032", "\\ensuremath{'}"],
    ["2033", "\\ensuremath{''}"],
    ["2034", "\\ensuremath{'''}"],
    ["2035", "\\backprime{}"],
    ["2039", "\\guilsinglleft{}"],
    ["203a", "\\guilsinglright{}"],
    ["2057", "''''"],
    ["205f", "\\mkern4mu{}"],
    ["2060", "\\nolinebreak{}"],
    ["20a7", "\\ensuremath{\\Elzpes}"],
    ["20ac", "\\mbox{\\texteuro}{}"],
    ["20db", "\\dddot{}"],
    ["20dc", "\\ddddot{}"],
    ["2102", "\\mathbb{C}"],
    ["210a", "\\mathscr{g}"],
    ["210b", "\\mathscr{H}"],
    ["210c", "\\mathfrak{H}"],
    ["210d", "\\mathbb{H}"],
    ["210f", "\\hslash{}"],
    ["2110", "\\mathscr{I}"],
    ["2111", "\\mathfrak{I}"],
    ["2112", "\\mathscr{L}"],
    ["2113", "\\mathscr{l}"],
    ["2115", "\\mathbb{N}"],
    ["2116", "\\cyrchar\\textnumero{}"],
    ["2118", "\\wp{}"],
    ["2119", "\\mathbb{P}"],
    ["211a", "\\mathbb{Q}"],
    ["211b", "\\mathscr{R}"],
    ["211c", "\\mathfrak{R}"],
    ["211d", "\\mathbb{R}"],
    ["211e", "\\Elzxrat{}"],
    ["2122", "\\texttrademark{}"],
    ["2124", "\\mathbb{Z}"],
    ["2126", "\\Omega{}"],
    ["2127", "\\mho{}"],
    ["2128", "\\mathfrak{Z}"],
    ["2129", "\\ElsevierGlyph{2129}"],
    ["212b", "\\AA{}"],
    ["212c", "\\mathscr{B}"],
    ["212d", "\\mathfrak{C}"],
    ["212f", "\\mathscr{e}"],
    ["2130", "\\mathscr{E}"],
    ["2131", "\\mathscr{F}"],
    ["2133", "\\mathscr{M}"],
    ["2134", "\\mathscr{o}"],
    ["2135", "\\aleph{}"],
    ["2136", "\\beth{}"],
    ["2137", "\\gimel{}"],
    ["2138", "\\daleth{}"],
    ["2153", "\\textfrac{1}{3}"],
    ["2154", "\\textfrac{2}{3}"],
    ["2155", "\\textfrac{1}{5}"],
    ["2156", "\\textfrac{2}{5}"],
    ["2157", "\\textfrac{3}{5}"],
    ["2158", "\\textfrac{4}{5}"],
    ["2159", "\\textfrac{1}{6}"],
    ["215a", "\\textfrac{5}{6}"],
    ["215b", "\\textfrac{1}{8}"],
    ["215c", "\\textfrac{3}{8}"],
    ["215d", "\\textfrac{5}{8}"],
    ["215e", "\\textfrac{7}{8}"],
    ["2190", "\\leftarrow{}"],
    ["2191", "\\uparrow{}"],
    ["2192", "\\rightarrow{}"],
    ["2193", "\\downarrow{}"],
    ["2194", "\\leftrightarrow{}"],
    ["2195", "\\updownarrow{}"],
    ["2196", "\\nwarrow{}"],
    ["2197", "\\nearrow{}"],
    ["2198", "\\searrow{}"],
    ["2199", "\\swarrow{}"],
    ["219a", "\\nleftarrow{}"],
    ["219b", "\\nrightarrow{}"],
    ["219c", "\\arrowwaveright{}"],
    ["219d", "\\arrowwaveright{}"],
    ["219e", "\\twoheadleftarrow{}"],
    ["21a0", "\\twoheadrightarrow{}"],
    ["21a2", "\\leftarrowtail{}"],
    ["21a3", "\\rightarrowtail{}"],
    ["21a6", "\\mapsto{}"],
    ["21a9", "\\hookleftarrow{}"],
    ["21aa", "\\hookrightarrow{}"],
    ["21ab", "\\looparrowleft{}"],
    ["21ac", "\\looparrowright{}"],
    ["21ad", "\\leftrightsquigarrow{}"],
    ["21ae", "\\nleftrightarrow{}"],
    ["21b0", "\\Lsh{}"],
    ["21b1", "\\Rsh{}"],
    ["21b3", "\\ElsevierGlyph{21B3}"],
    ["21b6", "\\curvearrowleft{}"],
    ["21b7", "\\curvearrowright{}"],
    ["21ba", "\\circlearrowleft{}"],
    ["21bb", "\\circlearrowright{}"],
    ["21bc", "\\leftharpoonup{}"],
    ["21bd", "\\leftharpoondown{}"],
    ["21be", "\\upharpoonright{}"],
    ["21bf", "\\upharpoonleft{}"],
    ["21c0", "\\rightharpoonup{}"],
    ["21c1", "\\rightharpoondown{}"],
    ["21c2", "\\downharpoonright{}"],
    ["21c3", "\\downharpoonleft{}"],
    ["21c4", "\\rightleftarrows{}"],
    ["21c5", "\\dblarrowupdown{}"],
    ["21c6", "\\leftrightarrows{}"],
    ["21c7", "\\leftleftarrows{}"],
    ["21c8", "\\upuparrows{}"],
    ["21c9", "\\rightrightarrows{}"],
    ["21ca", "\\downdownarrows{}"],
    ["21cb", "\\leftrightharpoons{}"],
    ["21cc", "\\rightleftharpoons{}"],
    ["21cd", "\\nLeftarrow{}"],
    ["21ce", "\\nLeftrightarrow{}"],
    ["21cf", "\\nRightarrow{}"],
    ["21d0", "\\Leftarrow{}"],
    ["21d1", "\\Uparrow{}"],
    ["21d2", "\\Rightarrow{}"],
    ["21d3", "\\Downarrow{}"],
    ["21d4", "\\Leftrightarrow{}"],
    ["21d5", "\\Updownarrow{}"],
    ["21da", "\\Lleftarrow{}"],
    ["21db", "\\Rrightarrow{}"],
    ["21dd", "\\rightsquigarrow{}"],
    ["21f5", "\\DownArrowUpArrow{}"],
    ["2200", "\\forall{}"],
    ["2201", "\\complement{}"],
    ["2202", "\\partial{}"],
    ["2203", "\\exists{}"],
    ["2204", "\\nexists{}"],
    ["2205", "\\varnothing{}"],
    ["2207", "\\nabla{}"],
    ["2208", "\\in{}"],
    ["2209", "\\not\\in{}"],
    ["220b", "\\ni{}"],
    ["220c", "\\not\\ni{}"],
    ["220f", "\\prod{}"],
    ["2210", "\\coprod{}"],
    ["2211", "\\sum{}"],
    ["2212", "-"],
    ["2213", "\\mp{}"],
    ["2214", "\\dotplus{}"],
    ["2216", "\\setminus{}"],
    ["2217", "{\\_\\ast}"],
    ["2218", "\\circ{}"],
    ["2219", "\\bullet{}"],
    ["221a", "\\surd{}"],
    ["221d", "\\propto{}"],
    ["221e", "\\infty{}"],
    ["221f", "\\rightangle{}"],
    ["2220", "\\angle{}"],
    ["2221", "\\measuredangle{}"],
    ["2222", "\\sphericalangle{}"],
    ["2223", "\\mid{}"],
    ["2224", "\\nmid{}"],
    ["2225", "\\parallel{}"],
    ["2226", "\\nparallel{}"],
    ["2227", "\\wedge{}"],
    ["2228", "\\vee{}"],
    ["2229", "\\cap{}"],
    ["222a", "\\cup{}"],
    ["222b", "\\int{}"],
    ["222c", "\\int\\!\\int{}"],
    ["222d", "\\int\\!\\int\\!\\int{}"],
    ["222e", "\\oint{}"],
    ["222f", "\\surfintegral{}"],
    ["2230", "\\volintegral{}"],
    ["2231", "\\clwintegral{}"],
    ["2232", "\\ElsevierGlyph{2232}"],
    ["2233", "\\ElsevierGlyph{2233}"],
    ["2234", "\\therefore{}"],
    ["2235", "\\because{}"],
    ["2237", "\\Colon{}"],
    ["2238", "\\ElsevierGlyph{2238}"],
    ["223a", "\\mathbin{{:}\\!\\!{-}\\!\\!{:}}"],
    ["223b", "\\homothetic{}"],
    ["223c", "\\sim{}"],
    ["223d", "\\backsim{}"],
    ["223e", "\\lazysinv{}"],
    ["2240", "\\wr{}"],
    ["2241", "\\not\\sim{}"],
    ["2242", "\\ElsevierGlyph{2242}"],
    ["2243", "\\simeq{}"],
    ["2244", "\\not\\simeq{}"],
    ["2245", "\\cong{}"],
    ["2246", "\\approxnotequal{}"],
    ["2247", "\\not\\cong{}"],
    ["2248", "\\approx{}"],
    ["2249", "\\not\\approx{}"],
    ["224a", "\\approxeq{}"],
    ["224b", "\\tildetrpl{}"],
    ["224c", "\\allequal{}"],
    ["224d", "\\asymp{}"],
    ["224e", "\\Bumpeq{}"],
    ["224f", "\\bumpeq{}"],
    ["2250", "\\doteq{}"],
    ["2251", "\\doteqdot{}"],
    ["2252", "\\fallingdotseq{}"],
    ["2253", "\\risingdotseq{}"],
    ["2254", ":="],
    ["2255", "=:"],
    ["2256", "\\eqcirc{}"],
    ["2257", "\\circeq{}"],
    ["2259", "\\estimates{}"],
    ["225a", "\\ElsevierGlyph{225A}"],
    ["225b", "\\starequal{}"],
    ["225c", "\\triangleq{}"],
    ["225f", "\\ElsevierGlyph{225F}"],
    ["2260", "\\not ="],
    ["2261", "\\equiv{}"],
    ["2262", "\\not\\equiv{}"],
    ["2264", "\\leq{}"],
    ["2265", "\\geq{}"],
    ["2266", "\\leqq{}"],
    ["2267", "\\geqq{}"],
    ["2268", "\\lneqq{}"],
    ["2269", "\\gneqq{}"],
    ["226a", "\\ll{}"],
    ["226b", "\\gg{}"],
    ["226c", "\\between{}"],
    ["226d", "\\not\\kern-0.3em\\times{}"],
    ["226e", "\\not&lt;"],
    ["226f", "\\not&gt;"],
    ["2270", "\\not\\leq{}"],
    ["2271", "\\not\\geq{}"],
    ["2272", "\\lessequivlnt{}"],
    ["2273", "\\greaterequivlnt{}"],
    ["2274", "\\ElsevierGlyph{2274}"],
    ["2275", "\\ElsevierGlyph{2275}"],
    ["2276", "\\lessgtr{}"],
    ["2277", "\\gtrless{}"],
    ["2278", "\\notlessgreater{}"],
    ["2279", "\\notgreaterless{}"],
    ["227a", "\\prec{}"],
    ["227b", "\\succ{}"],
    ["227c", "\\preccurlyeq{}"],
    ["227d", "\\succcurlyeq{}"],
    ["227e", "\\precapprox{}"],
    ["227f", "\\succapprox{}"],
    ["2280", "\\not\\prec{}"],
    ["2281", "\\not\\succ{}"],
    ["2282", "\\subset{}"],
    ["2283", "\\supset{}"],
    ["2284", "\\not\\subset{}"],
    ["2285", "\\not\\supset{}"],
    ["2286", "\\subseteq{}"],
    ["2287", "\\supseteq{}"],
    ["2288", "\\not\\subseteq{}"],
    ["2289", "\\not\\supseteq{}"],
    ["228a", "\\subsetneq{}"],
    ["228b", "\\supsetneq{}"],
    ["228e", "\\uplus{}"],
    ["228f", "\\sqsubset{}"],
    ["2290", "\\sqsupset{}"],
    ["2291", "\\sqsubseteq{}"],
    ["2292", "\\sqsupseteq{}"],
    ["2293", "\\sqcap{}"],
    ["2294", "\\sqcup{}"],
    ["2295", "\\oplus{}"],
    ["2296", "\\ominus{}"],
    ["2297", "\\otimes{}"],
    ["2298", "\\oslash{}"],
    ["2299", "\\odot{}"],
    ["229a", "\\circledcirc{}"],
    ["229b", "\\circledast{}"],
    ["229d", "\\circleddash{}"],
    ["229e", "\\boxplus{}"],
    ["229f", "\\boxminus{}"],
    ["22a0", "\\boxtimes{}"],
    ["22a1", "\\boxdot{}"],
    ["22a2", "\\vdash{}"],
    ["22a3", "\\dashv{}"],
    ["22a4", "\\top{}"],
    ["22a5", "\\perp{}"],
    ["22a7", "\\truestate{}"],
    ["22a8", "\\forcesextra{}"],
    ["22a9", "\\Vdash{}"],
    ["22aa", "\\Vvdash{}"],
    ["22ab", "\\VDash{}"],
    ["22ac", "\\nvdash{}"],
    ["22ad", "\\nvDash{}"],
    ["22ae", "\\nVdash{}"],
    ["22af", "\\nVDash{}"],
    ["22b2", "\\vartriangleleft{}"],
    ["22b3", "\\vartriangleright{}"],
    ["22b4", "\\trianglelefteq{}"],
    ["22b5", "\\trianglerighteq{}"],
    ["22b6", "\\original{}"],
    ["22b7", "\\image{}"],
    ["22b8", "\\multimap{}"],
    ["22b9", "\\hermitconjmatrix{}"],
    ["22ba", "\\intercal{}"],
    ["22bb", "\\veebar{}"],
    ["22be", "\\rightanglearc{}"],
    ["22c0", "\\ElsevierGlyph{22C0}"],
    ["22c1", "\\ElsevierGlyph{22C1}"],
    ["22c2", "\\bigcap{}"],
    ["22c3", "\\bigcup{}"],
    ["22c4", "\\diamond{}"],
    ["22c5", "\\cdot{}"],
    ["22c6", "\\star{}"],
    ["22c7", "\\divideontimes{}"],
    ["22c8", "\\bowtie{}"],
    ["22c9", "\\ltimes{}"],
    ["22ca", "\\rtimes{}"],
    ["22cb", "\\leftthreetimes{}"],
    ["22cc", "\\rightthreetimes{}"],
    ["22cd", "\\backsimeq{}"],
    ["22ce", "\\curlyvee{}"],
    ["22cf", "\\curlywedge{}"],
    ["22d0", "\\Subset{}"],
    ["22d1", "\\Supset{}"],
    ["22d2", "\\Cap{}"],
    ["22d3", "\\Cup{}"],
    ["22d4", "\\pitchfork{}"],
    ["22d6", "\\lessdot{}"],
    ["22d7", "\\gtrdot{}"],
    ["22d8", "\\verymuchless{}"],
    ["22d9", "\\verymuchgreater{}"],
    ["22da", "\\lesseqgtr{}"],
    ["22db", "\\gtreqless{}"],
    ["22de", "\\curlyeqprec{}"],
    ["22df", "\\curlyeqsucc{}"],
    ["22e2", "\\not\\sqsubseteq{}"],
    ["22e3", "\\not\\sqsupseteq{}"],
    ["22e5", "\\Elzsqspne{}"],
    ["22e6", "\\lnsim{}"],
    ["22e7", "\\gnsim{}"],
    ["22e8", "\\precedesnotsimilar{}"],
    ["22e9", "\\succnsim{}"],
    ["22ea", "\\ntriangleleft{}"],
    ["22eb", "\\ntriangleright{}"],
    ["22ec", "\\ntrianglelefteq{}"],
    ["22ed", "\\ntrianglerighteq{}"],
    ["22ee", "\\vdots{}"],
    ["22ef", "\\cdots{}"],
    ["22f0", "\\upslopeellipsis{}"],
    ["22f1", "\\downslopeellipsis{}"],
    ["2305", "\\barwedge{}"],
    ["2306", "\\perspcorrespond{}"],
    ["2308", "\\lceil{}"],
    ["2309", "\\rceil{}"],
    ["230a", "\\lfloor{}"],
    ["230b", "\\rfloor{}"],
    ["2315", "\\recorder{}"],
    ["2316", '\\mathchar"2208'],
    ["231c", "\\ulcorner{}"],
    ["231d", "\\urcorner{}"],
    ["231e", "\\llcorner{}"],
    ["231f", "\\lrcorner{}"],
    ["2322", "\\frown{}"],
    ["2323", "\\smile{}"],
    ["2329", "\\langle{}"],
    ["232a", "\\rangle{}"],
    ["233d", "\\ElsevierGlyph{E838}"],
    ["23a3", "\\Elzdlcorn{}"],
    ["23b0", "\\lmoustache{}"],
    ["23b1", "\\rmoustache{}"],
    ["2423", "\\textvisiblespace{}"],
    ["2460", "\\ding{172}"],
    ["2461", "\\ding{173}"],
    ["2462", "\\ding{174}"],
    ["2463", "\\ding{175}"],
    ["2464", "\\ding{176}"],
    ["2465", "\\ding{177}"],
    ["2466", "\\ding{178}"],
    ["2467", "\\ding{179}"],
    ["2468", "\\ding{180}"],
    ["2469", "\\ding{181}"],
    ["24c8", "\\circledS{}"],
    ["2506", "\\Elzdshfnc{}"],
    ["2519", "\\Elzsqfnw{}"],
    ["2571", "\\diagup{}"],
    ["25a0", "\\ding{110}"],
    ["25a1", "\\square{}"],
    ["25aa", "\\blacksquare{}"],
    ["25ad", "\\fbox{~~}"],
    ["25af", "\\Elzvrecto{}"],
    ["25b1", "\\ElsevierGlyph{E381}"],
    ["25b2", "\\ding{115}"],
    ["25b3", "\\bigtriangleup{}"],
    ["25b4", "\\blacktriangle{}"],
    ["25b5", "\\vartriangle{}"],
    ["25b8", "\\blacktriangleright{}"],
    ["25b9", "\\triangleright{}"],
    ["25bc", "\\ding{116}"],
    ["25bd", "\\bigtriangledown{}"],
    ["25be", "\\blacktriangledown{}"],
    ["25bf", "\\triangledown{}"],
    ["25c2", "\\blacktriangleleft{}"],
    ["25c3", "\\triangleleft{}"],
    ["25c6", "\\ding{117}"],
    ["25ca", "\\lozenge{}"],
    ["25cb", "\\bigcirc{}"],
    ["25cf", "\\ding{108}"],
    ["25d0", "\\Elzcirfl{}"],
    ["25d1", "\\Elzcirfr{}"],
    ["25d2", "\\Elzcirfb{}"],
    ["25d7", "\\ding{119}"],
    ["25d8", "\\Elzrvbull{}"],
    ["25e7", "\\Elzsqfl{}"],
    ["25e8", "\\Elzsqfr{}"],
    ["25ea", "\\Elzsqfse{}"],
    ["25ef", "\\bigcirc{}"],
    ["2605", "\\ding{72}"],
    ["2606", "\\ding{73}"],
    ["260e", "\\ding{37}"],
    ["261b", "\\ding{42}"],
    ["261e", "\\ding{43}"],
    ["263e", "\\rightmoon{}"],
    ["263f", "\\mercury{}"],
    ["2640", "\\venus{}"],
    ["2642", "\\male{}"],
    ["2643", "\\jupiter{}"],
    ["2644", "\\saturn{}"],
    ["2645", "\\uranus{}"],
    ["2646", "\\neptune{}"],
    ["2647", "\\pluto{}"],
    ["2648", "\\aries{}"],
    ["2649", "\\taurus{}"],
    ["264a", "\\gemini{}"],
    ["264b", "\\cancer{}"],
    ["264c", "\\leo{}"],
    ["264d", "\\virgo{}"],
    ["264e", "\\libra{}"],
    ["264f", "\\scorpio{}"],
    ["2650", "\\sagittarius{}"],
    ["2651", "\\capricornus{}"],
    ["2652", "\\aquarius{}"],
    ["2653", "\\pisces{}"],
    ["2660", "\\ding{171}"],
    ["2662", "\\diamond{}"],
    ["2663", "\\ding{168}"],
    ["2665", "\\ding{170}"],
    ["2666", "\\ding{169}"],
    ["2669", "\\quarternote{}"],
    ["266a", "\\eighthnote{}"],
    ["266d", "\\flat{}"],
    ["266e", "\\natural{}"],
    ["266f", "\\sharp{}"],
    ["2701", "\\ding{33}"],
    ["2702", "\\ding{34}"],
    ["2703", "\\ding{35}"],
    ["2704", "\\ding{36}"],
    ["2706", "\\ding{38}"],
    ["2707", "\\ding{39}"],
    ["2708", "\\ding{40}"],
    ["2709", "\\ding{41}"],
    ["270c", "\\ding{44}"],
    ["270d", "\\ding{45}"],
    ["270e", "\\ding{46}"],
    ["270f", "\\ding{47}"],
    ["2710", "\\ding{48}"],
    ["2711", "\\ding{49}"],
    ["2712", "\\ding{50}"],
    ["2713", "\\ding{51}"],
    ["2714", "\\ding{52}"],
    ["2715", "\\ding{53}"],
    ["2716", "\\ding{54}"],
    ["2717", "\\ding{55}"],
    ["2718", "\\ding{56}"],
    ["2719", "\\ding{57}"],
    ["271a", "\\ding{58}"],
    ["271b", "\\ding{59}"],
    ["271c", "\\ding{60}"],
    ["271d", "\\ding{61}"],
    ["271e", "\\ding{62}"],
    ["271f", "\\ding{63}"],
    ["2720", "\\ding{64}"],
    ["2721", "\\ding{65}"],
    ["2722", "\\ding{66}"],
    ["2723", "\\ding{67}"],
    ["2724", "\\ding{68}"],
    ["2725", "\\ding{69}"],
    ["2726", "\\ding{70}"],
    ["2727", "\\ding{71}"],
    ["2729", "\\ding{73}"],
    ["272a", "\\ding{74}"],
    ["272b", "\\ding{75}"],
    ["272c", "\\ding{76}"],
    ["272d", "\\ding{77}"],
    ["272e", "\\ding{78}"],
    ["272f", "\\ding{79}"],
    ["2730", "\\ding{80}"],
    ["2731", "\\ding{81}"],
    ["2732", "\\ding{82}"],
    ["2733", "\\ding{83}"],
    ["2734", "\\ding{84}"],
    ["2735", "\\ding{85}"],
    ["2736", "\\ding{86}"],
    ["2737", "\\ding{87}"],
    ["2738", "\\ding{88}"],
    ["2739", "\\ding{89}"],
    ["273a", "\\ding{90}"],
    ["273b", "\\ding{91}"],
    ["273c", "\\ding{92}"],
    ["273d", "\\ding{93}"],
    ["273e", "\\ding{94}"],
    ["273f", "\\ding{95}"],
    ["2740", "\\ding{96}"],
    ["2741", "\\ding{97}"],
    ["2742", "\\ding{98}"],
    ["2743", "\\ding{99}"],
    ["2744", "\\ding{100}"],
    ["2745", "\\ding{101}"],
    ["2746", "\\ding{102}"],
    ["2747", "\\ding{103}"],
    ["2748", "\\ding{104}"],
    ["2749", "\\ding{105}"],
    ["274a", "\\ding{106}"],
    ["274b", "\\ding{107}"],
    ["274d", "\\ding{109}"],
    ["274f", "\\ding{111}"],
    ["2750", "\\ding{112}"],
    ["2751", "\\ding{113}"],
    ["2752", "\\ding{114}"],
    ["2756", "\\ding{118}"],
    ["2758", "\\ding{120}"],
    ["2759", "\\ding{121}"],
    ["275a", "\\ding{122}"],
    ["275b", "\\ding{123}"],
    ["275c", "\\ding{124}"],
    ["275d", "\\ding{125}"],
    ["275e", "\\ding{126}"],
    ["2761", "\\ding{161}"],
    ["2762", "\\ding{162}"],
    ["2763", "\\ding{163}"],
    ["2764", "\\ding{164}"],
    ["2765", "\\ding{165}"],
    ["2766", "\\ding{166}"],
    ["2767", "\\ding{167}"],
    ["2776", "\\ding{182}"],
    ["2777", "\\ding{183}"],
    ["2778", "\\ding{184}"],
    ["2779", "\\ding{185}"],
    ["277a", "\\ding{186}"],
    ["277b", "\\ding{187}"],
    ["277c", "\\ding{188}"],
    ["277d", "\\ding{189}"],
    ["277e", "\\ding{190}"],
    ["277f", "\\ding{191}"],
    ["2780", "\\ding{192}"],
    ["2781", "\\ding{193}"],
    ["2782", "\\ding{194}"],
    ["2783", "\\ding{195}"],
    ["2784", "\\ding{196}"],
    ["2785", "\\ding{197}"],
    ["2786", "\\ding{198}"],
    ["2787", "\\ding{199}"],
    ["2788", "\\ding{200}"],
    ["2789", "\\ding{201}"],
    ["278a", "\\ding{202}"],
    ["278b", "\\ding{203}"],
    ["278c", "\\ding{204}"],
    ["278d", "\\ding{205}"],
    ["278e", "\\ding{206}"],
    ["278f", "\\ding{207}"],
    ["2790", "\\ding{208}"],
    ["2791", "\\ding{209}"],
    ["2792", "\\ding{210}"],
    ["2793", "\\ding{211}"],
    ["2794", "\\ding{212}"],
    ["2798", "\\ding{216}"],
    ["2799", "\\ding{217}"],
    ["279a", "\\ding{218}"],
    ["279b", "\\ding{219}"],
    ["279c", "\\ding{220}"],
    ["279d", "\\ding{221}"],
    ["279e", "\\ding{222}"],
    ["279f", "\\ding{223}"],
    ["27a0", "\\ding{224}"],
    ["27a1", "\\ding{225}"],
    ["27a2", "\\ding{226}"],
    ["27a3", "\\ding{227}"],
    ["27a4", "\\ding{228}"],
    ["27a5", "\\ding{229}"],
    ["27a6", "\\ding{230}"],
    ["27a7", "\\ding{231}"],
    ["27a8", "\\ding{232}"],
    ["27a9", "\\ding{233}"],
    ["27aa", "\\ding{234}"],
    ["27ab", "\\ding{235}"],
    ["27ac", "\\ding{236}"],
    ["27ad", "\\ding{237}"],
    ["27ae", "\\ding{238}"],
    ["27af", "\\ding{239}"],
    ["27b1", "\\ding{241}"],
    ["27b2", "\\ding{242}"],
    ["27b3", "\\ding{243}"],
    ["27b4", "\\ding{244}"],
    ["27b5", "\\ding{245}"],
    ["27b6", "\\ding{246}"],
    ["27b7", "\\ding{247}"],
    ["27b8", "\\ding{248}"],
    ["27b9", "\\ding{249}"],
    ["27ba", "\\ding{250}"],
    ["27bb", "\\ding{251}"],
    ["27bc", "\\ding{252}"],
    ["27bd", "\\ding{253}"],
    ["27be", "\\ding{254}"],
    ["27f5", "\\longleftarrow{}"],
    ["27f6", "\\longrightarrow{}"],
    ["27f7", "\\longleftrightarrow{}"],
    ["27f8", "\\Longleftarrow{}"],
    ["27f9", "\\Longrightarrow{}"],
    ["27fa", "\\Longleftrightarrow{}"],
    ["27fc", "\\longmapsto{}"],
    ["27ff", "\\sim\\joinrel\\leadsto"],
    ["2905", "\\ElsevierGlyph{E212}"],
    ["2912", "\\UpArrowBar{}"],
    ["2913", "\\DownArrowBar{}"],
    ["2923", "\\ElsevierGlyph{E20C}"],
    ["2924", "\\ElsevierGlyph{E20D}"],
    ["2925", "\\ElsevierGlyph{E20B}"],
    ["2926", "\\ElsevierGlyph{E20A}"],
    ["2927", "\\ElsevierGlyph{E211}"],
    ["2928", "\\ElsevierGlyph{E20E}"],
    ["2929", "\\ElsevierGlyph{E20F}"],
    ["292a", "\\ElsevierGlyph{E210}"],
    ["2933", "\\ElsevierGlyph{E21C}"],
    ["2936", "\\ElsevierGlyph{E21A}"],
    ["2937", "\\ElsevierGlyph{E219}"],
    ["2940", "\\Elolarr{}"],
    ["2941", "\\Elorarr{}"],
    ["2942", "\\ElzRlarr{}"],
    ["2944", "\\ElzrLarr{}"],
    ["2947", "\\Elzrarrx{}"],
    ["294e", "\\LeftRightVector{}"],
    ["294f", "\\RightUpDownVector{}"],
    ["2950", "\\DownLeftRightVector{}"],
    ["2951", "\\LeftUpDownVector{}"],
    ["2952", "\\LeftVectorBar{}"],
    ["2953", "\\RightVectorBar{}"],
    ["2954", "\\RightUpVectorBar{}"],
    ["2955", "\\RightDownVectorBar{}"],
    ["2956", "\\DownLeftVectorBar{}"],
    ["2957", "\\DownRightVectorBar{}"],
    ["2958", "\\LeftUpVectorBar{}"],
    ["2959", "\\LeftDownVectorBar{}"],
    ["295a", "\\LeftTeeVector{}"],
    ["295b", "\\RightTeeVector{}"],
    ["295c", "\\RightUpTeeVector{}"],
    ["295d", "\\RightDownTeeVector{}"],
    ["295e", "\\DownLeftTeeVector{}"],
    ["295f", "\\DownRightTeeVector{}"],
    ["2960", "\\LeftUpTeeVector{}"],
    ["2961", "\\LeftDownTeeVector{}"],
    ["296e", "\\UpEquilibrium{}"],
    ["296f", "\\ReverseUpEquilibrium{}"],
    ["2970", "\\RoundImplies{}"],
    ["297c", "\\ElsevierGlyph{E214}"],
    ["297d", "\\ElsevierGlyph{E215}"],
    ["2980", "\\Elztfnc{}"],
    ["2985", "\\ElsevierGlyph{3018}"],
    ["2986", "\\Elroang{}"],
    ["2993", "&lt;\\kern-0.58em("],
    ["2994", "\\ElsevierGlyph{E291}"],
    ["2999", "\\Elzddfnc{}"],
    ["299c", "\\Angle{}"],
    ["29a0", "\\Elzlpargt{}"],
    ["29b5", "\\ElsevierGlyph{E260}"],
    ["29b6", "\\ElsevierGlyph{E61B}"],
    ["29ca", "\\ElzLap{}"],
    ["29cb", "\\Elzdefas{}"],
    ["29cf", "\\LeftTriangleBar{}"],
    ["29d0", "\\RightTriangleBar{}"],
    ["29dc", "\\ElsevierGlyph{E372}"],
    ["29eb", "\\blacklozenge{}"],
    ["29f4", "\\RuleDelayed{}"],
    ["2a04", "\\Elxuplus{}"],
    ["2a05", "\\ElzThr{}"],
    ["2a06", "\\Elxsqcup{}"],
    ["2a07", "\\ElzInf{}"],
    ["2a08", "\\ElzSup{}"],
    ["2a0d", "\\ElzCint{}"],
    ["2a0f", "\\clockoint{}"],
    ["2a10", "\\ElsevierGlyph{E395}"],
    ["2a16", "\\sqrint{}"],
    ["2a25", "\\ElsevierGlyph{E25A}"],
    ["2a2a", "\\ElsevierGlyph{E25B}"],
    ["2a2d", "\\ElsevierGlyph{E25C}"],
    ["2a2e", "\\ElsevierGlyph{E25D}"],
    ["2a2f", "\\ElzTimes{}"],
    ["2a34", "\\ElsevierGlyph{E25E}"],
    ["2a35", "\\ElsevierGlyph{E25E}"],
    ["2a3c", "\\ElsevierGlyph{E259}"],
    ["2a3f", "\\amalg{}"],
    ["2a53", "\\ElzAnd{}"],
    ["2a54", "\\ElzOr{}"],
    ["2a55", "\\ElsevierGlyph{E36E}"],
    ["2a56", "\\ElOr{}"],
    ["2a5e", "\\perspcorrespond{}"],
    ["2a5f", "\\Elzminhat{}"],
    ["2a63", "\\ElsevierGlyph{225A}"],
    ["2a6e", "\\stackrel{*}{=}"],
    ["2a75", "\\Equal{}"],
    ["2a7d", "\\leqslant{}"],
    ["2a7e", "\\geqslant{}"],
    ["2a85", "\\lessapprox{}"],
    ["2a86", "\\gtrapprox{}"],
    ["2a87", "\\lneq{}"],
    ["2a88", "\\gneq{}"],
    ["2a89", "\\lnapprox{}"],
    ["2a8a", "\\gnapprox{}"],
    ["2a8b", "\\lesseqqgtr{}"],
    ["2a8c", "\\gtreqqless{}"],
    ["2a95", "\\eqslantless{}"],
    ["2a96", "\\eqslantgtr{}"],
    ["2a9d", "\\Pisymbol{ppi020}{117}"],
    ["2a9e", "\\Pisymbol{ppi020}{105}"],
    ["2aa1", "\\NestedLessLess{}"],
    ["2aa2", "\\NestedGreaterGreater{}"],
    ["2aaf", "\\preceq{}"],
    ["2ab0", "\\succeq{}"],
    ["2ab5", "\\precneqq{}"],
    ["2ab6", "\\succneqq{}"],
    ["2ab7", "\\precapprox{}"],
    ["2ab8", "\\succapprox{}"],
    ["2ab9", "\\precnapprox{}"],
    ["2aba", "\\succnapprox{}"],
    ["2ac5", "\\subseteqq{}"],
    ["2ac6", "\\supseteqq{}"],
    ["2acb", "\\subsetneqq{}"],
    ["2acc", "\\supsetneqq{}"],
    ["2aeb", "\\ElsevierGlyph{E30D}"],
    ["2af6", "\\Elztdcol{}"],
    ["2afd", "{{/}\\!\\!{/}}"],
    ["300a", "\\ElsevierGlyph{300A}"],
    ["300b", "\\ElsevierGlyph{300B}"],
    ["3018", "\\ElsevierGlyph{3018}"],
    ["3019", "\\ElsevierGlyph{3019}"],
    ["301a", "\\openbracketleft{}"],
    ["301b", "\\openbracketright{}"],
    ["fb00", "ff"],
    ["fb01", "fi"],
    ["fb02", "fl"],
    ["fb03", "ffi"],
    ["fb04", "ffl"],
    ["d400", "\\mathbf{A}"],
    ["d401", "\\mathbf{B}"],
    ["d402", "\\mathbf{C}"],
    ["d403", "\\mathbf{D}"],
    ["d404", "\\mathbf{E}"],
    ["d405", "\\mathbf{F}"],
    ["d406", "\\mathbf{G}"],
    ["d407", "\\mathbf{H}"],
    ["d408", "\\mathbf{I}"],
    ["d409", "\\mathbf{J}"],
    ["d40a", "\\mathbf{K}"],
    ["d40b", "\\mathbf{L}"],
    ["d40c", "\\mathbf{M}"],
    ["d40d", "\\mathbf{N}"],
    ["d40e", "\\mathbf{O}"],
    ["d40f", "\\mathbf{P}"],
    ["d410", "\\mathbf{Q}"],
    ["d411", "\\mathbf{R}"],
    ["d412", "\\mathbf{S}"],
    ["d413", "\\mathbf{T}"],
    ["d414", "\\mathbf{U}"],
    ["d415", "\\mathbf{V}"],
    ["d416", "\\mathbf{W}"],
    ["d417", "\\mathbf{X}"],
    ["d418", "\\mathbf{Y}"],
    ["d419", "\\mathbf{Z}"],
    ["d41a", "\\mathbf{a}"],
    ["d41b", "\\mathbf{b}"],
    ["d41c", "\\mathbf{c}"],
    ["d41d", "\\mathbf{d}"],
    ["d41e", "\\mathbf{e}"],
    ["d41f", "\\mathbf{f}"],
    ["d420", "\\mathbf{g}"],
    ["d421", "\\mathbf{h}"],
    ["d422", "\\mathbf{i}"],
    ["d423", "\\mathbf{j}"],
    ["d424", "\\mathbf{k}"],
    ["d425", "\\mathbf{l}"],
    ["d426", "\\mathbf{m}"],
    ["d427", "\\mathbf{n}"],
    ["d428", "\\mathbf{o}"],
    ["d429", "\\mathbf{p}"],
    ["d42a", "\\mathbf{q}"],
    ["d42b", "\\mathbf{r}"],
    ["d42c", "\\mathbf{s}"],
    ["d42d", "\\mathbf{t}"],
    ["d42e", "\\mathbf{u}"],
    ["d42f", "\\mathbf{v}"],
    ["d430", "\\mathbf{w}"],
    ["d431", "\\mathbf{x}"],
    ["d432", "\\mathbf{y}"],
    ["d433", "\\mathbf{z}"],
    ["d434", "\\mathsl{A}"],
    ["d435", "\\mathsl{B}"],
    ["d436", "\\mathsl{C}"],
    ["d437", "\\mathsl{D}"],
    ["d438", "\\mathsl{E}"],
    ["d439", "\\mathsl{F}"],
    ["d43a", "\\mathsl{G}"],
    ["d43b", "\\mathsl{H}"],
    ["d43c", "\\mathsl{I}"],
    ["d43d", "\\mathsl{J}"],
    ["d43e", "\\mathsl{K}"],
    ["d43f", "\\mathsl{L}"],
    ["d440", "\\mathsl{M}"],
    ["d441", "\\mathsl{N}"],
    ["d442", "\\mathsl{O}"],
    ["d443", "\\mathsl{P}"],
    ["d444", "\\mathsl{Q}"],
    ["d445", "\\mathsl{R}"],
    ["d446", "\\mathsl{S}"],
    ["d447", "\\mathsl{T}"],
    ["d448", "\\mathsl{U}"],
    ["d449", "\\mathsl{V}"],
    ["d44a", "\\mathsl{W}"],
    ["d44b", "\\mathsl{X}"],
    ["d44c", "\\mathsl{Y}"],
    ["d44d", "\\mathsl{Z}"],
    ["d44e", "\\mathsl{a}"],
    ["d44f", "\\mathsl{b}"],
    ["d450", "\\mathsl{c}"],
    ["d451", "\\mathsl{d}"],
    ["d452", "\\mathsl{e}"],
    ["d453", "\\mathsl{f}"],
    ["d454", "\\mathsl{g}"],
    ["d456", "\\mathsl{i}"],
    ["d457", "\\mathsl{j}"],
    ["d458", "\\mathsl{k}"],
    ["d459", "\\mathsl{l}"],
    ["d45a", "\\mathsl{m}"],
    ["d45b", "\\mathsl{n}"],
    ["d45c", "\\mathsl{o}"],
    ["d45d", "\\mathsl{p}"],
    ["d45e", "\\mathsl{q}"],
    ["d45f", "\\mathsl{r}"],
    ["d460", "\\mathsl{s}"],
    ["d461", "\\mathsl{t}"],
    ["d462", "\\mathsl{u}"],
    ["d463", "\\mathsl{v}"],
    ["d464", "\\mathsl{w}"],
    ["d465", "\\mathsl{x}"],
    ["d466", "\\mathsl{y}"],
    ["d467", "\\mathsl{z}"],
    ["d468", "\\mathbit{A}"],
    ["d469", "\\mathbit{B}"],
    ["d46a", "\\mathbit{C}"],
    ["d46b", "\\mathbit{D}"],
    ["d46c", "\\mathbit{E}"],
    ["d46d", "\\mathbit{F}"],
    ["d46e", "\\mathbit{G}"],
    ["d46f", "\\mathbit{H}"],
    ["d470", "\\mathbit{I}"],
    ["d471", "\\mathbit{J}"],
    ["d472", "\\mathbit{K}"],
    ["d473", "\\mathbit{L}"],
    ["d474", "\\mathbit{M}"],
    ["d475", "\\mathbit{N}"],
    ["d476", "\\mathbit{O}"],
    ["d477", "\\mathbit{P}"],
    ["d478", "\\mathbit{Q}"],
    ["d479", "\\mathbit{R}"],
    ["d47a", "\\mathbit{S}"],
    ["d47b", "\\mathbit{T}"],
    ["d47c", "\\mathbit{U}"],
    ["d47d", "\\mathbit{V}"],
    ["d47e", "\\mathbit{W}"],
    ["d47f", "\\mathbit{X}"],
    ["d480", "\\mathbit{Y}"],
    ["d481", "\\mathbit{Z}"],
    ["d482", "\\mathbit{a}"],
    ["d483", "\\mathbit{b}"],
    ["d484", "\\mathbit{c}"],
    ["d485", "\\mathbit{d}"],
    ["d486", "\\mathbit{e}"],
    ["d487", "\\mathbit{f}"],
    ["d488", "\\mathbit{g}"],
    ["d489", "\\mathbit{h}"],
    ["d48a", "\\mathbit{i}"],
    ["d48b", "\\mathbit{j}"],
    ["d48c", "\\mathbit{k}"],
    ["d48d", "\\mathbit{l}"],
    ["d48e", "\\mathbit{m}"],
    ["d48f", "\\mathbit{n}"],
    ["d490", "\\mathbit{o}"],
    ["d491", "\\mathbit{p}"],
    ["d492", "\\mathbit{q}"],
    ["d493", "\\mathbit{r}"],
    ["d494", "\\mathbit{s}"],
    ["d495", "\\mathbit{t}"],
    ["d496", "\\mathbit{u}"],
    ["d497", "\\mathbit{v}"],
    ["d498", "\\mathbit{w}"],
    ["d499", "\\mathbit{x}"],
    ["d49a", "\\mathbit{y}"],
    ["d49b", "\\mathbit{z}"],
    ["d49c", "\\mathscr{A}"],
    ["d49e", "\\mathscr{C}"],
    ["d49f", "\\mathscr{D}"],
    ["d4a2", "\\mathscr{G}"],
    ["d4a5", "\\mathscr{J}"],
    ["d4a6", "\\mathscr{K}"],
    ["d4a9", "\\mathscr{N}"],
    ["d4aa", "\\mathscr{O}"],
    ["d4ab", "\\mathscr{P}"],
    ["d4ac", "\\mathscr{Q}"],
    ["d4ae", "\\mathscr{S}"],
    ["d4af", "\\mathscr{T}"],
    ["d4b0", "\\mathscr{U}"],
    ["d4b1", "\\mathscr{V}"],
    ["d4b2", "\\mathscr{W}"],
    ["d4b3", "\\mathscr{X}"],
    ["d4b4", "\\mathscr{Y}"],
    ["d4b5", "\\mathscr{Z}"],
    ["d4b6", "\\mathscr{a}"],
    ["d4b7", "\\mathscr{b}"],
    ["d4b8", "\\mathscr{c}"],
    ["d4b9", "\\mathscr{d}"],
    ["d4bb", "\\mathscr{f}"],
    ["d4bd", "\\mathscr{h}"],
    ["d4be", "\\mathscr{i}"],
    ["d4bf", "\\mathscr{j}"],
    ["d4c0", "\\mathscr{k}"],
    ["d4c1", "\\mathscr{l}"],
    ["d4c2", "\\mathscr{m}"],
    ["d4c3", "\\mathscr{n}"],
    ["d4c5", "\\mathscr{p}"],
    ["d4c6", "\\mathscr{q}"],
    ["d4c7", "\\mathscr{r}"],
    ["d4c8", "\\mathscr{s}"],
    ["d4c9", "\\mathscr{t}"],
    ["d4ca", "\\mathscr{u}"],
    ["d4cb", "\\mathscr{v}"],
    ["d4cc", "\\mathscr{w}"],
    ["d4cd", "\\mathscr{x}"],
    ["d4ce", "\\mathscr{y}"],
    ["d4cf", "\\mathscr{z}"],
    ["d4d0", "\\mathmit{A}"],
    ["d4d1", "\\mathmit{B}"],
    ["d4d2", "\\mathmit{C}"],
    ["d4d3", "\\mathmit{D}"],
    ["d4d4", "\\mathmit{E}"],
    ["d4d5", "\\mathmit{F}"],
    ["d4d6", "\\mathmit{G}"],
    ["d4d7", "\\mathmit{H}"],
    ["d4d8", "\\mathmit{I}"],
    ["d4d9", "\\mathmit{J}"],
    ["d4da", "\\mathmit{K}"],
    ["d4db", "\\mathmit{L}"],
    ["d4dc", "\\mathmit{M}"],
    ["d4dd", "\\mathmit{N}"],
    ["d4de", "\\mathmit{O}"],
    ["d4df", "\\mathmit{P}"],
    ["d4e0", "\\mathmit{Q}"],
    ["d4e1", "\\mathmit{R}"],
    ["d4e2", "\\mathmit{S}"],
    ["d4e3", "\\mathmit{T}"],
    ["d4e4", "\\mathmit{U}"],
    ["d4e5", "\\mathmit{V}"],
    ["d4e6", "\\mathmit{W}"],
    ["d4e7", "\\mathmit{X}"],
    ["d4e8", "\\mathmit{Y}"],
    ["d4e9", "\\mathmit{Z}"],
    ["d4ea", "\\mathmit{a}"],
    ["d4eb", "\\mathmit{b}"],
    ["d4ec", "\\mathmit{c}"],
    ["d4ed", "\\mathmit{d}"],
    ["d4ee", "\\mathmit{e}"],
    ["d4ef", "\\mathmit{f}"],
    ["d4f0", "\\mathmit{g}"],
    ["d4f1", "\\mathmit{h}"],
    ["d4f2", "\\mathmit{i}"],
    ["d4f3", "\\mathmit{j}"],
    ["d4f4", "\\mathmit{k}"],
    ["d4f5", "\\mathmit{l}"],
    ["d4f6", "\\mathmit{m}"],
    ["d4f7", "\\mathmit{n}"],
    ["d4f8", "\\mathmit{o}"],
    ["d4f9", "\\mathmit{p}"],
    ["d4fa", "\\mathmit{q}"],
    ["d4fb", "\\mathmit{r}"],
    ["d4fc", "\\mathmit{s}"],
    ["d4fd", "\\mathmit{t}"],
    ["d4fe", "\\mathmit{u}"],
    ["d4ff", "\\mathmit{v}"],
    ["d500", "\\mathmit{w}"],
    ["d501", "\\mathmit{x}"],
    ["d502", "\\mathmit{y}"],
    ["d503", "\\mathmit{z}"],
    ["d504", "\\mathfrak{A}"],
    ["d505", "\\mathfrak{B}"],
    ["d507", "\\mathfrak{D}"],
    ["d508", "\\mathfrak{E}"],
    ["d509", "\\mathfrak{F}"],
    ["d50a", "\\mathfrak{G}"],
    ["d50d", "\\mathfrak{J}"],
    ["d50e", "\\mathfrak{K}"],
    ["d50f", "\\mathfrak{L}"],
    ["d510", "\\mathfrak{M}"],
    ["d511", "\\mathfrak{N}"],
    ["d512", "\\mathfrak{O}"],
    ["d513", "\\mathfrak{P}"],
    ["d514", "\\mathfrak{Q}"],
    ["d516", "\\mathfrak{S}"],
    ["d517", "\\mathfrak{T}"],
    ["d518", "\\mathfrak{U}"],
    ["d519", "\\mathfrak{V}"],
    ["d51a", "\\mathfrak{W}"],
    ["d51b", "\\mathfrak{X}"],
    ["d51c", "\\mathfrak{Y}"],
    ["d51e", "\\mathfrak{a}"],
    ["d51f", "\\mathfrak{b}"],
    ["d520", "\\mathfrak{c}"],
    ["d521", "\\mathfrak{d}"],
    ["d522", "\\mathfrak{e}"],
    ["d523", "\\mathfrak{f}"],
    ["d524", "\\mathfrak{g}"],
    ["d525", "\\mathfrak{h}"],
    ["d526", "\\mathfrak{i}"],
    ["d527", "\\mathfrak{j}"],
    ["d528", "\\mathfrak{k}"],
    ["d529", "\\mathfrak{l}"],
    ["d52a", "\\mathfrak{m}"],
    ["d52b", "\\mathfrak{n}"],
    ["d52c", "\\mathfrak{o}"],
    ["d52d", "\\mathfrak{p}"],
    ["d52e", "\\mathfrak{q}"],
    ["d52f", "\\mathfrak{r}"],
    ["d530", "\\mathfrak{s}"],
    ["d531", "\\mathfrak{t}"],
    ["d532", "\\mathfrak{u}"],
    ["d533", "\\mathfrak{v}"],
    ["d534", "\\mathfrak{w}"],
    ["d535", "\\mathfrak{x}"],
    ["d536", "\\mathfrak{y}"],
    ["d537", "\\mathfrak{z}"],
    ["d538", "\\mathbb{A}"],
    ["d539", "\\mathbb{B}"],
    ["d53b", "\\mathbb{D}"],
    ["d53c", "\\mathbb{E}"],
    ["d53d", "\\mathbb{F}"],
    ["d53e", "\\mathbb{G}"],
    ["d540", "\\mathbb{I}"],
    ["d541", "\\mathbb{J}"],
    ["d542", "\\mathbb{K}"],
    ["d543", "\\mathbb{L}"],
    ["d544", "\\mathbb{M}"],
    ["d546", "\\mathbb{O}"],
    ["d54a", "\\mathbb{S}"],
    ["d54b", "\\mathbb{T}"],
    ["d54c", "\\mathbb{U}"],
    ["d54d", "\\mathbb{V}"],
    ["d54e", "\\mathbb{W}"],
    ["d54f", "\\mathbb{X}"],
    ["d550", "\\mathbb{Y}"],
    ["d552", "\\mathbb{a}"],
    ["d553", "\\mathbb{b}"],
    ["d554", "\\mathbb{c}"],
    ["d555", "\\mathbb{d}"],
    ["d556", "\\mathbb{e}"],
    ["d557", "\\mathbb{f}"],
    ["d558", "\\mathbb{g}"],
    ["d559", "\\mathbb{h}"],
    ["d55a", "\\mathbb{i}"],
    ["d55b", "\\mathbb{j}"],
    ["d55c", "\\mathbb{k}"],
    ["d55d", "\\mathbb{l}"],
    ["d55e", "\\mathbb{m}"],
    ["d55f", "\\mathbb{n}"],
    ["d560", "\\mathbb{o}"],
    ["d561", "\\mathbb{p}"],
    ["d562", "\\mathbb{q}"],
    ["d563", "\\mathbb{r}"],
    ["d564", "\\mathbb{s}"],
    ["d565", "\\mathbb{t}"],
    ["d566", "\\mathbb{u}"],
    ["d567", "\\mathbb{v}"],
    ["d568", "\\mathbb{w}"],
    ["d569", "\\mathbb{x}"],
    ["d56a", "\\mathbb{y}"],
    ["d56b", "\\mathbb{z}"],
    ["d56c", "\\mathslbb{A}"],
    ["d56d", "\\mathslbb{B}"],
    ["d56e", "\\mathslbb{C}"],
    ["d56f", "\\mathslbb{D}"],
    ["d570", "\\mathslbb{E}"],
    ["d571", "\\mathslbb{F}"],
    ["d572", "\\mathslbb{G}"],
    ["d573", "\\mathslbb{H}"],
    ["d574", "\\mathslbb{I}"],
    ["d575", "\\mathslbb{J}"],
    ["d576", "\\mathslbb{K}"],
    ["d577", "\\mathslbb{L}"],
    ["d578", "\\mathslbb{M}"],
    ["d579", "\\mathslbb{N}"],
    ["d57a", "\\mathslbb{O}"],
    ["d57b", "\\mathslbb{P}"],
    ["d57c", "\\mathslbb{Q}"],
    ["d57d", "\\mathslbb{R}"],
    ["d57e", "\\mathslbb{S}"],
    ["d57f", "\\mathslbb{T}"],
    ["d580", "\\mathslbb{U}"],
    ["d581", "\\mathslbb{V}"],
    ["d582", "\\mathslbb{W}"],
    ["d583", "\\mathslbb{X}"],
    ["d584", "\\mathslbb{Y}"],
    ["d585", "\\mathslbb{Z}"],
    ["d586", "\\mathslbb{a}"],
    ["d587", "\\mathslbb{b}"],
    ["d588", "\\mathslbb{c}"],
    ["d589", "\\mathslbb{d}"],
    ["d58a", "\\mathslbb{e}"],
    ["d58b", "\\mathslbb{f}"],
    ["d58c", "\\mathslbb{g}"],
    ["d58d", "\\mathslbb{h}"],
    ["d58e", "\\mathslbb{i}"],
    ["d58f", "\\mathslbb{j}"],
    ["d590", "\\mathslbb{k}"],
    ["d591", "\\mathslbb{l}"],
    ["d592", "\\mathslbb{m}"],
    ["d593", "\\mathslbb{n}"],
    ["d594", "\\mathslbb{o}"],
    ["d595", "\\mathslbb{p}"],
    ["d596", "\\mathslbb{q}"],
    ["d597", "\\mathslbb{r}"],
    ["d598", "\\mathslbb{s}"],
    ["d599", "\\mathslbb{t}"],
    ["d59a", "\\mathslbb{u}"],
    ["d59b", "\\mathslbb{v}"],
    ["d59c", "\\mathslbb{w}"],
    ["d59d", "\\mathslbb{x}"],
    ["d59e", "\\mathslbb{y}"],
    ["d59f", "\\mathslbb{z}"],
    ["d5a0", "\\mathsf{A}"],
    ["d5a1", "\\mathsf{B}"],
    ["d5a2", "\\mathsf{C}"],
    ["d5a3", "\\mathsf{D}"],
    ["d5a4", "\\mathsf{E}"],
    ["d5a5", "\\mathsf{F}"],
    ["d5a6", "\\mathsf{G}"],
    ["d5a7", "\\mathsf{H}"],
    ["d5a8", "\\mathsf{I}"],
    ["d5a9", "\\mathsf{J}"],
    ["d5aa", "\\mathsf{K}"],
    ["d5ab", "\\mathsf{L}"],
    ["d5ac", "\\mathsf{M}"],
    ["d5ad", "\\mathsf{N}"],
    ["d5ae", "\\mathsf{O}"],
    ["d5af", "\\mathsf{P}"],
    ["d5b0", "\\mathsf{Q}"],
    ["d5b1", "\\mathsf{R}"],
    ["d5b2", "\\mathsf{S}"],
    ["d5b3", "\\mathsf{T}"],
    ["d5b4", "\\mathsf{U}"],
    ["d5b5", "\\mathsf{V}"],
    ["d5b6", "\\mathsf{W}"],
    ["d5b7", "\\mathsf{X}"],
    ["d5b8", "\\mathsf{Y}"],
    ["d5b9", "\\mathsf{Z}"],
    ["d5ba", "\\mathsf{a}"],
    ["d5bb", "\\mathsf{b}"],
    ["d5bc", "\\mathsf{c}"],
    ["d5bd", "\\mathsf{d}"],
    ["d5be", "\\mathsf{e}"],
    ["d5bf", "\\mathsf{f}"],
    ["d5c0", "\\mathsf{g}"],
    ["d5c1", "\\mathsf{h}"],
    ["d5c2", "\\mathsf{i}"],
    ["d5c3", "\\mathsf{j}"],
    ["d5c4", "\\mathsf{k}"],
    ["d5c5", "\\mathsf{l}"],
    ["d5c6", "\\mathsf{m}"],
    ["d5c7", "\\mathsf{n}"],
    ["d5c8", "\\mathsf{o}"],
    ["d5c9", "\\mathsf{p}"],
    ["d5ca", "\\mathsf{q}"],
    ["d5cb", "\\mathsf{r}"],
    ["d5cc", "\\mathsf{s}"],
    ["d5cd", "\\mathsf{t}"],
    ["d5ce", "\\mathsf{u}"],
    ["d5cf", "\\mathsf{v}"],
    ["d5d0", "\\mathsf{w}"],
    ["d5d1", "\\mathsf{x}"],
    ["d5d2", "\\mathsf{y}"],
    ["d5d3", "\\mathsf{z}"],
    ["d5d4", "\\mathsfbf{A}"],
    ["d5d5", "\\mathsfbf{B}"],
    ["d5d6", "\\mathsfbf{C}"],
    ["d5d7", "\\mathsfbf{D}"],
    ["d5d8", "\\mathsfbf{E}"],
    ["d5d9", "\\mathsfbf{F}"],
    ["d5da", "\\mathsfbf{G}"],
    ["d5db", "\\mathsfbf{H}"],
    ["d5dc", "\\mathsfbf{I}"],
    ["d5dd", "\\mathsfbf{J}"],
    ["d5de", "\\mathsfbf{K}"],
    ["d5df", "\\mathsfbf{L}"],
    ["d5e0", "\\mathsfbf{M}"],
    ["d5e1", "\\mathsfbf{N}"],
    ["d5e2", "\\mathsfbf{O}"],
    ["d5e3", "\\mathsfbf{P}"],
    ["d5e4", "\\mathsfbf{Q}"],
    ["d5e5", "\\mathsfbf{R}"],
    ["d5e6", "\\mathsfbf{S}"],
    ["d5e7", "\\mathsfbf{T}"],
    ["d5e8", "\\mathsfbf{U}"],
    ["d5e9", "\\mathsfbf{V}"],
    ["d5ea", "\\mathsfbf{W}"],
    ["d5eb", "\\mathsfbf{X}"],
    ["d5ec", "\\mathsfbf{Y}"],
    ["d5ed", "\\mathsfbf{Z}"],
    ["d5ee", "\\mathsfbf{a}"],
    ["d5ef", "\\mathsfbf{b}"],
    ["d5f0", "\\mathsfbf{c}"],
    ["d5f1", "\\mathsfbf{d}"],
    ["d5f2", "\\mathsfbf{e}"],
    ["d5f3", "\\mathsfbf{f}"],
    ["d5f4", "\\mathsfbf{g}"],
    ["d5f5", "\\mathsfbf{h}"],
    ["d5f6", "\\mathsfbf{i}"],
    ["d5f7", "\\mathsfbf{j}"],
    ["d5f8", "\\mathsfbf{k}"],
    ["d5f9", "\\mathsfbf{l}"],
    ["d5fa", "\\mathsfbf{m}"],
    ["d5fb", "\\mathsfbf{n}"],
    ["d5fc", "\\mathsfbf{o}"],
    ["d5fd", "\\mathsfbf{p}"],
    ["d5fe", "\\mathsfbf{q}"],
    ["d5ff", "\\mathsfbf{r}"],
    ["d600", "\\mathsfbf{s}"],
    ["d601", "\\mathsfbf{t}"],
    ["d602", "\\mathsfbf{u}"],
    ["d603", "\\mathsfbf{v}"],
    ["d604", "\\mathsfbf{w}"],
    ["d605", "\\mathsfbf{x}"],
    ["d606", "\\mathsfbf{y}"],
    ["d607", "\\mathsfbf{z}"],
    ["d608", "\\mathsfsl{A}"],
    ["d609", "\\mathsfsl{B}"],
    ["d60a", "\\mathsfsl{C}"],
    ["d60b", "\\mathsfsl{D}"],
    ["d60c", "\\mathsfsl{E}"],
    ["d60d", "\\mathsfsl{F}"],
    ["d60e", "\\mathsfsl{G}"],
    ["d60f", "\\mathsfsl{H}"],
    ["d610", "\\mathsfsl{I}"],
    ["d611", "\\mathsfsl{J}"],
    ["d612", "\\mathsfsl{K}"],
    ["d613", "\\mathsfsl{L}"],
    ["d614", "\\mathsfsl{M}"],
    ["d615", "\\mathsfsl{N}"],
    ["d616", "\\mathsfsl{O}"],
    ["d617", "\\mathsfsl{P}"],
    ["d618", "\\mathsfsl{Q}"],
    ["d619", "\\mathsfsl{R}"],
    ["d61a", "\\mathsfsl{S}"],
    ["d61b", "\\mathsfsl{T}"],
    ["d61c", "\\mathsfsl{U}"],
    ["d61d", "\\mathsfsl{V}"],
    ["d61e", "\\mathsfsl{W}"],
    ["d61f", "\\mathsfsl{X}"],
    ["d620", "\\mathsfsl{Y}"],
    ["d621", "\\mathsfsl{Z}"],
    ["d622", "\\mathsfsl{a}"],
    ["d623", "\\mathsfsl{b}"],
    ["d624", "\\mathsfsl{c}"],
    ["d625", "\\mathsfsl{d}"],
    ["d626", "\\mathsfsl{e}"],
    ["d627", "\\mathsfsl{f}"],
    ["d628", "\\mathsfsl{g}"],
    ["d629", "\\mathsfsl{h}"],
    ["d62a", "\\mathsfsl{i}"],
    ["d62b", "\\mathsfsl{j}"],
    ["d62c", "\\mathsfsl{k}"],
    ["d62d", "\\mathsfsl{l}"],
    ["d62e", "\\mathsfsl{m}"],
    ["d62f", "\\mathsfsl{n}"],
    ["d630", "\\mathsfsl{o}"],
    ["d631", "\\mathsfsl{p}"],
    ["d632", "\\mathsfsl{q}"],
    ["d633", "\\mathsfsl{r}"],
    ["d634", "\\mathsfsl{s}"],
    ["d635", "\\mathsfsl{t}"],
    ["d636", "\\mathsfsl{u}"],
    ["d637", "\\mathsfsl{v}"],
    ["d638", "\\mathsfsl{w}"],
    ["d639", "\\mathsfsl{x}"],
    ["d63a", "\\mathsfsl{y}"],
    ["d63b", "\\mathsfsl{z}"],
    ["d63c", "\\mathsfbfsl{A}"],
    ["d63d", "\\mathsfbfsl{B}"],
    ["d63e", "\\mathsfbfsl{C}"],
    ["d63f", "\\mathsfbfsl{D}"],
    ["d640", "\\mathsfbfsl{E}"],
    ["d641", "\\mathsfbfsl{F}"],
    ["d642", "\\mathsfbfsl{G}"],
    ["d643", "\\mathsfbfsl{H}"],
    ["d644", "\\mathsfbfsl{I}"],
    ["d645", "\\mathsfbfsl{J}"],
    ["d646", "\\mathsfbfsl{K}"],
    ["d647", "\\mathsfbfsl{L}"],
    ["d648", "\\mathsfbfsl{M}"],
    ["d649", "\\mathsfbfsl{N}"],
    ["d64a", "\\mathsfbfsl{O}"],
    ["d64b", "\\mathsfbfsl{P}"],
    ["d64c", "\\mathsfbfsl{Q}"],
    ["d64d", "\\mathsfbfsl{R}"],
    ["d64e", "\\mathsfbfsl{S}"],
    ["d64f", "\\mathsfbfsl{T}"],
    ["d650", "\\mathsfbfsl{U}"],
    ["d651", "\\mathsfbfsl{V}"],
    ["d652", "\\mathsfbfsl{W}"],
    ["d653", "\\mathsfbfsl{X}"],
    ["d654", "\\mathsfbfsl{Y}"],
    ["d655", "\\mathsfbfsl{Z}"],
    ["d656", "\\mathsfbfsl{a}"],
    ["d657", "\\mathsfbfsl{b}"],
    ["d658", "\\mathsfbfsl{c}"],
    ["d659", "\\mathsfbfsl{d}"],
    ["d65a", "\\mathsfbfsl{e}"],
    ["d65b", "\\mathsfbfsl{f}"],
    ["d65c", "\\mathsfbfsl{g}"],
    ["d65d", "\\mathsfbfsl{h}"],
    ["d65e", "\\mathsfbfsl{i}"],
    ["d65f", "\\mathsfbfsl{j}"],
    ["d660", "\\mathsfbfsl{k}"],
    ["d661", "\\mathsfbfsl{l}"],
    ["d662", "\\mathsfbfsl{m}"],
    ["d663", "\\mathsfbfsl{n}"],
    ["d664", "\\mathsfbfsl{o}"],
    ["d665", "\\mathsfbfsl{p}"],
    ["d666", "\\mathsfbfsl{q}"],
    ["d667", "\\mathsfbfsl{r}"],
    ["d668", "\\mathsfbfsl{s}"],
    ["d669", "\\mathsfbfsl{t}"],
    ["d66a", "\\mathsfbfsl{u}"],
    ["d66b", "\\mathsfbfsl{v}"],
    ["d66c", "\\mathsfbfsl{w}"],
    ["d66d", "\\mathsfbfsl{x}"],
    ["d66e", "\\mathsfbfsl{y}"],
    ["d66f", "\\mathsfbfsl{z}"],
    ["d670", "\\mathtt{A}"],
    ["d671", "\\mathtt{B}"],
    ["d672", "\\mathtt{C}"],
    ["d673", "\\mathtt{D}"],
    ["d674", "\\mathtt{E}"],
    ["d675", "\\mathtt{F}"],
    ["d676", "\\mathtt{G}"],
    ["d677", "\\mathtt{H}"],
    ["d678", "\\mathtt{I}"],
    ["d679", "\\mathtt{J}"],
    ["d67a", "\\mathtt{K}"],
    ["d67b", "\\mathtt{L}"],
    ["d67c", "\\mathtt{M}"],
    ["d67d", "\\mathtt{N}"],
    ["d67e", "\\mathtt{O}"],
    ["d67f", "\\mathtt{P}"],
    ["d680", "\\mathtt{Q}"],
    ["d681", "\\mathtt{R}"],
    ["d682", "\\mathtt{S}"],
    ["d683", "\\mathtt{T}"],
    ["d684", "\\mathtt{U}"],
    ["d685", "\\mathtt{V}"],
    ["d686", "\\mathtt{W}"],
    ["d687", "\\mathtt{X}"],
    ["d688", "\\mathtt{Y}"],
    ["d689", "\\mathtt{Z}"],
    ["d68a", "\\mathtt{a}"],
    ["d68b", "\\mathtt{b}"],
    ["d68c", "\\mathtt{c}"],
    ["d68d", "\\mathtt{d}"],
    ["d68e", "\\mathtt{e}"],
    ["d68f", "\\mathtt{f}"],
    ["d690", "\\mathtt{g}"],
    ["d691", "\\mathtt{h}"],
    ["d692", "\\mathtt{i}"],
    ["d693", "\\mathtt{j}"],
    ["d694", "\\mathtt{k}"],
    ["d695", "\\mathtt{l}"],
    ["d696", "\\mathtt{m}"],
    ["d697", "\\mathtt{n}"],
    ["d698", "\\mathtt{o}"],
    ["d699", "\\mathtt{p}"],
    ["d69a", "\\mathtt{q}"],
    ["d69b", "\\mathtt{r}"],
    ["d69c", "\\mathtt{s}"],
    ["d69d", "\\mathtt{t}"],
    ["d69e", "\\mathtt{u}"],
    ["d69f", "\\mathtt{v}"],
    ["d6a0", "\\mathtt{w}"],
    ["d6a1", "\\mathtt{x}"],
    ["d6a2", "\\mathtt{y}"],
    ["d6a3", "\\mathtt{z}"],
    ["d6a8", "\\mathbf{\\Alpha}"],
    ["d6a9", "\\mathbf{\\Beta}"],
    ["d6aa", "\\mathbf{\\Gamma}"],
    ["d6ab", "\\mathbf{\\Delta}"],
    ["d6ac", "\\mathbf{\\Epsilon}"],
    ["d6ad", "\\mathbf{\\Zeta}"],
    ["d6ae", "\\mathbf{\\Eta}"],
    ["d6af", "\\mathbf{\\Theta}"],
    ["d6b0", "\\mathbf{\\Iota}"],
    ["d6b1", "\\mathbf{\\Kappa}"],
    ["d6b2", "\\mathbf{\\Lambda}"],
    ["d6b5", "\\mathbf{\\Xi}"],
    ["d6b7", "\\mathbf{\\Pi}"],
    ["d6b8", "\\mathbf{\\Rho}"],
    ["d6b9", "\\mathbf{\\vartheta}"],
    ["d6ba", "\\mathbf{\\Sigma}"],
    ["d6bb", "\\mathbf{\\Tau}"],
    ["d6bc", "\\mathbf{\\Upsilon}"],
    ["d6bd", "\\mathbf{\\Phi}"],
    ["d6be", "\\mathbf{\\Chi}"],
    ["d6bf", "\\mathbf{\\Psi}"],
    ["d6c0", "\\mathbf{\\Omega}"],
    ["d6c1", "\\mathbf{\\nabla}"],
    ["d6c2", "\\mathbf{\\Alpha}"],
    ["d6c3", "\\mathbf{\\Beta}"],
    ["d6c4", "\\mathbf{\\Gamma}"],
    ["d6c5", "\\mathbf{\\Delta}"],
    ["d6c6", "\\mathbf{\\Epsilon}"],
    ["d6c7", "\\mathbf{\\Zeta}"],
    ["d6c8", "\\mathbf{\\Eta}"],
    ["d6c9", "\\mathbf{\\theta}"],
    ["d6ca", "\\mathbf{\\Iota}"],
    ["d6cb", "\\mathbf{\\Kappa}"],
    ["d6cc", "\\mathbf{\\Lambda}"],
    ["d6cf", "\\mathbf{\\Xi}"],
    ["d6d1", "\\mathbf{\\Pi}"],
    ["d6d2", "\\mathbf{\\Rho}"],
    ["d6d3", "\\mathbf{\\varsigma}"],
    ["d6d4", "\\mathbf{\\Sigma}"],
    ["d6d5", "\\mathbf{\\Tau}"],
    ["d6d6", "\\mathbf{\\Upsilon}"],
    ["d6d7", "\\mathbf{\\Phi}"],
    ["d6d8", "\\mathbf{\\Chi}"],
    ["d6d9", "\\mathbf{\\Psi}"],
    ["d6da", "\\mathbf{\\Omega}"],
    ["d6db", "\\partial{}"],
    ["d6dc", "\\in"],
    ["d6dd", "\\mathbf{\\vartheta}"],
    ["d6de", "\\mathbf{\\varkappa}"],
    ["d6df", "\\mathbf{\\phi}"],
    ["d6e0", "\\mathbf{\\varrho}"],
    ["d6e1", "\\mathbf{\\varpi}"],
    ["d6e2", "\\mathsl{\\Alpha}"],
    ["d6e3", "\\mathsl{\\Beta}"],
    ["d6e4", "\\mathsl{\\Gamma}"],
    ["d6e5", "\\mathsl{\\Delta}"],
    ["d6e6", "\\mathsl{\\Epsilon}"],
    ["d6e7", "\\mathsl{\\Zeta}"],
    ["d6e8", "\\mathsl{\\Eta}"],
    ["d6e9", "\\mathsl{\\Theta}"],
    ["d6ea", "\\mathsl{\\Iota}"],
    ["d6eb", "\\mathsl{\\Kappa}"],
    ["d6ec", "\\mathsl{\\Lambda}"],
    ["d6ef", "\\mathsl{\\Xi}"],
    ["d6f1", "\\mathsl{\\Pi}"],
    ["d6f2", "\\mathsl{\\Rho}"],
    ["d6f3", "\\mathsl{\\vartheta}"],
    ["d6f4", "\\mathsl{\\Sigma}"],
    ["d6f5", "\\mathsl{\\Tau}"],
    ["d6f6", "\\mathsl{\\Upsilon}"],
    ["d6f7", "\\mathsl{\\Phi}"],
    ["d6f8", "\\mathsl{\\Chi}"],
    ["d6f9", "\\mathsl{\\Psi}"],
    ["d6fa", "\\mathsl{\\Omega}"],
    ["d6fb", "\\mathsl{\\nabla}"],
    ["d6fc", "\\mathsl{\\Alpha}"],
    ["d6fd", "\\mathsl{\\Beta}"],
    ["d6fe", "\\mathsl{\\Gamma}"],
    ["d6ff", "\\mathsl{\\Delta}"],
    ["d700", "\\mathsl{\\Epsilon}"],
    ["d701", "\\mathsl{\\Zeta}"],
    ["d702", "\\mathsl{\\Eta}"],
    ["d703", "\\mathsl{\\Theta}"],
    ["d704", "\\mathsl{\\Iota}"],
    ["d705", "\\mathsl{\\Kappa}"],
    ["d706", "\\mathsl{\\Lambda}"],
    ["d709", "\\mathsl{\\Xi}"],
    ["d70b", "\\mathsl{\\Pi}"],
    ["d70c", "\\mathsl{\\Rho}"],
    ["d70d", "\\mathsl{\\varsigma}"],
    ["d70e", "\\mathsl{\\Sigma}"],
    ["d70f", "\\mathsl{\\Tau}"],
    ["d710", "\\mathsl{\\Upsilon}"],
    ["d711", "\\mathsl{\\Phi}"],
    ["d712", "\\mathsl{\\Chi}"],
    ["d713", "\\mathsl{\\Psi}"],
    ["d714", "\\mathsl{\\Omega}"],
    ["d715", "\\partial{}"],
    ["d716", "\\in"],
    ["d717", "\\mathsl{\\vartheta}"],
    ["d718", "\\mathsl{\\varkappa}"],
    ["d719", "\\mathsl{\\phi}"],
    ["d71a", "\\mathsl{\\varrho}"],
    ["d71b", "\\mathsl{\\varpi}"],
    ["d71c", "\\mathbit{\\Alpha}"],
    ["d71d", "\\mathbit{\\Beta}"],
    ["d71e", "\\mathbit{\\Gamma}"],
    ["d71f", "\\mathbit{\\Delta}"],
    ["d720", "\\mathbit{\\Epsilon}"],
    ["d721", "\\mathbit{\\Zeta}"],
    ["d722", "\\mathbit{\\Eta}"],
    ["d723", "\\mathbit{\\Theta}"],
    ["d724", "\\mathbit{\\Iota}"],
    ["d725", "\\mathbit{\\Kappa}"],
    ["d726", "\\mathbit{\\Lambda}"],
    ["d729", "\\mathbit{\\Xi}"],
    ["d72b", "\\mathbit{\\Pi}"],
    ["d72c", "\\mathbit{\\Rho}"],
    ["d72d", "\\mathbit{O}"],
    ["d72e", "\\mathbit{\\Sigma}"],
    ["d72f", "\\mathbit{\\Tau}"],
    ["d730", "\\mathbit{\\Upsilon}"],
    ["d731", "\\mathbit{\\Phi}"],
    ["d732", "\\mathbit{\\Chi}"],
    ["d733", "\\mathbit{\\Psi}"],
    ["d734", "\\mathbit{\\Omega}"],
    ["d735", "\\mathbit{\\nabla}"],
    ["d736", "\\mathbit{\\Alpha}"],
    ["d737", "\\mathbit{\\Beta}"],
    ["d738", "\\mathbit{\\Gamma}"],
    ["d739", "\\mathbit{\\Delta}"],
    ["d73a", "\\mathbit{\\Epsilon}"],
    ["d73b", "\\mathbit{\\Zeta}"],
    ["d73c", "\\mathbit{\\Eta}"],
    ["d73d", "\\mathbit{\\Theta}"],
    ["d73e", "\\mathbit{\\Iota}"],
    ["d73f", "\\mathbit{\\Kappa}"],
    ["d740", "\\mathbit{\\Lambda}"],
    ["d743", "\\mathbit{\\Xi}"],
    ["d745", "\\mathbit{\\Pi}"],
    ["d746", "\\mathbit{\\Rho}"],
    ["d747", "\\mathbit{\\varsigma}"],
    ["d748", "\\mathbit{\\Sigma}"],
    ["d749", "\\mathbit{\\Tau}"],
    ["d74a", "\\mathbit{\\Upsilon}"],
    ["d74b", "\\mathbit{\\Phi}"],
    ["d74c", "\\mathbit{\\Chi}"],
    ["d74d", "\\mathbit{\\Psi}"],
    ["d74e", "\\mathbit{\\Omega}"],
    ["d74f", "\\partial{}"],
    ["d750", "\\in"],
    ["d751", "\\mathbit{\\vartheta}"],
    ["d752", "\\mathbit{\\varkappa}"],
    ["d753", "\\mathbit{\\phi}"],
    ["d754", "\\mathbit{\\varrho}"],
    ["d755", "\\mathbit{\\varpi}"],
    ["d756", "\\mathsfbf{\\Alpha}"],
    ["d757", "\\mathsfbf{\\Beta}"],
    ["d758", "\\mathsfbf{\\Gamma}"],
    ["d759", "\\mathsfbf{\\Delta}"],
    ["d75a", "\\mathsfbf{\\Epsilon}"],
    ["d75b", "\\mathsfbf{\\Zeta}"],
    ["d75c", "\\mathsfbf{\\Eta}"],
    ["d75d", "\\mathsfbf{\\Theta}"],
    ["d75e", "\\mathsfbf{\\Iota}"],
    ["d75f", "\\mathsfbf{\\Kappa}"],
    ["d760", "\\mathsfbf{\\Lambda}"],
    ["d763", "\\mathsfbf{\\Xi}"],
    ["d765", "\\mathsfbf{\\Pi}"],
    ["d766", "\\mathsfbf{\\Rho}"],
    ["d767", "\\mathsfbf{\\vartheta}"],
    ["d768", "\\mathsfbf{\\Sigma}"],
    ["d769", "\\mathsfbf{\\Tau}"],
    ["d76a", "\\mathsfbf{\\Upsilon}"],
    ["d76b", "\\mathsfbf{\\Phi}"],
    ["d76c", "\\mathsfbf{\\Chi}"],
    ["d76d", "\\mathsfbf{\\Psi}"],
    ["d76e", "\\mathsfbf{\\Omega}"],
    ["d76f", "\\mathsfbf{\\nabla}"],
    ["d770", "\\mathsfbf{\\Alpha}"],
    ["d771", "\\mathsfbf{\\Beta}"],
    ["d772", "\\mathsfbf{\\Gamma}"],
    ["d773", "\\mathsfbf{\\Delta}"],
    ["d774", "\\mathsfbf{\\Epsilon}"],
    ["d775", "\\mathsfbf{\\Zeta}"],
    ["d776", "\\mathsfbf{\\Eta}"],
    ["d777", "\\mathsfbf{\\Theta}"],
    ["d778", "\\mathsfbf{\\Iota}"],
    ["d779", "\\mathsfbf{\\Kappa}"],
    ["d77a", "\\mathsfbf{\\Lambda}"],
    ["d77d", "\\mathsfbf{\\Xi}"],
    ["d77f", "\\mathsfbf{\\Pi}"],
    ["d780", "\\mathsfbf{\\Rho}"],
    ["d781", "\\mathsfbf{\\varsigma}"],
    ["d782", "\\mathsfbf{\\Sigma}"],
    ["d783", "\\mathsfbf{\\Tau}"],
    ["d784", "\\mathsfbf{\\Upsilon}"],
    ["d785", "\\mathsfbf{\\Phi}"],
    ["d786", "\\mathsfbf{\\Chi}"],
    ["d787", "\\mathsfbf{\\Psi}"],
    ["d788", "\\mathsfbf{\\Omega}"],
    ["d789", "\\partial{}"],
    ["d78a", "\\in"],
    ["d78b", "\\mathsfbf{\\vartheta}"],
    ["d78c", "\\mathsfbf{\\varkappa}"],
    ["d78d", "\\mathsfbf{\\phi}"],
    ["d78e", "\\mathsfbf{\\varrho}"],
    ["d78f", "\\mathsfbf{\\varpi}"],
    ["d790", "\\mathsfbfsl{\\Alpha}"],
    ["d791", "\\mathsfbfsl{\\Beta}"],
    ["d792", "\\mathsfbfsl{\\Gamma}"],
    ["d793", "\\mathsfbfsl{\\Delta}"],
    ["d794", "\\mathsfbfsl{\\Epsilon}"],
    ["d795", "\\mathsfbfsl{\\Zeta}"],
    ["d796", "\\mathsfbfsl{\\Eta}"],
    ["d797", "\\mathsfbfsl{\\vartheta}"],
    ["d798", "\\mathsfbfsl{\\Iota}"],
    ["d799", "\\mathsfbfsl{\\Kappa}"],
    ["d79a", "\\mathsfbfsl{\\Lambda}"],
    ["d79d", "\\mathsfbfsl{\\Xi}"],
    ["d79f", "\\mathsfbfsl{\\Pi}"],
    ["d7a0", "\\mathsfbfsl{\\Rho}"],
    ["d7a1", "\\mathsfbfsl{\\vartheta}"],
    ["d7a2", "\\mathsfbfsl{\\Sigma}"],
    ["d7a3", "\\mathsfbfsl{\\Tau}"],
    ["d7a4", "\\mathsfbfsl{\\Upsilon}"],
    ["d7a5", "\\mathsfbfsl{\\Phi}"],
    ["d7a6", "\\mathsfbfsl{\\Chi}"],
    ["d7a7", "\\mathsfbfsl{\\Psi}"],
    ["d7a8", "\\mathsfbfsl{\\Omega}"],
    ["d7a9", "\\mathsfbfsl{\\nabla}"],
    ["d7aa", "\\mathsfbfsl{\\Alpha}"],
    ["d7ab", "\\mathsfbfsl{\\Beta}"],
    ["d7ac", "\\mathsfbfsl{\\Gamma}"],
    ["d7ad", "\\mathsfbfsl{\\Delta}"],
    ["d7ae", "\\mathsfbfsl{\\Epsilon}"],
    ["d7af", "\\mathsfbfsl{\\Zeta}"],
    ["d7b0", "\\mathsfbfsl{\\Eta}"],
    ["d7b1", "\\mathsfbfsl{\\vartheta}"],
    ["d7b2", "\\mathsfbfsl{\\Iota}"],
    ["d7b3", "\\mathsfbfsl{\\Kappa}"],
    ["d7b4", "\\mathsfbfsl{\\Lambda}"],
    ["d7b7", "\\mathsfbfsl{\\Xi}"],
    ["d7b9", "\\mathsfbfsl{\\Pi}"],
    ["d7ba", "\\mathsfbfsl{\\Rho}"],
    ["d7bb", "\\mathsfbfsl{\\varsigma}"],
    ["d7bc", "\\mathsfbfsl{\\Sigma}"],
    ["d7bd", "\\mathsfbfsl{\\Tau}"],
    ["d7be", "\\mathsfbfsl{\\Upsilon}"],
    ["d7bf", "\\mathsfbfsl{\\Phi}"],
    ["d7c0", "\\mathsfbfsl{\\Chi}"],
    ["d7c1", "\\mathsfbfsl{\\Psi}"],
    ["d7c2", "\\mathsfbfsl{\\Omega}"],
    ["d7c3", "\\partial{}"],
    ["d7c4", "\\in"],
    ["d7c5", "\\mathsfbfsl{\\vartheta}"],
    ["d7c6", "\\mathsfbfsl{\\varkappa}"],
    ["d7c7", "\\mathsfbfsl{\\phi}"],
    ["d7c8", "\\mathsfbfsl{\\varrho}"],
    ["d7c9", "\\mathsfbfsl{\\varpi}"],
    ["d7ce", "\\mathbf{0}"],
    ["d7cf", "\\mathbf{1}"],
    ["d7d0", "\\mathbf{2}"],
    ["d7d1", "\\mathbf{3}"],
    ["d7d2", "\\mathbf{4}"],
    ["d7d3", "\\mathbf{5}"],
    ["d7d4", "\\mathbf{6}"],
    ["d7d5", "\\mathbf{7}"],
    ["d7d6", "\\mathbf{8}"],
    ["d7d7", "\\mathbf{9}"],
    ["d7d8", "\\mathbb{0}"],
    ["d7d9", "\\mathbb{1}"],
    ["d7da", "\\mathbb{2}"],
    ["d7db", "\\mathbb{3}"],
    ["d7dc", "\\mathbb{4}"],
    ["d7dd", "\\mathbb{5}"],
    ["d7de", "\\mathbb{6}"],
    ["d7df", "\\mathbb{7}"],
    ["d7e0", "\\mathbb{8}"],
    ["d7e1", "\\mathbb{9}"],
    ["d7e2", "\\mathsf{0}"],
    ["d7e3", "\\mathsf{1}"],
    ["d7e4", "\\mathsf{2}"],
    ["d7e5", "\\mathsf{3}"],
    ["d7e6", "\\mathsf{4}"],
    ["d7e7", "\\mathsf{5}"],
    ["d7e8", "\\mathsf{6}"],
    ["d7e9", "\\mathsf{7}"],
    ["d7ea", "\\mathsf{8}"],
    ["d7eb", "\\mathsf{9}"],
    ["d7ec", "\\mathsfbf{0}"],
    ["d7ed", "\\mathsfbf{1}"],
    ["d7ee", "\\mathsfbf{2}"],
    ["d7ef", "\\mathsfbf{3}"],
    ["d7f0", "\\mathsfbf{4}"],
    ["d7f1", "\\mathsfbf{5}"],
    ["d7f2", "\\mathsfbf{6}"],
    ["d7f3", "\\mathsfbf{7}"],
    ["d7f4", "\\mathsfbf{8}"],
    ["d7f5", "\\mathsfbf{9}"],
    ["d7f6", "\\mathtt{0}"],
    ["d7f7", "\\mathtt{1}"],
    ["d7f8", "\\mathtt{2}"],
    ["d7f9", "\\mathtt{3}"],
    ["d7fa", "\\mathtt{4}"],
    ["d7fb", "\\mathtt{5}"],
    ["d7fc", "\\mathtt{6}"],
    ["d7fd", "\\mathtt{7}"],
    ["d7fe", "\\mathtt{8}"],
    ["d7ff", "\\mathtt{9}"],
  ]);
  // src/utils.ts
  function escapeSpecialCharacters(str) {
    var _a2;
    var mathExpressions = [];
    str = str.replace(/\$[^$]+\$/, (match) => {
      mathExpressions.push(match);
      return "MATH.EXP.".concat(mathExpressions.length - 1);
    });
    var newstr = "";
    var escapeMode = false;
    for (var i = 0; i < str.length; i++) {
      if (escapeMode) {
        escapeMode = false;
        newstr += str[i];
        continue;
      }
      if (str[i] === "\\") {
        escapeMode = true;
        newstr += str[i];
        continue;
      }
      var c = str.charCodeAt(i).toString(16).padStart(4, "0");
      newstr += (_a2 = specialCharacters.get(c)) != null ? _a2 : str[i];
    }
    return newstr.replace(/MATH\.EXP\.(\d+)/, (_, i) => {
      var _a3;
      return (_a3 = mathExpressions[Number(i)]) != null ? _a3 : "";
    });
  }
  __name(escapeSpecialCharacters, "escapeSpecialCharacters");
  function titleCase(str) {
    return str.replace(/(\w)(\S*)/g, (_, first, rest) => {
      var word = first + rest;
      if (isRomanNumeral(word)) return word;
      return first.toLocaleUpperCase() + rest.toLocaleLowerCase();
    });
  }
  __name(titleCase, "titleCase");
  function isRomanNumeral(str) {
    return /^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$/.test(str);
  }
  __name(isRomanNumeral, "isRomanNumeral");
  function alphaNum(str) {
    return str.replace(/[^0-9A-Za-z]/g, "").toLocaleLowerCase();
  }
  __name(alphaNum, "alphaNum");
  function convertCRLF(str) {
    return str.replace(/\r\n?/g, "\n");
  }
  __name(convertCRLF, "convertCRLF");
  function wrapText(line, lineWidth) {
    var words2 = line.split(" ");
    var lines = [];
    var currLine = "";
    var _iteratorNormalCompletion = true,
      _didIteratorError = false,
      _iteratorError = undefined;
    try {
      for (var _iterator = words2.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _step_value = _slicedToArray(_step.value, 2),
          i = _step_value[0],
          word = _step_value[1];
        if (currLine.length + word.length + 1 > lineWidth && i > 0) {
          lines.push(currLine.trim());
          currLine = "";
        }
        currLine += word + " ";
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    return [...lines, currLine.trim()];
  }
  __name(wrapText, "wrapText");
  function unwrapText(str) {
    return str
      .replace(/\s*\n\s*\n\s*/g, "<<BIBTEX_TIDY_PARA>>")
      .replace(/\s*\n\s*/g, " ")
      .replace(/<<BIBTEX_TIDY_PARA>>/g, "\n\n");
  }
  __name(unwrapText, "unwrapText");
  function addEnclosingBraces(str, removeInsideBraces) {
    if (removeInsideBraces) {
      str = stringifyLaTeX(flattenLaTeX(parseLaTeX(str)));
    }
    return "{".concat(str, "}");
  }
  __name(addEnclosingBraces, "addEnclosingBraces");
  function removeEnclosingBraces(str) {
    return str.replace(/^\{([^{}]*)\}$/g, "$1");
  }
  __name(removeEnclosingBraces, "removeEnclosingBraces");
  function escapeURL(str) {
    return str.replace(/\\?_/g, "\\%5F");
  }
  __name(escapeURL, "escapeURL");
  function limitAuthors(str, maxAuthors) {
    var authors = str.split(" and ");
    if (authors.length > maxAuthors) {
      return [...authors.slice(0, maxAuthors), "others"].join(" and ");
    }
    return str;
  }
  __name(limitAuthors, "limitAuthors");
  function formatPageRange(str) {
    for (var i = 0; i < 4; i++) {
      str = str.replace(/(\d)\s*-\s*(\d)/g, "$1--$2");
    }
    return str;
  }
  __name(formatPageRange, "formatPageRange");
  function isEntryNode(node) {
    var _a2;
    return node.type !== "text" && ((_a2 = node.block) == null ? void 0 : _a2.type) === "entry";
  }
  __name(isEntryNode, "isEntryNode");
  // src/duplicates.ts
  function checkForDuplicates(ast, valueLookup, duplicateRules, merge) {
    var _a2, _b;
    var rules = /* @__PURE__ */ new Map();
    if (duplicateRules) {
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = duplicateRules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var rule = _step.value;
          rules.set(rule, !!merge);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    if (!rules.has("key")) {
      rules.set("key", false);
    }
    var duplicateEntries = /* @__PURE__ */ new Set();
    var warnings = [];
    var keys = /* @__PURE__ */ new Map();
    var dois = /* @__PURE__ */ new Map();
    var citations = /* @__PURE__ */ new Map();
    var abstracts = /* @__PURE__ */ new Map();
    var _iteratorNormalCompletion1 = true,
      _didIteratorError1 = false,
      _iteratorError1 = undefined;
    try {
      for (var _iterator1 = getEntries(ast)[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
        var entry = _step1.value;
        var entryValues = valueLookup.get(entry);
        var _iteratorNormalCompletion2 = true,
          _didIteratorError2 = false,
          _iteratorError2 = undefined;
        try {
          for (var _iterator2 = rules[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _step_value = _slicedToArray(_step2.value, 2),
              rule1 = _step_value[0],
              doMerge = _step_value[1];
            var duplicateOf = void 0;
            var warning = void 0;
            switch (rule1) {
              case "key": {
                if (!entry.key) continue;
                var keyLC = entry.key.toLocaleLowerCase();
                duplicateOf = keys.get(keyLC);
                if (!duplicateOf) {
                  keys.set(keyLC, entry);
                } else {
                  warning = "The citation key ".concat(entry.key, " has already been used.");
                }
                break;
              }
              case "doi": {
                var doi = alphaNum((_a2 = entryValues.get("doi")) != null ? _a2 : "");
                if (!doi) continue;
                duplicateOf = dois.get(doi);
                if (!duplicateOf) {
                  dois.set(doi, entry);
                } else {
                  warning = "Entry ".concat(entry.key, " has an identical DOI to entry ").concat(duplicateOf.key, ".");
                }
                break;
              }
              case "citation": {
                var ttl = entryValues.get("title");
                var aut = entryValues.get("author");
                var num = entryValues.get("number");
                if (!ttl || !aut) continue;
                var cit = [alphaNum(aut.split(/,| and/)[0]), alphaNum(ttl), alphaNum(num != null ? num : "0")].join(":");
                duplicateOf = citations.get(cit);
                if (!duplicateOf) {
                  citations.set(cit, entry);
                } else {
                  warning = "Entry ".concat(entry.key, " has similar content to entry ").concat(duplicateOf.key, ".");
                }
                break;
              }
              case "abstract": {
                var abstract = alphaNum((_b = entryValues.get("abstract")) != null ? _b : "");
                var abs = abstract.slice(0, 100);
                if (!abs) continue;
                duplicateOf = abstracts.get(abs);
                if (!duplicateOf) {
                  abstracts.set(abs, entry);
                } else {
                  warning = "Entry ".concat(entry.key, " has a similar abstract to entry ").concat(duplicateOf.key, ".");
                }
                break;
              }
            }
            if (duplicateOf && doMerge) {
              duplicateEntries.add(entry);
              mergeEntries(merge, duplicateOf, entry);
            }
            if (warning) {
              warnings.push({
                code: "DUPLICATE_ENTRY",
                rule: rule1,
                message: "Duplicate ".concat(doMerge ? "removed" : "detected", ". ").concat(warning),
              });
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError1 = true;
      _iteratorError1 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
          _iterator1.return();
        }
      } finally {
        if (_didIteratorError1) {
          throw _iteratorError1;
        }
      }
    }
    return {
      entries: duplicateEntries,
      warnings,
    };
  }
  __name(checkForDuplicates, "checkForDuplicates");
  function mergeEntries(merge, duplicateOf, entry) {
    if (!merge) return;
    switch (merge) {
      case "last":
        duplicateOf.key = entry.key;
        duplicateOf.fields = entry.fields;
        break;
      case "combine":
      case "overwrite":
        var _iteratorNormalCompletion = true,
          _didIteratorError = false,
          _iteratorError = undefined;
        try {
          var _loop = function () {
            var field = _step.value;
            var existing = duplicateOf.fields.find((f) => f.name.toLocaleLowerCase() === field.name.toLocaleLowerCase());
            if (!existing) {
              duplicateOf.fields.push(field);
            } else if (merge === "overwrite") {
              existing.value = field.value;
            }
          };
          for (var _iterator = entry.fields[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) _loop();
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        break;
      case "first":
        return;
    }
  }
  __name(mergeEntries, "mergeEntries");
  // src/sort.ts
  var MONTHS = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"];
  function sortEntries(ast, fieldMaps, sort) {
    var _a2, _b, _c, _d, _e;
    var sortIndexes = /* @__PURE__ */ new Map();
    var precedingMeta = [];
    var _iteratorNormalCompletion = true,
      _didIteratorError = false,
      _iteratorError = undefined;
    try {
      for (var _iterator = ast.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var item = _step.value;
        if (item.type === "text" || ((_a2 = item.block) == null ? void 0 : _a2.type) !== "entry") {
          precedingMeta.push(item);
          continue;
        }
        var sortIndex = /* @__PURE__ */ new Map();
        var _iteratorNormalCompletion1 = true,
          _didIteratorError1 = false,
          _iteratorError1 = undefined;
        try {
          for (var _iterator1 = sort[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
            var key = _step1.value;
            if (key.startsWith("-")) key = key.slice(1);
            var val = void 0;
            if (key === "key") {
              val = (_b = item.block.key) != null ? _b : "";
            } else if (key === "type") {
              val = item.command;
            } else if (key === "month") {
              var v = (_c = fieldMaps.get(item.block)) == null ? void 0 : _c.get(key);
              var i = v ? MONTHS.indexOf(v) : -1;
              val = i > -1 ? i : "";
            } else {
              val = (_e = (_d = fieldMaps.get(item.block)) == null ? void 0 : _d.get(key)) != null ? _e : "";
            }
            sortIndex.set(key, typeof val === "string" ? val.toLowerCase() : val);
          }
        } catch (err) {
          _didIteratorError1 = true;
          _iteratorError1 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
              _iterator1.return();
            }
          } finally {
            if (_didIteratorError1) {
              throw _iteratorError1;
            }
          }
        }
        sortIndexes.set(item, sortIndex);
        while (precedingMeta.length > 0) {
          sortIndexes.set(precedingMeta.pop(), sortIndex);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    var _iteratorNormalCompletion2 = true,
      _didIteratorError2 = false,
      _iteratorError2 = undefined;
    try {
      var _loop = function () {
        var prefixedKey = _step2.value;
        var desc = prefixedKey.startsWith("-");
        var key = desc ? prefixedKey.slice(1) : prefixedKey;
        ast.children.sort((a, b) => {
          var _a3, _b2, _c2, _d2;
          var ia = (_b2 = (_a3 = sortIndexes.get(a)) == null ? void 0 : _a3.get(key)) != null ? _b2 : "";
          var ib = (_d2 = (_c2 = sortIndexes.get(b)) == null ? void 0 : _c2.get(key)) != null ? _d2 : "";
          if (typeof ia === "number") ia = String(ia).padStart(50, "0");
          if (typeof ib === "number") ib = String(ib).padStart(50, "0");
          return (desc ? ib : ia).localeCompare(desc ? ia : ib);
        });
      };
      for (var _iterator2 = [...sort].reverse()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) _loop();
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }
  __name(sortEntries, "sortEntries");
  function sortEntryFields(ast, fieldOrder) {
    var _iteratorNormalCompletion = true,
      _didIteratorError = false,
      _iteratorError = undefined;
    try {
      for (var _iterator = getEntries(ast)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var entry = _step.value;
        entry.fields.sort((a, b) => {
          var orderA = fieldOrder.indexOf(a.name.toLocaleLowerCase());
          var orderB = fieldOrder.indexOf(b.name.toLocaleLowerCase());
          if (orderA === -1 && orderB === -1) return 0;
          if (orderA === -1) return 1;
          if (orderB === -1) return -1;
          if (orderB < orderA) return 1;
          if (orderB > orderA) return -1;
          return 0;
        });
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }
  __name(sortEntryFields, "sortEntryFields");
  // src/format.ts
  var MONTH_SET = new Set(MONTHS);
  function formatBibtex(ast, options, replacementKeys) {
    var omit = options.omit,
      tab = options.tab,
      space2 = options.space;
    var indent = tab ? "	" : " ".repeat(space2);
    var omitFields = new Set(omit);
    var bibtex = ast.children
      .map((child) => formatNode(child, options, indent, omitFields, replacementKeys))
      .join("")
      .trimEnd();
    if (!bibtex.endsWith("\n")) bibtex += "\n";
    return bibtex;
  }
  __name(formatBibtex, "formatBibtex");
  function formatNode(child, options, indent, omitFields, replacementKeys) {
    if (child.type === "text") {
      return formatComment(child.text, options);
    }
    if (!child.block) throw new Error("FATAL!");
    switch (child.block.type) {
      case "preamble":
      case "string":
        return "".concat(child.block.raw, "\n") + (options.blankLines ? "\n" : "");
      case "comment":
        return formatComment(child.block.raw, options);
      case "entry":
        return formatEntry(child.command, child.block, options, indent, omitFields, replacementKeys == null ? void 0 : replacementKeys.get(child.block)) + (options.blankLines ? "\n" : "");
    }
  }
  __name(formatNode, "formatNode");
  function formatEntry(entryType, entry, options, indent, omitFields, replacementKey) {
    var align = options.align,
      trailingCommas = options.trailingCommas,
      removeDuplicateFields = options.removeDuplicateFields,
      removeEmptyFields = options.removeEmptyFields,
      lowercase = options.lowercase;
    var bibtex = "";
    var itemType = lowercase ? entryType.toLocaleLowerCase() : entryType;
    bibtex += "@".concat(itemType, "{");
    var key = replacementKey != null ? replacementKey : entry.key;
    if (key) bibtex += "".concat(key, ",");
    var fieldSeen = /* @__PURE__ */ new Set();
    var _iteratorNormalCompletion = true,
      _didIteratorError = false,
      _iteratorError = undefined;
    try {
      for (var _iterator = entry.fields.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _step_value = _slicedToArray(_step.value, 2),
          i = _step_value[0],
          field = _step_value[1];
        var nameLowerCase = field.name.toLocaleLowerCase();
        var name2 = lowercase ? nameLowerCase : field.name;
        if (field.name === "") continue;
        if (omitFields.has(nameLowerCase)) continue;
        if (removeDuplicateFields && fieldSeen.has(nameLowerCase)) continue;
        fieldSeen.add(nameLowerCase);
        if (field.value.concat.length === 0) {
          if (removeEmptyFields) continue;
          bibtex += "\n".concat(indent).concat(name2);
        } else {
          var value = formatValue(field, options);
          if (removeEmptyFields && (value === "{}" || value === '""')) continue;
          bibtex += "\n"
            .concat(indent)
            .concat(name2.trim().padEnd(align - 1), " = ")
            .concat(value);
        }
        if (i < entry.fields.length - 1 || trailingCommas) bibtex += ",";
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    bibtex += "\n}\n";
    return bibtex;
  }
  __name(formatEntry, "formatEntry");
  function formatComment(comment2, param) {
    var stripComments = param.stripComments,
      tidyComments = param.tidyComments;
    if (stripComments) return "";
    if (tidyComments) {
      var trimmed = comment2.trim();
      if (trimmed === "") return "";
      return trimmed + "\n";
    } else {
      return comment2.replace(/^[ \t]*\n|[ \t]*$/g, "");
    }
  }
  __name(formatComment, "formatComment");
  function formatValue(field, options) {
    var curly = options.curly,
      numeric = options.numeric,
      align = options.align,
      stripEnclosingBraces = options.stripEnclosingBraces,
      dropAllCaps = options.dropAllCaps,
      escape = options.escape,
      encodeUrls = options.encodeUrls,
      wrap = options.wrap,
      maxAuthors = options.maxAuthors,
      tab = options.tab,
      space2 = options.space,
      enclosingBraces = options.enclosingBraces,
      removeBraces = options.removeBraces;
    var nameLowerCase = field.name.toLocaleLowerCase();
    var indent = tab ? "	" : " ".repeat(space2);
    var enclosingBracesFields = new Set((enclosingBraces != null ? enclosingBraces : []).map((field2) => field2.toLocaleLowerCase()));
    var removeBracesFields = new Set((removeBraces != null ? removeBraces : []).map((field2) => field2.toLocaleLowerCase()));
    return field.value.concat
      .map((param) => {
        var type = param.type,
          value = param.value;
        var isNumeric = value.match(/^[1-9][0-9]*$/);
        if (isNumeric && curly) {
          type = "braced";
        }
        if (type === "literal" || (numeric && isNumeric)) {
          return value;
        }
        var dig3 = value.slice(0, 3).toLowerCase();
        if (!curly && numeric && nameLowerCase === "month" && MONTH_SET.has(dig3)) {
          return dig3;
        }
        value = unwrapText(value);
        if (stripEnclosingBraces) {
          value = removeEnclosingBraces(value);
        }
        if (dropAllCaps && !value.match(/[a-z]/)) {
          value = titleCase(value);
        }
        if (nameLowerCase === "url" && encodeUrls) {
          value = escapeURL(value);
        }
        if (escape) {
          value = escapeSpecialCharacters(value);
        }
        if (nameLowerCase === "pages") {
          value = formatPageRange(value);
        }
        if (nameLowerCase === "author" && maxAuthors) {
          value = limitAuthors(value, maxAuthors);
        }
        if (removeBracesFields.has(nameLowerCase)) {
          value = stringifyLaTeX(flattenLaTeX(parseLaTeX(value)));
        }
        if (enclosingBracesFields.has(nameLowerCase) && (type === "braced" || curly)) {
          value = addEnclosingBraces(value, true);
        }
        if (type === "braced" && field.value.concat.length === 1) {
          value = value.trim();
        }
        if (type === "braced" || curly) {
          var lineLength = "".concat(indent).concat(align, "{").concat(value, "}").length;
          var multiLine = value.includes("\n\n");
          if ((wrap && lineLength > wrap) || multiLine) {
            var paragraphs = value.split("\n\n");
            var valIndent = indent.repeat(2);
            if (wrap) {
              var wrapCol = wrap;
              paragraphs = paragraphs.map((paragraph) => wrapText(paragraph, wrapCol - valIndent.length).join("\n" + valIndent));
            }
            value = "\n" + valIndent + paragraphs.join("\n\n".concat(valIndent)) + "\n" + indent;
          }
          return addEnclosingBraces(value);
        } else {
          return '"'.concat(value, '"');
        }
      })
      .join(" # ");
  }
  __name(formatValue, "formatValue");
  // src/parseAuthors.ts
  function parseAuthors(authors, sanitize) {
    return authors
      .replace(/\s+/g, " ")
      .split(/ and /i)
      .map((nameRaw) => {
        var name2 = nameRaw.trim();
        if (sanitize) {
          name2 = name2.replace(/["{}]/g, "");
        }
        var commaPos = name2.indexOf(",");
        if (commaPos > -1) {
          return {
            firstNames: name2.slice(commaPos + 1).trim(),
            lastName: name2.slice(0, commaPos).trim(),
          };
        } else {
          var lastSpacePos = name2.lastIndexOf(" ");
          return {
            firstNames: name2.slice(0, lastSpacePos).trim(),
            lastName: name2.slice(lastSpacePos).trim(),
          };
        }
      });
  }
  __name(parseAuthors, "parseAuthors");
  // src/generateKeys.ts
  var SPECIAL_MARKERS = {
    auth: {
      description: "Last name of first authors",
      callback: (v) => {
        var _a2, _b;
        var authors = parseAuthors((_a2 = v.get("author")) != null ? _a2 : "", true);
        var author =
          (_b = authors[0]) == null
            ? void 0
            : _b.lastName.replace(
                /(?:(?![A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])[\s\S])+/g,
                "_"
              );
        return author ? [author] : [];
      },
    },
    authEtAl: {
      description: "If 1 or 2 authors, both authors, otherwise first author and EtAl",
      callback: (v) => {
        var _a2;
        var authors = parseAuthors((_a2 = v.get("author")) != null ? _a2 : "", true);
        return [
          ...authors
            .slice(0, 2)
            .map((author) =>
              author.lastName.replace(
                /(?:(?![A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])[\s\S])+/g,
                "_"
              )
            ),
          ...(authors.length > 2 ? ["Et", "Al"] : []),
        ];
      },
    },
    authors: {
      description: "Last name all authors",
      callback: (v) => {
        var _a2;
        var authors = parseAuthors((_a2 = v.get("author")) != null ? _a2 : "", true);
        return authors.map((author) =>
          author.lastName.replace(
            /(?:(?![A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])[\s\S])+/g,
            "_"
          )
        );
      },
    },
    authorsN: {
      description: "Last name N authors, with EtAl if more",
      callback: (v, n) => {
        var _a2;
        var authors = parseAuthors((_a2 = v.get("author")) != null ? _a2 : "", true);
        return [
          ...authors
            .slice(0, n)
            .map((author) =>
              author.lastName.replace(
                /(?:(?![A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])[\s\S])+/g,
                "_"
              )
            ),
          ...(authors.length > n ? ["Et", "Al"] : []),
        ];
      },
    },
    veryshorttitle: {
      description: "First non-function word of the title",
      callback: (v) => nonFunctionWords(title(v)).slice(0, 1),
    },
    shorttitle: {
      description: "First three non-function words of the title",
      callback: (v) => nonFunctionWords(title(v)).slice(0, 3),
    },
    title: {
      description: "Full title, capitalized",
      callback: (v) => capitalize(words(title(v))),
    },
    fulltitle: {
      description: "Full title, verbatim",
      callback: (v) => words(title(v)),
    },
    year: {
      description: "Year",
      callback: (v) => {
        var _a2;
        var year = (_a2 = v.get("year")) == null ? void 0 : _a2.replace(/[^0-9]/g, "");
        return year ? [year] : [];
      },
    },
    duplicateLetter: {
      description: "If the multiple entries end up with the same key, then insert a letter a-z. By default this will be inserted at the end.",
      callback: () => ["[duplicateLetter]"],
    },
    duplicateNumber: {
      description: "If the multiple entries end up with the same key, then insert a number.",
      callback: () => ["[duplicateNumber]"],
    },
  };
  var MODIFIERS = {
    required: {
      description: "If data is missing, revert to existing key",
      callback: (words2) => {
        if (words2.length === 0) throw new MissingRequiredData();
        return words2;
      },
    },
    lower: {
      description: "Convert to lowercase",
      callback: (words2) => words2.map((word) => word.toLocaleLowerCase()),
    },
    upper: {
      description: "Convert to uppercase",
      callback: (words2) => words2.map((word) => word.toLocaleUpperCase()),
    },
    capitalize: {
      description: "Capitalize first letter of each word",
      callback: capitalize,
    },
  };
  var MissingRequiredData = class MissingRequiredData extends Error {};
  __name(MissingRequiredData, "MissingRequiredData");
  function generateKeys(ast, valueLookup, template) {
    var _a2;
    var template2 = template;
    if (!template.includes("[duplicateLetter]") && !template.includes("[duplicateNumber]")) {
      template2 = template + "[duplicateLetter]";
    }
    var entriesByKey = /* @__PURE__ */ new Map();
    var _iteratorNormalCompletion = true,
      _didIteratorError = false,
      _iteratorError = undefined;
    try {
      for (var _iterator = ast.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var node = _step.value;
        if (isEntryNode(node)) {
          var entryValues = valueLookup.get(node.block);
          if (!entryValues) continue;
          var newKey = generateKey(entryValues, template2);
          if (!newKey) continue;
          var keyEntries = (_a2 = entriesByKey.get(newKey)) != null ? _a2 : [];
          entriesByKey.set(newKey, [...keyEntries, node.block]);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    var keys = /* @__PURE__ */ new Map();
    var _iteratorNormalCompletion1 = true,
      _didIteratorError1 = false,
      _iteratorError1 = undefined;
    try {
      for (var _iterator1 = entriesByKey[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
        var _step_value = _slicedToArray(_step1.value, 2),
          key = _step_value[0],
          entries = _step_value[1];
        var _iteratorNormalCompletion2 = true,
          _didIteratorError2 = false,
          _iteratorError2 = undefined;
        try {
          for (var _iterator2 = entries.entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _step_value1 = _slicedToArray(_step2.value, 2),
              i = _step_value1[0],
              entry = _step_value1[1];
            var duplicateLetter = entries.length > 1 ? String.fromCharCode(97 + i) : "";
            var duplicateNumber = entries.length > 1 ? String(i + 1) : "";
            entry.key = key.replace(/\[duplicateLetter\]/g, duplicateLetter).replace(/\[duplicateNumber\]/g, duplicateNumber);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError1 = true;
      _iteratorError1 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
          _iterator1.return();
        }
      } finally {
        if (_didIteratorError1) {
          throw _iteratorError1;
        }
      }
    }
    return keys;
  }
  __name(generateKeys, "generateKeys");
  function generateKey(valueLookup, template) {
    try {
      var newKey = template.replace(/\[[^:\]]+(?::[^:\]]+)*\]/g, (m) => {
        var _m_slice_split = _toArray(m.slice(1, -1).split(":")),
          tokenKeyN = _m_slice_split[0],
          modifierKeys = _m_slice_split.slice(1);
        if (!tokenKeyN) {
          throw new Error("Token parse error");
        }
        var n;
        var tokenKey = tokenKeyN.replace(/[0-9]+/g, (m2) => {
          n = Number(m2);
          return "N";
        });
        var token = SPECIAL_MARKERS[tokenKey];
        var key;
        if (token) {
          key = token.callback(valueLookup, n);
        } else if (tokenKey === tokenKey.toLocaleUpperCase()) {
          var value = valueLookup.get(tokenKey.toLocaleLowerCase());
          key = value ? words(value) : [];
        } else {
          throw new Error("Invalid citation key token ".concat(tokenKey));
        }
        var _iteratorNormalCompletion = true,
          _didIteratorError = false,
          _iteratorError = undefined;
        try {
          for (var _iterator = modifierKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var modifierKey = _step.value;
            var modifier = MODIFIERS[modifierKey];
            if (modifier) {
              key = modifier.callback(key);
            } else {
              throw new Error("Invalid modifier ".concat(modifierKey));
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        return key.join("");
      });
      if (newKey === "") return;
      return newKey;
    } catch (e) {
      if (e instanceof MissingRequiredData) {
        return;
      }
      throw e;
    }
  }
  __name(generateKey, "generateKey");
  var functionWords = /* @__PURE__ */ new Set([
    "a",
    "about",
    "above",
    "across",
    "against",
    "along",
    "among",
    "an",
    "and",
    "around",
    "at",
    "before",
    "behind",
    "below",
    "beneath",
    "beside",
    "between",
    "beyond",
    "but",
    "by",
    "down",
    "during",
    "except",
    "for",
    "for",
    "from",
    "in",
    "inside",
    "into",
    "like",
    "near",
    "nor",
    "of",
    "off",
    "on",
    "onto",
    "or",
    "since",
    "so",
    "the",
    "through",
    "to",
    "toward",
    "under",
    "until",
    "up",
    "upon",
    "with",
    "within",
    "without",
    "yet",
  ]);
  function nonFunctionWords(value) {
    return words(value).filter((word) => !functionWords.has(word.toLocaleLowerCase()));
  }
  __name(nonFunctionWords, "nonFunctionWords");
  function words(value) {
    return value
      .split(
        /(?:(?![0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])[\s\S])+/
      )
      .filter((word) => word.length > 0);
  }
  __name(words, "words");
  function capitalize(words2) {
    return words2.map((word) => word.slice(0, 1).toLocaleUpperCase() + word.slice(1).toLocaleLowerCase());
  }
  __name(capitalize, "capitalize");
  function title(entryValues) {
    var _a2, _b;
    return (_b = (_a2 = entryValues.get("title")) != null ? _a2 : entryValues.get("booktitle")) != null ? _b : "";
  }
  __name(title, "title");
  // src/optionDefinitions.ts
  var DEFAULT_MERGE_CHECK = ["doi", "citation", "abstract"];
  var DEFAULT_ALIGN = 14;
  var DEFAULT_SPACE = 2;
  var DEFAULT_WRAP = 80;
  var DEFAULT_FIELD_SORT = ["title", "shorttitle", "author", "year", "month", "day", "journal", "booktitle", "location", "on", "publisher", "address", "series", "volume", "number", "pages", "doi", "isbn", "issn", "url", "urldate", "copyright", "category", "note", "metadata"];
  var DEFAULT_SORT = ["key"];
  var DEFAULT_KEY_TEMPLATE = "[auth:required:lower][year:required][veryshorttitle:lower][duplicateNumber]";
  var optionDefinitions = [
    {
      key: "help",
      cli: {
        "--help": true,
        "-h": true,
      },
      title: "Help",
      description: ["Show help"],
      type: "boolean",
    },
    {
      key: "omit",
      cli: {
        "--omit": (args) => {
          if (args.length === 0) {
            console.error("Expected a omit list");
            process.exit(1);
          }
          return args;
        },
      },
      toCLI: (val) => (Array.isArray(val) && val.length > 0 ? "--omit=".concat(val.join(",")) : void 0),
      title: "Remove fields",
      description: ["Remove specified fields from bibliography entries."],
      examples: ["--omit=id,name"],
      type: "string[]",
      defaultValue: [],
    },
    {
      key: "curly",
      cli: {
        "--curly": true,
        "--no-curly": false,
      },
      toCLI: (val) => (val ? "--curly" : void 0),
      title: "Enclose values in braces",
      description: ['Enclose all property values in braces. Quoted values will be converted to braces. For example, "Journal of Tea" will become {Journal of Tea}.'],
      type: "boolean",
      defaultValue: false,
    },
    {
      key: "numeric",
      cli: {
        "--numeric": true,
        "--no-numeric": false,
      },
      toCLI: (val) => (val ? "--numeric" : void 0),
      title: "Use numeric values where possible",
      description: ["Strip quotes and braces from numeric/month values. For example, {1998} will become 1998."],
      type: "boolean",
      defaultValue: false,
    },
    {
      key: "space",
      cli: {
        "--space": (args) => (args.length > 0 ? Number(args[0]) : true),
      },
      toCLI: (val, opt) => {
        if (opt.tab) return void 0;
        if (typeof val === "number" && val !== DEFAULT_SPACE) return "--space=".concat(val);
        if (val && val !== DEFAULT_SPACE) return "--space";
        return void 0;
      },
      title: "Indent with spaces",
      description: ["Indent all fields with the specified number of spaces. Ignored if tab is set."],
      examples: ["--space=2 (default)", "--space=4"],
      type: "boolean | number",
      convertBoolean: {
        true: DEFAULT_SPACE,
        false: void 0,
      },
      defaultValue: DEFAULT_SPACE,
    },
    {
      key: "tab",
      cli: {
        "--tab": true,
        "--no-tab": false,
      },
      toCLI: (val) => (val ? "--tab" : void 0),
      title: "Indent with tabs",
      description: ["Indent all fields with a tab."],
      type: "boolean",
      defaultValue: false,
    },
    {
      key: "align",
      cli: {
        "--align": (args) => Number(args[0]),
        "--no-align": false,
      },
      toCLI: (val) => {
        if (val === false || val === 1 || val === 0) return "--no-align";
        if (typeof val === "number" && val !== DEFAULT_ALIGN) return "--align=".concat(val);
        return void 0;
      },
      title: "Align values",
      description: ["Insert whitespace between fields and values so that values are visually aligned."],
      examples: ["--align=14 (default)"],
      type: "boolean | number",
      convertBoolean: {
        true: DEFAULT_ALIGN,
        false: 1,
      },
      defaultValue: DEFAULT_ALIGN,
    },
    {
      key: "blankLines",
      cli: {
        "--blank-lines": true,
        "--no-blank-lines": false,
      },
      toCLI: (val) => (val ? "--blank-lines" : void 0),
      title: "Insert blank lines",
      description: ["Insert an empty line between each entry."],
      type: "boolean",
    },
    {
      key: "sort",
      cli: {
        "--sort": (args) => (args.length > 0 ? args : true),
        "--no-sort": false,
      },
      toCLI: (val) => {
        if (Array.isArray(val) && val.length > 0) return "--sort=".concat(val.join(","));
        if (val === true) return "--sort";
        return void 0;
      },
      title: "Sort bibliography entries",
      description: ["Sort entries by specified fields. For descending order, prefix the field with a dash (-)."],
      examples: ["--sort (sort by id)", "--sort=-year,name (sort year descending then name ascending)", "--sort=name,year"],
      type: "boolean | string[]",
      convertBoolean: {
        true: DEFAULT_SORT,
        false: void 0,
      },
    },
    {
      key: "duplicates",
      cli: {
        "--duplicates": (args) => {
          if (args.length === 0) return true;
          var _iteratorNormalCompletion = true,
            _didIteratorError = false,
            _iteratorError = undefined;
          try {
            for (var _iterator = args[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var i = _step.value;
              if (i !== "doi" && i !== "key" && i !== "abstract" && i !== "citation") {
                console.error('Invalid key for merge option: "'.concat(i, '"'));
                process.exit(1);
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
          return args;
        },
      },
      toCLI: (val) => {
        if (Array.isArray(val) && val.length > 0) return "--duplicates=".concat(val.join(","));
        if (val === true) return "--duplicates";
        return void 0;
      },
      title: "Check for duplicates",
      description: ["Warn if duplicates are found, which are entries where DOI, abstract, or author and title are the same."],
      examples: ["--duplicates doi (same DOIs)", "--duplicates key (same IDs)", "--duplicates abstract (similar abstracts)", "--duplicates citation (similar author and titles)", "--duplicates doi, key (identical DOI or keys)", "--duplicates (same DOI, key, abstract, or citation)"],
      type: "boolean | ('doi' | 'key' | 'abstract' | 'citation')[]",
      convertBoolean: {
        true: DEFAULT_MERGE_CHECK,
        false: void 0,
      },
      defaultValue: (options) => (options.merge ? DEFAULT_MERGE_CHECK : void 0),
    },
    {
      key: "merge",
      cli: {
        "--merge": (args) => {
          if (args.length === 0) return true;
          if (args[0] !== "first" && args[0] !== "last" && args[0] !== "combine" && args[0] !== "overwrite") {
            console.error('Invalid merge strategy: "'.concat(args[0], '"'));
            process.exit(1);
          }
          return args[0];
        },
        "--no-merge": false,
      },
      toCLI: (val) => {
        if (typeof val === "string") return "--merge=".concat(val);
        if (val) return "--merge";
        return void 0;
      },
      title: "Merge duplicate entries",
      description: [
        "Merge duplicates entries. Use the duplicates option to determine how duplicates are identified. There are different ways to merge:",
        "- first: only keep the original entry",
        "- last: only keep the last found duplicate",
        "- combine: keep original entry and merge in fields of duplicates if they do not already exist",
        "- overwrite: keep original entry and merge in fields of duplicates, overwriting existing fields if they exist",
      ],
      type: "boolean | 'first' | 'last' | 'combine' | 'overwrite'",
      convertBoolean: {
        true: "combine",
        false: void 0,
      },
    },
    {
      key: "stripEnclosingBraces",
      cli: {
        "--strip-enclosing-braces": true,
      },
      toCLI: (val) => (val ? "--strip-enclosing-braces" : void 0),
      title: "Strip double-braced values",
      description: ["Where an entire value is enclosed in double braces, remove the extra braces. For example, {{Journal of Tea}} will become {Journal of Tea}."],
      type: "boolean",
      defaultValue: false,
    },
    {
      key: "dropAllCaps",
      cli: {
        "--drop-all-caps": true,
      },
      toCLI: (val) => (val ? "--drop-all-caps" : void 0),
      title: "Drop all caps",
      description: ["Where values are all caps, make them title case. For example, {JOURNAL OF TEA} will become {Journal of Tea}. Roman numerals will be left unchanged."],
      type: "boolean",
      defaultValue: false,
    },
    {
      key: "escape",
      cli: {
        "--escape": true,
        "--no-escape": false,
      },
      toCLI: (val) => (val === false ? "--no-escape" : void 0),
      title: "Escape special characters",
      description: ["Escape special characters, such as umlaut. This ensures correct typesetting with latex. Enabled by default."],
      type: "boolean",
      defaultValue: true,
    },
    {
      key: "sortFields",
      cli: {
        "--sort-fields": (args) => (args.length > 0 ? args : true),
      },
      toCLI: (val) => {
        if (Array.isArray(val) && val.length > 0) {
          if (JSON.stringify(val) === JSON.stringify(DEFAULT_FIELD_SORT)) {
            return "--sort_fields";
          }
          return "--sort-fields=".concat(val.join(","));
        }
        if (val === true) return "--sort-fields";
        return void 0;
      },
      title: "Sort fields",
      description: ["Sort the fields within entries.", "If no fields are specified fields will be sorted by: title, shorttitle, author, year, month, day, journal, booktitle, location, on, publisher, address, series, volume, number, pages, doi, isbn, issn, url, urldate, copyright, category, note, metadata"],
      examples: ["--sort-fields=name,author"],
      type: "boolean | string[]",
      convertBoolean: {
        true: DEFAULT_FIELD_SORT,
        false: void 0,
      },
      defaultValue: void 0,
    },
    {
      key: "sortProperties",
      cli: {
        "--sort-properties": (args) => (args.length > 0 ? args : true),
      },
      title: "Sort properties",
      description: ["Alias of sort fields (legacy)"],
      type: "boolean | string[]",
      deprecated: true,
    },
    {
      key: "stripComments",
      cli: {
        "--strip-comments": true,
        "--no-strip-comments": false,
      },
      toCLI: (val) => (val ? "--strip-comments" : void 0),
      title: "Remove comments",
      description: ["Remove all comments from the bibtex source."],
      type: "boolean",
      defaultValue: false,
    },
    {
      key: "trailingCommas",
      cli: {
        "--trailing-commas": true,
        "--no-trailing-commas": true,
      },
      toCLI: (val) => (val ? "--trailing-commas" : void 0),
      title: "Trailing commas",
      description: ["End the last key value pair in each entry with a comma."],
      type: "boolean",
      defaultValue: false,
    },
    {
      key: "encodeUrls",
      cli: {
        "--encode-urls": true,
        "--no-encode-urls": true,
      },
      toCLI: (val) => (val ? "--encode-urls" : void 0),
      title: "Encode URLs",
      description: ["Replace invalid URL characters with percent encoded values."],
      type: "boolean",
      defaultValue: false,
    },
    {
      key: "tidyComments",
      cli: {
        "--tidy-comments": true,
        "--no-tidy-comments": false,
      },
      toCLI: (val) => (val === false ? "--no-tidy-comments" : void 0),
      title: "Tidy comments",
      description: ["Remove whitespace surrounding comments."],
      type: "boolean",
      defaultValue: true,
    },
    {
      key: "removeEmptyFields",
      cli: {
        "--remove-empty-fields": true,
        "--no-remove-empty-fields": false,
      },
      toCLI: (val) => (val ? "--remove-empty-fields" : void 0),
      title: "Remove empty fields",
      description: ["Remove any fields that have empty values."],
      type: "boolean",
      defaultValue: false,
    },
    {
      key: "removeDuplicateFields",
      cli: {
        "--remove-dupe-fields": true,
        "--no-remove-dupe-fields": false,
      },
      toCLI: (val) => (val === false ? "--no-remove-dupe-fields" : void 0),
      title: "Remove duplicate fields",
      description: ["Only allow one of each field in each entry. Enabled by default."],
      type: "boolean",
      defaultValue: true,
    },
    {
      key: "generateKeys",
      cli: {
        "--generate-keys": (args) => (args.length > 0 ? args : true),
      },
      toCLI: (val) => {
        if (val === true || val === DEFAULT_KEY_TEMPLATE) return "--generate-keys";
        if (typeof val === "string") return '--generate-keys="'.concat(val.replace(/"/g, '\\"'), '"');
        return void 0;
      },
      title: "Generate citation keys [Experimental]",
      description: ["For all entries replace the key with a new key of the form <author><year><title>. A JabRef citation pattern can be provided. This is an experimental option that may change without warning."],
      type: "boolean | string",
      convertBoolean: {
        true: DEFAULT_KEY_TEMPLATE,
        false: void 0,
      },
      defaultValue: void 0,
    },
    {
      key: "maxAuthors",
      cli: {
        "--max-authors": (args) => Number(args[0]),
      },
      toCLI: (val) => (val ? "--max-authors=".concat(val) : void 0),
      title: "Maximum authors",
      description: ['Truncate authors if above a given number into "and others".'],
      type: "number",
    },
    {
      key: "lowercase",
      cli: {
        "--no-lowercase": false,
      },
      toCLI: (val) => (val === false ? "--no-lowercase" : void 0),
      title: "Lowercase fields",
      description: ["Lowercase field names and entry type. Enabled by default."],
      type: "boolean",
      defaultValue: true,
    },
    {
      key: "enclosingBraces",
      cli: {
        "--enclosing-braces": (args) => (args.length > 0 ? args : true),
      },
      toCLI: (val) => {
        if (Array.isArray(val) && val.length > 0) return "--enclosing-braces=".concat(val.join(","));
        if (val === true) return "--enclosing-braces";
        return void 0;
      },
      title: "Enclose values in double braces",
      description: ["Enclose the given fields in double braces, such that case is preserved during BibTeX compilation."],
      examples: ["--enclosing-braces=title,journal (output title and journal fields will be of the form {{This is a title}})", "--enclosing-braces (equivalent to ---enclosing-braces=title)"],
      type: "boolean | string[]",
      convertBoolean: {
        true: ["title"],
        false: void 0,
      },
    },
    {
      key: "removeBraces",
      cli: {
        "--remove-braces": (args) => (args.length > 0 ? args : true),
      },
      toCLI: (val) => {
        if (Array.isArray(val) && val.length > 0) return "--remove-braces=".concat(val.join(","));
        if (val === true) return "--remove-braces";
        return void 0;
      },
      title: "Remove braces",
      description: ["Remove any curly braces within the value, unless they are part of a command."],
      examples: ["--remove-braces=title,journal", "--remove-braces (equivalent to ---remove-braces=title)"],
      type: "boolean | string[]",
      convertBoolean: {
        true: ["title"],
        false: void 0,
      },
    },
    {
      key: "wrap",
      cli: {
        "--wrap": (args) => (args.length > 0 ? Number(args[0]) : true),
        "--no-wrap": false,
      },
      toCLI: (val) => (val ? "--wrap=".concat(val) : void 0),
      title: "Wrap values",
      description: ["Wrap long values at the given column"],
      examples: ["--wrap (80 by default)", "--wrap=82"],
      type: "boolean | number",
      convertBoolean: {
        true: DEFAULT_WRAP,
        false: void 0,
      },
    },
    {
      key: "version",
      cli: {
        "--version": true,
        "-v": true,
      },
      title: "Version",
      description: ["Show bibtex-tidy version."],
      type: "boolean",
    },
    {
      key: "quiet",
      cli: {
        "--quiet": true,
      },
      title: "Quiet",
      description: ["Suppress logs and warnings."],
      type: "boolean",
    },
    {
      key: "backup",
      cli: {
        "--backup": true,
        "--no-backup": false,
      },
      title: "Backup",
      description: ["Make a backup <filename>.original. Enabled by default."],
      type: "boolean",
      defaultValue: true,
    },
  ];
  var optionDefinitionByKey = Object.fromEntries(optionDefinitions.map((opt) => [opt.key, opt]));
  // src/optionUtils.ts
  function normalizeOptions(options) {
    return Object.fromEntries(
      optionDefinitions.map((def) => {
        var key = def.key;
        var value = options[key];
        if (def.convertBoolean && typeof value === "boolean") {
          return [key, value ? def.convertBoolean.true : def.convertBoolean.false];
        }
        if (typeof value === "undefined" && def.defaultValue !== void 0) {
          if (typeof def.defaultValue === "function") {
            return [key, def.defaultValue(options)];
          }
          return [key, def.defaultValue];
        }
        return [key, value];
      })
    );
  }
  __name(normalizeOptions, "normalizeOptions");
  // src/index.ts
  function tidy(input) {
    var options_ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var options = normalizeOptions(options_);
    input = convertCRLF(input);
    var ast = generateAST(input);
    var warnings = getEntries(ast)
      .filter((entry) => !entry.key)
      .map((entry) => ({
        code: "MISSING_KEY",
        message: "".concat(entry.parent.command, " entry does not have a citation key."),
      }));
    var valueLookup = generateValueLookup(ast, options);
    var duplicates = checkForDuplicates(ast, valueLookup, options.duplicates, options.merge);
    warnings.push(...duplicates.warnings);
    ast.children = ast.children.filter((child) => !isEntryNode(child) || !duplicates.entries.has(child.block));
    if (options.sort) sortEntries(ast, valueLookup, options.sort);
    if (options.sortFields) sortEntryFields(ast, options.sortFields);
    var newKeys = options.generateKeys ? generateKeys(ast, valueLookup, options.generateKeys) : void 0;
    var bibtex = formatBibtex(ast, options, newKeys);
    return {
      bibtex,
      warnings,
      count: getEntries(ast).length,
    };
  }
  __name(tidy, "tidy");
  function getEntries(ast) {
    return ast.children.filter(isEntryNode).map((node) => node.block);
  }
  __name(getEntries, "getEntries");
  function generateValueLookup(ast, options) {
    return new Map(
      getEntries(ast).map((entry) => [
        entry,
        new Map(
          entry.fields.map((field) => {
            var _a2;
            return [field.name.toLocaleLowerCase(), (_a2 = formatValue(field, options)) != null ? _a2 : ""];
          })
        ),
      ])
    );
  }
  __name(generateValueLookup, "generateValueLookup");
  // node_modules/@codemirror/state/dist/index.js
  var Text = class Text1 {
    lineAt(pos) {
      if (pos < 0 || pos > this.length) throw new RangeError("Invalid position ".concat(pos, " in document of length ").concat(this.length));
      return this.lineInner(pos, false, 1, 0);
    }
    line(n) {
      if (n < 1 || n > this.lines) throw new RangeError("Invalid line number ".concat(n, " in ").concat(this.lines, "-line document"));
      return this.lineInner(n, true, 1, 0);
    }
    replace(from, to, text2) {
      var parts = [];
      this.decompose(0, from, parts, 2);
      if (text2.length) text2.decompose(0, text2.length, parts, 1 | 2);
      this.decompose(to, this.length, parts, 1);
      return TextNode3.from(parts, this.length - (to - from) + text2.length);
    }
    append(other) {
      return this.replace(this.length, this.length, other);
    }
    slice(from) {
      var to = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.length;
      var parts = [];
      this.decompose(from, to, parts, 0);
      return TextNode3.from(parts, to - from);
    }
    eq(other) {
      if (other == this) return true;
      if (other.length != this.length || other.lines != this.lines) return false;
      var start = this.scanIdentical(other, 1),
        end = this.length - this.scanIdentical(other, -1);
      var a = new RawTextCursor(this),
        b = new RawTextCursor(other);
      for (var skip = start, pos = start; ; ) {
        a.next(skip);
        b.next(skip);
        skip = 0;
        if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value) return false;
        pos += a.value.length;
        if (a.done || pos >= end) return true;
      }
    }
    iter() {
      var dir = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
      return new RawTextCursor(this, dir);
    }
    iterRange(from) {
      var to = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.length;
      return new PartialTextCursor(this, from, to);
    }
    iterLines(from, to) {
      var inner;
      if (from == null) {
        inner = this.iter();
      } else {
        if (to == null) to = this.lines + 1;
        var start = this.line(from).from;
        inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
      }
      return new LineCursor(inner);
    }
    toString() {
      return this.sliceString(0);
    }
    toJSON() {
      var lines = [];
      this.flatten(lines);
      return lines;
    }
    static of(text2) {
      if (text2.length == 0) throw new RangeError("A document must have at least one line");
      if (text2.length == 1 && !text2[0]) return Text.empty;
      return text2.length <= 32 ? new TextLeaf(text2) : TextNode3.from(TextLeaf.split(text2, []));
    }
    constructor() {}
  };
  __name(Text, "Text");
  var TextLeaf = class TextLeaf1 extends Text {
    get lines() {
      return this.text.length;
    }
    get children() {
      return null;
    }
    lineInner(target, isLine, line, offset) {
      for (var i = 0; ; i++) {
        var string2 = this.text[i],
          end = offset + string2.length;
        if ((isLine ? line : end) >= target) return new Line(offset, end, line, string2);
        offset = end + 1;
        line++;
      }
    }
    decompose(from, to, target, open) {
      var text2 = from <= 0 && to >= this.length ? this : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));
      if (open & 1) {
        var prev = target.pop();
        var joined = appendText(text2.text, prev.text.slice(), 0, text2.length);
        if (joined.length <= 32) {
          target.push(new TextLeaf(joined, prev.length + text2.length));
        } else {
          var mid = joined.length >> 1;
          target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
        }
      } else {
        target.push(text2);
      }
    }
    replace(from, to, text2) {
      if (!(text2 instanceof TextLeaf)) return super.replace(from, to, text2);
      var lines = appendText(this.text, appendText(text2.text, sliceText(this.text, 0, from)), to);
      var newLen = this.length + text2.length - (to - from);
      if (lines.length <= 32) return new TextLeaf(lines, newLen);
      return TextNode3.from(TextLeaf.split(lines, []), newLen);
    }
    sliceString(from) {
      var to = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.length,
        lineSep = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "\n";
      var result = "";
      for (var pos = 0, i = 0; pos <= to && i < this.text.length; i++) {
        var line = this.text[i],
          end = pos + line.length;
        if (pos > from && i) result += lineSep;
        if (from < end && to > pos) result += line.slice(Math.max(0, from - pos), to - pos);
        pos = end + 1;
      }
      return result;
    }
    flatten(target) {
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.text[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var line = _step.value;
          target.push(line);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    scanIdentical() {
      return 0;
    }
    static split(text2, target) {
      var part = [],
        len = -1;
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = text2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var line = _step.value;
          part.push(line);
          len += line.length + 1;
          if (part.length == 32) {
            target.push(new TextLeaf(part, len));
            part = [];
            len = -1;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      if (len > -1) target.push(new TextLeaf(part, len));
      return target;
    }
    constructor(text2, ref) {
      var length = ref === void 0 ? textLength(text2) : ref;
      super();
      this.text = text2;
      this.length = length;
    }
  };
  __name(TextLeaf, "TextLeaf");
  var TextNode3 = class TextNode31 extends Text {
    lineInner(target, isLine, line, offset) {
      for (var i = 0; ; i++) {
        var child = this.children[i],
          end = offset + child.length,
          endLine = line + child.lines - 1;
        if ((isLine ? endLine : end) >= target) return child.lineInner(target, isLine, line, offset);
        offset = end + 1;
        line = endLine + 1;
      }
    }
    decompose(from, to, target, open) {
      for (var i = 0, pos = 0; pos <= to && i < this.children.length; i++) {
        var child = this.children[i],
          end = pos + child.length;
        if (from <= end && to >= pos) {
          var childOpen = open & ((pos <= from ? 1 : 0) | (end >= to ? 2 : 0));
          if (pos >= from && end <= to && !childOpen) target.push(child);
          else child.decompose(from - pos, to - pos, target, childOpen);
        }
        pos = end + 1;
      }
    }
    replace(from, to, text2) {
      if (text2.lines < this.lines)
        for (var i = 0, pos = 0; i < this.children.length; i++) {
          var child = this.children[i],
            end = pos + child.length;
          if (from >= pos && to <= end) {
            var updated = child.replace(from - pos, to - pos, text2);
            var totalLines = this.lines - child.lines + updated.lines;
            if (updated.lines < totalLines >> (5 - 1) && updated.lines > totalLines >> (5 + 1)) {
              var copy = this.children.slice();
              copy[i] = updated;
              return new TextNode3(copy, this.length - (to - from) + text2.length);
            }
            return super.replace(pos, end, updated);
          }
          pos = end + 1;
        }
      return super.replace(from, to, text2);
    }
    sliceString(from) {
      var to = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.length,
        lineSep = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "\n";
      var result = "";
      for (var i = 0, pos = 0; i < this.children.length && pos <= to; i++) {
        var child = this.children[i],
          end = pos + child.length;
        if (pos > from && i) result += lineSep;
        if (from < end && to > pos) result += child.sliceString(from - pos, to - pos, lineSep);
        pos = end + 1;
      }
      return result;
    }
    flatten(target) {
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var child = _step.value;
          child.flatten(target);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    scanIdentical(other, dir) {
      if (!(other instanceof TextNode3)) return 0;
      var length = 0;
      var _ref = _slicedToArray(dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1], 4),
        iA = _ref[0],
        iB = _ref[1],
        eA = _ref[2],
        eB = _ref[3];
      for (; ; iA += dir, iB += dir) {
        if (iA == eA || iB == eB) return length;
        var chA = this.children[iA],
          chB = other.children[iB];
        if (chA != chB) return length + chA.scanIdentical(chB, dir);
        length += chA.length + 1;
      }
    }
    static from(children2) {
      var length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : children2.reduce((l, ch) => l + ch.length + 1, -1);
      var lines = 0;
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = children2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var ch = _step.value;
          lines += ch.lines;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      if (lines < 32) {
        var flat = [];
        var _iteratorNormalCompletion1 = true,
          _didIteratorError1 = false,
          _iteratorError1 = undefined;
        try {
          for (var _iterator1 = children2[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
            var ch1 = _step1.value;
            ch1.flatten(flat);
          }
        } catch (err) {
          _didIteratorError1 = true;
          _iteratorError1 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
              _iterator1.return();
            }
          } finally {
            if (_didIteratorError1) {
              throw _iteratorError1;
            }
          }
        }
        return new TextLeaf(flat, length);
      }
      var chunk = Math.max(32, lines >> 5),
        maxChunk = chunk << 1,
        minChunk = chunk >> 1;
      var chunked = [],
        currentLines = 0,
        currentLen = -1,
        currentChunk = [];
      function add2(child) {
        var last;
        if (child.lines > maxChunk && child instanceof TextNode3) {
          var _iteratorNormalCompletion = true,
            _didIteratorError = false,
            _iteratorError = undefined;
          try {
            for (var _iterator = child.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var node = _step.value;
              add2(node);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
          flush2();
          chunked.push(child);
        } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32) {
          currentLines += child.lines;
          currentLen += child.length + 1;
          currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
        } else {
          if (currentLines + child.lines > chunk) flush2();
          currentLines += child.lines;
          currentLen += child.length + 1;
          currentChunk.push(child);
        }
      }
      __name(add2, "add");
      function flush2() {
        if (currentLines == 0) return;
        chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode3.from(currentChunk, currentLen));
        currentLen = -1;
        currentLines = currentChunk.length = 0;
      }
      __name(flush2, "flush");
      var _iteratorNormalCompletion2 = true,
        _didIteratorError2 = false,
        _iteratorError2 = undefined;
      try {
        for (var _iterator2 = children2[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var child = _step2.value;
          add2(child);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
      flush2();
      return chunked.length == 1 ? chunked[0] : new TextNode3(chunked, length);
    }
    constructor(children2, length) {
      super();
      this.children = children2;
      this.length = length;
      this.lines = 0;
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = children2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var child = _step.value;
          this.lines += child.lines;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  };
  __name(TextNode3, "TextNode");
  Text.empty = /* @__PURE__ */ new TextLeaf([""], 0);
  function textLength(text2) {
    var length = -1;
    var _iteratorNormalCompletion = true,
      _didIteratorError = false,
      _iteratorError = undefined;
    try {
      for (var _iterator = text2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var line = _step.value;
        length += line.length + 1;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    return length;
  }
  __name(textLength, "textLength");
  function appendText(text2, target) {
    var from = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,
      to = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1e9;
    for (var pos = 0, i = 0, first = true; i < text2.length && pos <= to; i++) {
      var line = text2[i],
        end = pos + line.length;
      if (end >= from) {
        if (end > to) line = line.slice(0, to - pos);
        if (pos < from) line = line.slice(from - pos);
        if (first) {
          target[target.length - 1] += line;
          first = false;
        } else target.push(line);
      }
      pos = end + 1;
    }
    return target;
  }
  __name(appendText, "appendText");
  function sliceText(text2, from, to) {
    return appendText(text2, [""], from, to);
  }
  __name(sliceText, "sliceText");
  var RawTextCursor = class RawTextCursor {
    nextInner(skip, dir) {
      this.done = this.lineBreak = false;
      for (;;) {
        var last = this.nodes.length - 1;
        var top2 = this.nodes[last],
          offsetValue = this.offsets[last],
          offset = offsetValue >> 1;
        var size = top2 instanceof TextLeaf ? top2.text.length : top2.children.length;
        if (offset == (dir > 0 ? size : 0)) {
          if (last == 0) {
            this.done = true;
            this.value = "";
            return this;
          }
          if (dir > 0) this.offsets[last - 1]++;
          this.nodes.pop();
          this.offsets.pop();
        } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
          this.offsets[last] += dir;
          if (skip == 0) {
            this.lineBreak = true;
            this.value = "\n";
            return this;
          }
          skip--;
        } else if (top2 instanceof TextLeaf) {
          var next = top2.text[offset + (dir < 0 ? -1 : 0)];
          this.offsets[last] += dir;
          if (next.length > Math.max(0, skip)) {
            this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
            return this;
          }
          skip -= next.length;
        } else {
          var next1 = top2.children[offset + (dir < 0 ? -1 : 0)];
          if (skip > next1.length) {
            skip -= next1.length;
            this.offsets[last] += dir;
          } else {
            if (dir < 0) this.offsets[last]--;
            this.nodes.push(next1);
            this.offsets.push(dir > 0 ? 1 : (next1 instanceof TextLeaf ? next1.text.length : next1.children.length) << 1);
          }
        }
      }
    }
    next() {
      var skip = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      if (skip < 0) {
        this.nextInner(-skip, -this.dir);
        skip = this.value.length;
      }
      return this.nextInner(skip, this.dir);
    }
    constructor(text2, ref) {
      var dir = ref === void 0 ? 1 : ref;
      this.dir = dir;
      this.done = false;
      this.lineBreak = false;
      this.value = "";
      this.nodes = [text2];
      this.offsets = [dir > 0 ? 1 : (text2 instanceof TextLeaf ? text2.text.length : text2.children.length) << 1];
    }
  };
  __name(RawTextCursor, "RawTextCursor");
  var PartialTextCursor = class PartialTextCursor {
    nextInner(skip, dir) {
      if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
        this.value = "";
        this.done = true;
        return this;
      }
      skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
      var limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
      if (skip > limit) skip = limit;
      limit -= skip;
      var value = this.cursor.next(skip).value;
      this.pos += (value.length + skip) * dir;
      this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
      this.done = !this.value;
      return this;
    }
    next() {
      var skip = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      if (skip < 0) skip = Math.max(skip, this.from - this.pos);
      else if (skip > 0) skip = Math.min(skip, this.to - this.pos);
      return this.nextInner(skip, this.cursor.dir);
    }
    get lineBreak() {
      return this.cursor.lineBreak && this.value != "";
    }
    constructor(text2, start, end) {
      this.value = "";
      this.done = false;
      this.cursor = new RawTextCursor(text2, start > end ? -1 : 1);
      this.pos = start > end ? text2.length : 0;
      this.from = Math.min(start, end);
      this.to = Math.max(start, end);
    }
  };
  __name(PartialTextCursor, "PartialTextCursor");
  var LineCursor = class LineCursor {
    next() {
      var skip = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var _this_inner_next = this.inner.next(skip),
        done = _this_inner_next.done,
        lineBreak = _this_inner_next.lineBreak,
        value = _this_inner_next.value;
      if (done) {
        this.done = true;
        this.value = "";
      } else if (lineBreak) {
        if (this.afterBreak) {
          this.value = "";
        } else {
          this.afterBreak = true;
          this.next();
        }
      } else {
        this.value = value;
        this.afterBreak = false;
      }
      return this;
    }
    get lineBreak() {
      return false;
    }
    constructor(inner) {
      this.inner = inner;
      this.afterBreak = true;
      this.value = "";
      this.done = false;
    }
  };
  __name(LineCursor, "LineCursor");
  if (typeof Symbol != "undefined") {
    Text.prototype[Symbol.iterator] = function () {
      return this.iter();
    };
    RawTextCursor.prototype[Symbol.iterator] =
      PartialTextCursor.prototype[Symbol.iterator] =
      LineCursor.prototype[Symbol.iterator] =
        function () {
          return this;
        };
  }
  var Line = class Line {
    get length() {
      return this.to - this.from;
    }
    constructor(from, to, number2, text2) {
      this.from = from;
      this.to = to;
      this.number = number2;
      this.text = text2;
    }
  };
  __name(Line, "Line");
  var extend =
    /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o"
      .split(",")
      .map((s) => (s ? parseInt(s, 36) : 1));
  for (var i = 1; i < extend.length; i++) extend[i] += extend[i - 1];
  function isExtendingChar(code) {
    for (var i = 1; i < extend.length; i += 2) if (extend[i] > code) return extend[i - 1] <= code;
    return false;
  }
  __name(isExtendingChar, "isExtendingChar");
  function isRegionalIndicator(code) {
    return code >= 127462 && code <= 127487;
  }
  __name(isRegionalIndicator, "isRegionalIndicator");
  var ZWJ = 8205;
  function findClusterBreak(str, pos) {
    var forward = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true,
      includeExtending = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
    return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
  }
  __name(findClusterBreak, "findClusterBreak");
  function nextClusterBreak(str, pos, includeExtending) {
    if (pos == str.length) return pos;
    if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1))) pos--;
    var prev = codePointAt(str, pos);
    pos += codePointSize(prev);
    while (pos < str.length) {
      var next = codePointAt(str, pos);
      if (prev == ZWJ || next == ZWJ || (includeExtending && isExtendingChar(next))) {
        pos += codePointSize(next);
        prev = next;
      } else if (isRegionalIndicator(next)) {
        var countBefore = 0,
          i = pos - 2;
        while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {
          countBefore++;
          i -= 2;
        }
        if (countBefore % 2 == 0) break;
        else pos += 2;
      } else {
        break;
      }
    }
    return pos;
  }
  __name(nextClusterBreak, "nextClusterBreak");
  function prevClusterBreak(str, pos, includeExtending) {
    while (pos > 0) {
      var found = nextClusterBreak(str, pos - 2, includeExtending);
      if (found < pos) return found;
      pos--;
    }
    return 0;
  }
  __name(prevClusterBreak, "prevClusterBreak");
  function surrogateLow(ch) {
    return ch >= 56320 && ch < 57344;
  }
  __name(surrogateLow, "surrogateLow");
  function surrogateHigh(ch) {
    return ch >= 55296 && ch < 56320;
  }
  __name(surrogateHigh, "surrogateHigh");
  function codePointAt(str, pos) {
    var code0 = str.charCodeAt(pos);
    if (!surrogateHigh(code0) || pos + 1 == str.length) return code0;
    var code1 = str.charCodeAt(pos + 1);
    if (!surrogateLow(code1)) return code0;
    return ((code0 - 55296) << 10) + (code1 - 56320) + 65536;
  }
  __name(codePointAt, "codePointAt");
  function codePointSize(code) {
    return code < 65536 ? 1 : 2;
  }
  __name(codePointSize, "codePointSize");
  var DefaultSplit = /\r\n?|\n/;
  var MapMode = /* @__PURE__ */ (function (MapMode2) {
    MapMode2[(MapMode2["Simple"] = 0)] = "Simple";
    MapMode2[(MapMode2["TrackDel"] = 1)] = "TrackDel";
    MapMode2[(MapMode2["TrackBefore"] = 2)] = "TrackBefore";
    MapMode2[(MapMode2["TrackAfter"] = 3)] = "TrackAfter";
    return MapMode2;
  })(MapMode || (MapMode = {}));
  var ChangeDesc = class ChangeDesc1 {
    get length() {
      var result = 0;
      for (var i = 0; i < this.sections.length; i += 2) result += this.sections[i];
      return result;
    }
    get newLength() {
      var result = 0;
      for (var i = 0; i < this.sections.length; i += 2) {
        var ins = this.sections[i + 1];
        result += ins < 0 ? this.sections[i] : ins;
      }
      return result;
    }
    get empty() {
      return this.sections.length == 0 || (this.sections.length == 2 && this.sections[1] < 0);
    }
    iterGaps(f) {
      for (var i = 0, posA = 0, posB = 0; i < this.sections.length; ) {
        var len = this.sections[i++],
          ins = this.sections[i++];
        if (ins < 0) {
          f(posA, posB, len);
          posB += len;
        } else {
          posB += ins;
        }
        posA += len;
      }
    }
    iterChangedRanges(f) {
      var individual = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      iterChanges(this, f, individual);
    }
    get invertedDesc() {
      var sections = [];
      for (var i = 0; i < this.sections.length; ) {
        var len = this.sections[i++],
          ins = this.sections[i++];
        if (ins < 0) sections.push(len, ins);
        else sections.push(ins, len);
      }
      return new ChangeDesc(sections);
    }
    composeDesc(other) {
      return this.empty ? other : other.empty ? this : composeSets(this, other);
    }
    mapDesc(other) {
      var before = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return other.empty ? this : mapSet(this, other, before);
    }
    mapPos(pos) {
      var assoc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1,
        mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : MapMode.Simple;
      var posA = 0,
        posB = 0;
      for (var i = 0; i < this.sections.length; ) {
        var len = this.sections[i++],
          ins = this.sections[i++],
          endA = posA + len;
        if (ins < 0) {
          if (endA > pos) return posB + (pos - posA);
          posB += len;
        } else {
          if (mode != MapMode.Simple && endA >= pos && ((mode == MapMode.TrackDel && posA < pos && endA > pos) || (mode == MapMode.TrackBefore && posA < pos) || (mode == MapMode.TrackAfter && endA > pos))) return null;
          if (endA > pos || (endA == pos && assoc < 0 && !len)) return pos == posA || assoc < 0 ? posB : posB + ins;
          posB += ins;
        }
        posA = endA;
      }
      if (pos > posA) throw new RangeError("Position ".concat(pos, " is out of range for changeset of length ").concat(posA));
      return posB;
    }
    touchesRange(from) {
      var to = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : from;
      for (var i = 0, pos = 0; i < this.sections.length && pos <= to; ) {
        var len = this.sections[i++],
          ins = this.sections[i++],
          end = pos + len;
        if (ins >= 0 && pos <= to && end >= from) return pos < from && end > to ? "cover" : true;
        pos = end;
      }
      return false;
    }
    toString() {
      var result = "";
      for (var i = 0; i < this.sections.length; ) {
        var len = this.sections[i++],
          ins = this.sections[i++];
        result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
      }
      return result;
    }
    toJSON() {
      return this.sections;
    }
    static fromJSON(json) {
      if (!Array.isArray(json) || json.length % 2 || json.some((a) => typeof a != "number")) throw new RangeError("Invalid JSON representation of ChangeDesc");
      return new ChangeDesc(json);
    }
    static create(sections) {
      return new ChangeDesc(sections);
    }
    constructor(sections) {
      this.sections = sections;
    }
  };
  __name(ChangeDesc, "ChangeDesc");
  var ChangeSet = class ChangeSet1 extends ChangeDesc {
    apply(doc2) {
      if (this.length != doc2.length) throw new RangeError("Applying change set to a document with the wrong length");
      iterChanges(this, (fromA, toA, fromB, _toB, text2) => (doc2 = doc2.replace(fromB, fromB + (toA - fromA), text2)), false);
      return doc2;
    }
    mapDesc(other) {
      var before = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return mapSet(this, other, before, true);
    }
    invert(doc2) {
      var sections = this.sections.slice(),
        inserted = [];
      for (var i = 0, pos = 0; i < sections.length; i += 2) {
        var len = sections[i],
          ins = sections[i + 1];
        if (ins >= 0) {
          sections[i] = ins;
          sections[i + 1] = len;
          var index = i >> 1;
          while (inserted.length < index) inserted.push(Text.empty);
          inserted.push(len ? doc2.slice(pos, pos + len) : Text.empty);
        }
        pos += len;
      }
      return new ChangeSet(sections, inserted);
    }
    compose(other) {
      return this.empty ? other : other.empty ? this : composeSets(this, other, true);
    }
    map(other) {
      var before = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return other.empty ? this : mapSet(this, other, before, true);
    }
    iterChanges(f) {
      var individual = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      iterChanges(this, f, individual);
    }
    get desc() {
      return ChangeDesc.create(this.sections);
    }
    filter(ranges) {
      var resultSections = [],
        resultInserted = [],
        filteredSections = [];
      var iter = new SectionIter(this);
      done: for (var i = 0, pos = 0; ; ) {
        var next = i == ranges.length ? 1e9 : ranges[i++];
        while (pos < next || (pos == next && iter.len == 0)) {
          if (iter.done) break done;
          var len = Math.min(iter.len, next - pos);
          addSection(filteredSections, len, -1);
          var ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
          addSection(resultSections, len, ins);
          if (ins > 0) addInsert(resultInserted, resultSections, iter.text);
          iter.forward(len);
          pos += len;
        }
        var end = ranges[i++];
        while (pos < end) {
          if (iter.done) break done;
          var len1 = Math.min(iter.len, end - pos);
          addSection(resultSections, len1, -1);
          addSection(filteredSections, len1, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
          iter.forward(len1);
          pos += len1;
        }
      }
      return {
        changes: new ChangeSet(resultSections, resultInserted),
        filtered: ChangeDesc.create(filteredSections),
      };
    }
    toJSON() {
      var parts = [];
      for (var i = 0; i < this.sections.length; i += 2) {
        var len = this.sections[i],
          ins = this.sections[i + 1];
        if (ins < 0) parts.push(len);
        else if (ins == 0) parts.push([len]);
        else parts.push([len].concat(this.inserted[i >> 1].toJSON()));
      }
      return parts;
    }
    static of(changes, length, lineSep) {
      var sections = [],
        inserted = [],
        pos = 0;
      var total = null;
      function flush2() {
        var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        if (!force && !sections.length) return;
        if (pos < length) addSection(sections, length - pos, -1);
        var set = new ChangeSet(sections, inserted);
        total = total ? total.compose(set.map(total)) : set;
        sections = [];
        inserted = [];
        pos = 0;
      }
      __name(flush2, "flush");
      function process2(spec) {
        if (Array.isArray(spec)) {
          var _iteratorNormalCompletion = true,
            _didIteratorError = false,
            _iteratorError = undefined;
          try {
            for (var _iterator = spec[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var sub = _step.value;
              process2(sub);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        } else if (spec instanceof ChangeSet) {
          if (spec.length != length) throw new RangeError("Mismatched change set length (got ".concat(spec.length, ", expected ").concat(length, ")"));
          flush2();
          total = total ? total.compose(spec.map(total)) : spec;
        } else {
          var from = spec.from,
            _spec_to = spec.to,
            to = _spec_to === void 0 ? from : _spec_to,
            insert3 = spec.insert;
          if (from > to || from < 0 || to > length) throw new RangeError("Invalid change range ".concat(from, " to ").concat(to, " (in doc of length ").concat(length, ")"));
          var insText = !insert3 ? Text.empty : typeof insert3 == "string" ? Text.of(insert3.split(lineSep || DefaultSplit)) : insert3;
          var insLen = insText.length;
          if (from == to && insLen == 0) return;
          if (from < pos) flush2();
          if (from > pos) addSection(sections, from - pos, -1);
          addSection(sections, to - from, insLen);
          addInsert(inserted, sections, insText);
          pos = to;
        }
      }
      __name(process2, "process");
      process2(changes);
      flush2(!total);
      return total;
    }
    static empty(length) {
      return new ChangeSet(length ? [length, -1] : [], []);
    }
    static fromJSON(json) {
      var _loop = function (i) {
        var part = json[i];
        if (typeof part == "number") {
          sections.push(part, -1);
        } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i2) => i2 && typeof e != "string")) {
          throw new RangeError("Invalid JSON representation of ChangeSet");
        } else if (part.length == 1) {
          sections.push(part[0], 0);
        } else {
          while (inserted.length < i) inserted.push(Text.empty);
          inserted[i] = Text.of(part.slice(1));
          sections.push(part[0], inserted[i].length);
        }
      };
      if (!Array.isArray(json)) throw new RangeError("Invalid JSON representation of ChangeSet");
      var sections = [],
        inserted = [];
      for (var i = 0; i < json.length; i++) _loop(i);
      return new ChangeSet(sections, inserted);
    }
    static createSet(sections, inserted) {
      return new ChangeSet(sections, inserted);
    }
    constructor(sections, inserted) {
      super(sections);
      this.inserted = inserted;
    }
  };
  __name(ChangeSet, "ChangeSet");
  function addSection(sections, len, ins) {
    var forceJoin = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    if (len == 0 && ins <= 0) return;
    var last = sections.length - 2;
    if (last >= 0 && ins <= 0 && ins == sections[last + 1]) sections[last] += len;
    else if (len == 0 && sections[last] == 0) sections[last + 1] += ins;
    else if (forceJoin) {
      sections[last] += len;
      sections[last + 1] += ins;
    } else sections.push(len, ins);
  }
  __name(addSection, "addSection");
  function addInsert(values, sections, value) {
    if (value.length == 0) return;
    var index = (sections.length - 2) >> 1;
    if (index < values.length) {
      values[values.length - 1] = values[values.length - 1].append(value);
    } else {
      while (values.length < index) values.push(Text.empty);
      values.push(value);
    }
  }
  __name(addInsert, "addInsert");
  function iterChanges(desc, f, individual) {
    var inserted = desc.inserted;
    for (var posA = 0, posB = 0, i = 0; i < desc.sections.length; ) {
      var len = desc.sections[i++],
        ins = desc.sections[i++];
      if (ins < 0) {
        posA += len;
        posB += len;
      } else {
        var endA = posA,
          endB = posB,
          text2 = Text.empty;
        for (;;) {
          endA += len;
          endB += ins;
          if (ins && inserted) text2 = text2.append(inserted[(i - 2) >> 1]);
          if (individual || i == desc.sections.length || desc.sections[i + 1] < 0) break;
          len = desc.sections[i++];
          ins = desc.sections[i++];
        }
        f(posA, endA, posB, endB, text2);
        posA = endA;
        posB = endB;
      }
    }
  }
  __name(iterChanges, "iterChanges");
  function mapSet(setA, setB, before) {
    var mkSet = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    var sections = [],
      insert3 = mkSet ? [] : null;
    var a = new SectionIter(setA),
      b = new SectionIter(setB);
    for (var inserted = -1; ; ) {
      if (a.ins == -1 && b.ins == -1) {
        var len = Math.min(a.len, b.len);
        addSection(sections, len, -1);
        a.forward(len);
        b.forward(len);
      } else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || (a.off == 0 && (b.len < a.len || (b.len == a.len && !before))))) {
        var len1 = b.len;
        addSection(sections, b.ins, -1);
        while (len1) {
          var piece = Math.min(a.len, len1);
          if (a.ins >= 0 && inserted < a.i && a.len <= piece) {
            addSection(sections, 0, a.ins);
            if (insert3) addInsert(insert3, sections, a.text);
            inserted = a.i;
          }
          a.forward(piece);
          len1 -= piece;
        }
        b.next();
      } else if (a.ins >= 0) {
        var len2 = 0,
          left = a.len;
        while (left) {
          if (b.ins == -1) {
            var piece1 = Math.min(left, b.len);
            len2 += piece1;
            left -= piece1;
            b.forward(piece1);
          } else if (b.ins == 0 && b.len < left) {
            left -= b.len;
            b.next();
          } else {
            break;
          }
        }
        addSection(sections, len2, inserted < a.i ? a.ins : 0);
        if (insert3 && inserted < a.i) addInsert(insert3, sections, a.text);
        inserted = a.i;
        a.forward(a.len - left);
      } else if (a.done && b.done) {
        return insert3 ? ChangeSet.createSet(sections, insert3) : ChangeDesc.create(sections);
      } else {
        throw new Error("Mismatched change set lengths");
      }
    }
  }
  __name(mapSet, "mapSet");
  function composeSets(setA, setB) {
    var mkSet = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var sections = [];
    var insert3 = mkSet ? [] : null;
    var a = new SectionIter(setA),
      b = new SectionIter(setB);
    for (var open = false; ; ) {
      if (a.done && b.done) {
        return insert3 ? ChangeSet.createSet(sections, insert3) : ChangeDesc.create(sections);
      } else if (a.ins == 0) {
        addSection(sections, a.len, 0, open);
        a.next();
      } else if (b.len == 0 && !b.done) {
        addSection(sections, 0, b.ins, open);
        if (insert3) addInsert(insert3, sections, b.text);
        b.next();
      } else if (a.done || b.done) {
        throw new Error("Mismatched change set lengths");
      } else {
        var len = Math.min(a.len2, b.len),
          sectionLen = sections.length;
        if (a.ins == -1) {
          var insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
          addSection(sections, len, insB, open);
          if (insert3 && insB) addInsert(insert3, sections, b.text);
        } else if (b.ins == -1) {
          addSection(sections, a.off ? 0 : a.len, len, open);
          if (insert3) addInsert(insert3, sections, a.textBit(len));
        } else {
          addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
          if (insert3 && !b.off) addInsert(insert3, sections, b.text);
        }
        open = (a.ins > len || (b.ins >= 0 && b.len > len)) && (open || sections.length > sectionLen);
        a.forward2(len);
        b.forward(len);
      }
    }
  }
  __name(composeSets, "composeSets");
  var SectionIter = class SectionIter {
    next() {
      var sections = this.set.sections;
      if (this.i < sections.length) {
        this.len = sections[this.i++];
        this.ins = sections[this.i++];
      } else {
        this.len = 0;
        this.ins = -2;
      }
      this.off = 0;
    }
    get done() {
      return this.ins == -2;
    }
    get len2() {
      return this.ins < 0 ? this.len : this.ins;
    }
    get text() {
      var inserted = this.set.inserted,
        index = (this.i - 2) >> 1;
      return index >= inserted.length ? Text.empty : inserted[index];
    }
    textBit(len) {
      var inserted = this.set.inserted,
        index = (this.i - 2) >> 1;
      return index >= inserted.length && !len ? Text.empty : inserted[index].slice(this.off, len == null ? void 0 : this.off + len);
    }
    forward(len) {
      if (len == this.len) this.next();
      else {
        this.len -= len;
        this.off += len;
      }
    }
    forward2(len) {
      if (this.ins == -1) this.forward(len);
      else if (len == this.ins) this.next();
      else {
        this.ins -= len;
        this.off += len;
      }
    }
    constructor(set) {
      this.set = set;
      this.i = 0;
      this.next();
    }
  };
  __name(SectionIter, "SectionIter");
  var SelectionRange = class SelectionRange1 {
    get anchor() {
      return this.flags & 16 ? this.to : this.from;
    }
    get head() {
      return this.flags & 16 ? this.from : this.to;
    }
    get empty() {
      return this.from == this.to;
    }
    get assoc() {
      return this.flags & 4 ? -1 : this.flags & 8 ? 1 : 0;
    }
    get bidiLevel() {
      var level = this.flags & 3;
      return level == 3 ? null : level;
    }
    get goalColumn() {
      var value = this.flags >> 5;
      return value == 33554431 ? void 0 : value;
    }
    map(change) {
      var assoc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
      var from, to;
      if (this.empty) {
        from = to = change.mapPos(this.from, assoc);
      } else {
        from = change.mapPos(this.from, 1);
        to = change.mapPos(this.to, -1);
      }
      return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);
    }
    extend(from) {
      var to = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : from;
      if (from <= this.anchor && to >= this.anchor) return EditorSelection.range(from, to);
      var head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
      return EditorSelection.range(this.anchor, head);
    }
    eq(other) {
      return this.anchor == other.anchor && this.head == other.head;
    }
    toJSON() {
      return {
        anchor: this.anchor,
        head: this.head,
      };
    }
    static fromJSON(json) {
      if (!json || typeof json.anchor != "number" || typeof json.head != "number") throw new RangeError("Invalid JSON representation for SelectionRange");
      return EditorSelection.range(json.anchor, json.head);
    }
    static create(from, to, flags) {
      return new SelectionRange(from, to, flags);
    }
    constructor(from, to, flags) {
      this.from = from;
      this.to = to;
      this.flags = flags;
    }
  };
  __name(SelectionRange, "SelectionRange");
  var EditorSelection = class EditorSelection1 {
    map(change) {
      var assoc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
      if (change.empty) return this;
      return EditorSelection.create(
        this.ranges.map((r) => r.map(change, assoc)),
        this.mainIndex
      );
    }
    eq(other) {
      if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex) return false;
      for (var i = 0; i < this.ranges.length; i++) if (!this.ranges[i].eq(other.ranges[i])) return false;
      return true;
    }
    get main() {
      return this.ranges[this.mainIndex];
    }
    asSingle() {
      return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);
    }
    addRange(range) {
      var main = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
    }
    replaceRange(range) {
      var which = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.mainIndex;
      var ranges = this.ranges.slice();
      ranges[which] = range;
      return EditorSelection.create(ranges, this.mainIndex);
    }
    toJSON() {
      return {
        ranges: this.ranges.map((r) => r.toJSON()),
        main: this.mainIndex,
      };
    }
    static fromJSON(json) {
      if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length) throw new RangeError("Invalid JSON representation for EditorSelection");
      return new EditorSelection(
        json.ranges.map((r) => SelectionRange.fromJSON(r)),
        json.main
      );
    }
    static single(anchor) {
      var head = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : anchor;
      return new EditorSelection([EditorSelection.range(anchor, head)], 0);
    }
    static create(ranges) {
      var mainIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      if (ranges.length == 0) throw new RangeError("A selection needs at least one range");
      for (var pos = 0, i = 0; i < ranges.length; i++) {
        var range = ranges[i];
        if (range.empty ? range.from <= pos : range.from < pos) return EditorSelection.normalized(ranges.slice(), mainIndex);
        pos = range.to;
      }
      return new EditorSelection(ranges, mainIndex);
    }
    static cursor(pos) {
      var assoc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
        bidiLevel = arguments.length > 2 ? arguments[2] : void 0,
        goalColumn = arguments.length > 3 ? arguments[3] : void 0;
      return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 4 : 8) | (bidiLevel == null ? 3 : Math.min(2, bidiLevel)) | ((goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5));
    }
    static range(anchor, head, goalColumn) {
      var goal = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5;
      return head < anchor ? SelectionRange.create(head, anchor, 16 | goal | 8) : SelectionRange.create(anchor, head, goal | (head > anchor ? 4 : 0));
    }
    static normalized(ranges) {
      var mainIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var main = ranges[mainIndex];
      ranges.sort((a, b) => a.from - b.from);
      mainIndex = ranges.indexOf(main);
      for (var i = 1; i < ranges.length; i++) {
        var range = ranges[i],
          prev = ranges[i - 1];
        if (range.empty ? range.from <= prev.to : range.from < prev.to) {
          var from = prev.from,
            to = Math.max(range.to, prev.to);
          if (i <= mainIndex) mainIndex--;
          ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));
        }
      }
      return new EditorSelection(ranges, mainIndex);
    }
    constructor(ranges, mainIndex) {
      this.ranges = ranges;
      this.mainIndex = mainIndex;
    }
  };
  __name(EditorSelection, "EditorSelection");
  function checkSelection(selection, docLength) {
    var _iteratorNormalCompletion = true,
      _didIteratorError = false,
      _iteratorError = undefined;
    try {
      for (var _iterator = selection.ranges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var range = _step.value;
        if (range.to > docLength) throw new RangeError("Selection points outside of document");
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }
  __name(checkSelection, "checkSelection");
  var nextID = 0;
  var Facet = class Facet1 {
    static define() {
      var config = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return new Facet(config.combine || ((a) => a), config.compareInput || ((a, b) => a === b), config.compare || (!config.combine ? sameArray : (a, b) => a === b), !!config.static, config.enables);
    }
    of(value) {
      return new FacetProvider([], this, 0, value);
    }
    compute(deps, get) {
      if (this.isStatic) throw new Error("Can't compute a static facet");
      return new FacetProvider(deps, this, 1, get);
    }
    computeN(deps, get) {
      if (this.isStatic) throw new Error("Can't compute a static facet");
      return new FacetProvider(deps, this, 2, get);
    }
    from(field, get) {
      if (!get) get = /* @__PURE__ */ __name((x) => x, "get");
      return this.compute([field], (state) => get(state.field(field)));
    }
    constructor(combine, compareInput, compare2, isStatic, enables) {
      this.combine = combine;
      this.compareInput = compareInput;
      this.compare = compare2;
      this.isStatic = isStatic;
      this.id = nextID++;
      this.default = combine([]);
      this.extensions = typeof enables == "function" ? enables(this) : enables;
    }
  };
  __name(Facet, "Facet");
  function sameArray(a, b) {
    return a == b || (a.length == b.length && a.every((e, i) => e === b[i]));
  }
  __name(sameArray, "sameArray");
  var FacetProvider = class FacetProvider {
    dynamicSlot(addresses) {
      var _a2;
      var getter = this.value;
      var compare2 = this.facet.compareInput;
      var id = this.id,
        idx = addresses[id] >> 1,
        multi = this.type == 2;
      var depDoc = false,
        depSel = false,
        depAddrs = [];
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.dependencies[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var dep = _step.value;
          if (dep == "doc") depDoc = true;
          else if (dep == "selection") depSel = true;
          else if ((((_a2 = addresses[dep.id]) !== null && _a2 !== void 0 ? _a2 : 1) & 1) == 0) depAddrs.push(addresses[dep.id]);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return {
        create(state) {
          state.values[idx] = getter(state);
          return 1;
        },
        update(state, tr) {
          if ((depDoc && tr.docChanged) || (depSel && (tr.docChanged || tr.selection)) || ensureAll(state, depAddrs)) {
            var newVal = getter(state);
            if (multi ? !compareArray(newVal, state.values[idx], compare2) : !compare2(newVal, state.values[idx])) {
              state.values[idx] = newVal;
              return 1;
            }
          }
          return 0;
        },
        reconfigure: (state, oldState) => {
          var newVal,
            oldAddr = oldState.config.address[id];
          if (oldAddr != null) {
            var oldVal = getAddr(oldState, oldAddr);
            if (
              this.dependencies.every((dep) => {
                return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
              }) ||
              (multi ? compareArray((newVal = getter(state)), oldVal, compare2) : compare2((newVal = getter(state)), oldVal))
            ) {
              state.values[idx] = oldVal;
              return 0;
            }
          } else {
            newVal = getter(state);
          }
          state.values[idx] = newVal;
          return 1;
        },
      };
    }
    constructor(dependencies, facet, type, value) {
      this.dependencies = dependencies;
      this.facet = facet;
      this.type = type;
      this.value = value;
      this.id = nextID++;
    }
  };
  __name(FacetProvider, "FacetProvider");
  function compareArray(a, b, compare2) {
    if (a.length != b.length) return false;
    for (var i = 0; i < a.length; i++) if (!compare2(a[i], b[i])) return false;
    return true;
  }
  __name(compareArray, "compareArray");
  function ensureAll(state, addrs) {
    var changed = false;
    var _iteratorNormalCompletion = true,
      _didIteratorError = false,
      _iteratorError = undefined;
    try {
      for (var _iterator = addrs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var addr = _step.value;
        if (ensureAddr(state, addr) & 1) changed = true;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    return changed;
  }
  __name(ensureAll, "ensureAll");
  function dynamicFacetSlot(addresses, facet, providers) {
    var providerAddrs = providers.map((p) => addresses[p.id]);
    var providerTypes = providers.map((p) => p.type);
    var dynamic = providerAddrs.filter((p) => !(p & 1));
    var idx = addresses[facet.id] >> 1;
    function get(state) {
      var values = [];
      for (var i = 0; i < providerAddrs.length; i++) {
        var value = getAddr(state, providerAddrs[i]);
        var _iteratorNormalCompletion = true,
          _didIteratorError = false,
          _iteratorError = undefined;
        if (providerTypes[i] == 2)
          try {
            for (var _iterator = value[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var val = _step.value;
              values.push(val);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        else values.push(value);
      }
      return facet.combine(values);
    }
    __name(get, "get");
    return {
      create(state) {
        var _iteratorNormalCompletion = true,
          _didIteratorError = false,
          _iteratorError = undefined;
        try {
          for (var _iterator = providerAddrs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var addr = _step.value;
            ensureAddr(state, addr);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        state.values[idx] = get(state);
        return 1;
      },
      update(state, tr) {
        if (!ensureAll(state, dynamic)) return 0;
        var value = get(state);
        if (facet.compare(value, state.values[idx])) return 0;
        state.values[idx] = value;
        return 1;
      },
      reconfigure(state, oldState) {
        var depChanged = ensureAll(state, providerAddrs);
        var oldProviders = oldState.config.facets[facet.id],
          oldValue = oldState.facet(facet);
        if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {
          state.values[idx] = oldValue;
          return 0;
        }
        var value = get(state);
        if (facet.compare(value, oldValue)) {
          state.values[idx] = oldValue;
          return 0;
        }
        state.values[idx] = value;
        return 1;
      },
    };
  }
  __name(dynamicFacetSlot, "dynamicFacetSlot");
  var initField = /* @__PURE__ */ Facet.define({
    static: true,
  });
  var StateField = class StateField1 {
    static define(config) {
      var field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), config);
      if (config.provide) field.provides = config.provide(field);
      return field;
    }
    create(state) {
      var init2 = state.facet(initField).find((i) => i.field == this);
      return ((init2 === null || init2 === void 0 ? void 0 : init2.create) || this.createF)(state);
    }
    slot(addresses) {
      var idx = addresses[this.id] >> 1;
      return {
        create: (state) => {
          state.values[idx] = this.create(state);
          return 1;
        },
        update: (state, tr) => {
          var oldVal = state.values[idx];
          var value = this.updateF(oldVal, tr);
          if (this.compareF(oldVal, value)) return 0;
          state.values[idx] = value;
          return 1;
        },
        reconfigure: (state, oldState) => {
          if (oldState.config.address[this.id] != null) {
            state.values[idx] = oldState.field(this);
            return 0;
          }
          state.values[idx] = this.create(state);
          return 1;
        },
      };
    }
    init(create) {
      return [
        this,
        initField.of({
          field: this,
          create,
        }),
      ];
    }
    get extension() {
      return this;
    }
    constructor(id, createF, updateF, compareF, spec) {
      this.id = id;
      this.createF = createF;
      this.updateF = updateF;
      this.compareF = compareF;
      this.spec = spec;
      this.provides = void 0;
    }
  };
  __name(StateField, "StateField");
  var Prec_ = {
    lowest: 4,
    low: 3,
    default: 2,
    high: 1,
    highest: 0,
  };
  function prec(value) {
    return (ext) => new PrecExtension(ext, value);
  }
  __name(prec, "prec");
  var Prec = {
    highest: /* @__PURE__ */ prec(Prec_.highest),
    high: /* @__PURE__ */ prec(Prec_.high),
    default: /* @__PURE__ */ prec(Prec_.default),
    low: /* @__PURE__ */ prec(Prec_.low),
    lowest: /* @__PURE__ */ prec(Prec_.lowest),
  };
  var PrecExtension = class PrecExtension {
    constructor(inner, prec2) {
      this.inner = inner;
      this.prec = prec2;
    }
  };
  __name(PrecExtension, "PrecExtension");
  var Compartment = class Compartment1 {
    of(ext) {
      return new CompartmentInstance(this, ext);
    }
    reconfigure(content2) {
      return Compartment.reconfigure.of({
        compartment: this,
        extension: content2,
      });
    }
    get(state) {
      return state.config.compartments.get(this);
    }
  };
  __name(Compartment, "Compartment");
  var CompartmentInstance = class CompartmentInstance {
    constructor(compartment, inner) {
      this.compartment = compartment;
      this.inner = inner;
    }
  };
  __name(CompartmentInstance, "CompartmentInstance");
  var Configuration = class Configuration1 {
    staticFacet(facet) {
      var addr = this.address[facet.id];
      return addr == null ? facet.default : this.staticValues[addr >> 1];
    }
    static resolve(base2, compartments, oldState) {
      var _loop = function (id) {
        var providers = facets[id],
          facet = providers[0].facet;
        var oldProviders = (oldFacets && oldFacets[id]) || [];
        if (providers.every((p) => p.type == 0)) {
          address[facet.id] = (staticValues.length << 1) | 1;
          if (sameArray(oldProviders, providers)) {
            staticValues.push(oldState.facet(facet));
          } else {
            var value = facet.combine(providers.map((p) => p.value));
            staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
          }
        } else {
          var _iteratorNormalCompletion = true,
            _didIteratorError = false,
            _iteratorError = undefined;
          try {
            var _loop = function () {
              var p = _step.value;
              if (p.type == 0) {
                address[p.id] = (staticValues.length << 1) | 1;
                staticValues.push(p.value);
              } else {
                address[p.id] = dynamicSlots.length << 1;
                dynamicSlots.push((a) => p.dynamicSlot(a));
              }
            };
            for (var _iterator = providers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) _loop();
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
          address[facet.id] = dynamicSlots.length << 1;
          dynamicSlots.push((a) => dynamicFacetSlot(a, facet, providers));
        }
      };
      var fields = [];
      var facets = /* @__PURE__ */ Object.create(null);
      var newCompartments = /* @__PURE__ */ new Map();
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = flatten(base2, compartments, newCompartments)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var ext = _step.value;
          if (ext instanceof StateField) fields.push(ext);
          else (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      var address = /* @__PURE__ */ Object.create(null);
      var staticValues = [];
      var dynamicSlots = [];
      var _iteratorNormalCompletion1 = true,
        _didIteratorError1 = false,
        _iteratorError1 = undefined;
      try {
        var _loop1 = function () {
          var field = _step1.value;
          address[field.id] = dynamicSlots.length << 1;
          dynamicSlots.push((a) => field.slot(a));
        };
        for (var _iterator1 = fields[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) _loop1();
      } catch (err) {
        _didIteratorError1 = true;
        _iteratorError1 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
            _iterator1.return();
          }
        } finally {
          if (_didIteratorError1) {
            throw _iteratorError1;
          }
        }
      }
      var oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
      for (var id in facets) _loop(id);
      var dynamic = dynamicSlots.map((f) => f(address));
      return new Configuration(base2, newCompartments, dynamic, address, staticValues, facets);
    }
    constructor(base2, compartments, dynamicSlots, address, staticValues, facets) {
      this.base = base2;
      this.compartments = compartments;
      this.dynamicSlots = dynamicSlots;
      this.address = address;
      this.staticValues = staticValues;
      this.facets = facets;
      this.statusTemplate = [];
      while (this.statusTemplate.length < dynamicSlots.length) this.statusTemplate.push(0);
    }
  };
  __name(Configuration, "Configuration");
  function flatten(extension, compartments, newCompartments) {
    var result = [[], [], [], [], []];
    var seen = /* @__PURE__ */ new Map();
    function inner(ext, prec2) {
      var known = seen.get(ext);
      if (known != null) {
        if (known <= prec2) return;
        var found = result[known].indexOf(ext);
        if (found > -1) result[known].splice(found, 1);
        if (ext instanceof CompartmentInstance) newCompartments.delete(ext.compartment);
      }
      seen.set(ext, prec2);
      if (Array.isArray(ext)) {
        var _iteratorNormalCompletion = true,
          _didIteratorError = false,
          _iteratorError = undefined;
        try {
          for (var _iterator = ext[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var e = _step.value;
            inner(e, prec2);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      } else if (ext instanceof CompartmentInstance) {
        if (newCompartments.has(ext.compartment)) throw new RangeError("Duplicate use of compartment in extensions");
        var content2 = compartments.get(ext.compartment) || ext.inner;
        newCompartments.set(ext.compartment, content2);
        inner(content2, prec2);
      } else if (ext instanceof PrecExtension) {
        inner(ext.inner, ext.prec);
      } else if (ext instanceof StateField) {
        result[prec2].push(ext);
        if (ext.provides) inner(ext.provides, prec2);
      } else if (ext instanceof FacetProvider) {
        result[prec2].push(ext);
        if (ext.facet.extensions) inner(ext.facet.extensions, Prec_.default);
      } else {
        var content21 = ext.extension;
        if (!content21) throw new Error("Unrecognized extension value in extension set (".concat(ext, "). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks."));
        inner(content21, prec2);
      }
    }
    __name(inner, "inner");
    inner(extension, Prec_.default);
    return result.reduce((a, b) => a.concat(b));
  }
  __name(flatten, "flatten");
  function ensureAddr(state, addr) {
    if (addr & 1) return 2;
    var idx = addr >> 1;
    var status = state.status[idx];
    if (status == 4) throw new Error("Cyclic dependency between fields and/or facets");
    if (status & 2) return status;
    state.status[idx] = 4;
    var changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
    return (state.status[idx] = 2 | changed);
  }
  __name(ensureAddr, "ensureAddr");
  function getAddr(state, addr) {
    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
  }
  __name(getAddr, "getAddr");
  var languageData = /* @__PURE__ */ Facet.define();
  var allowMultipleSelections = /* @__PURE__ */ Facet.define({
    combine: (values) => values.some((v) => v),
    static: true,
  });
  var lineSeparator = /* @__PURE__ */ Facet.define({
    combine: (values) => (values.length ? values[0] : void 0),
    static: true,
  });
  var changeFilter = /* @__PURE__ */ Facet.define();
  var transactionFilter = /* @__PURE__ */ Facet.define();
  var transactionExtender = /* @__PURE__ */ Facet.define();
  var readOnly = /* @__PURE__ */ Facet.define({
    combine: (values) => (values.length ? values[0] : false),
  });
  var Annotation = class Annotation {
    static define() {
      return new AnnotationType();
    }
    constructor(type, value) {
      this.type = type;
      this.value = value;
    }
  };
  __name(Annotation, "Annotation");
  var AnnotationType = class AnnotationType {
    of(value) {
      return new Annotation(this, value);
    }
  };
  __name(AnnotationType, "AnnotationType");
  var StateEffectType = class StateEffectType {
    of(value) {
      return new StateEffect(this, value);
    }
    constructor(map) {
      this.map = map;
    }
  };
  __name(StateEffectType, "StateEffectType");
  var StateEffect = class StateEffect1 {
    map(mapping) {
      var mapped = this.type.map(this.value, mapping);
      return mapped === void 0 ? void 0 : mapped == this.value ? this : new StateEffect(this.type, mapped);
    }
    is(type) {
      return this.type == type;
    }
    static define() {
      var spec = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return new StateEffectType(spec.map || ((v) => v));
    }
    static mapEffects(effects, mapping) {
      if (!effects.length) return effects;
      var result = [];
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = effects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var effect = _step.value;
          var mapped = effect.map(mapping);
          if (mapped) result.push(mapped);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return result;
    }
    constructor(type, value) {
      this.type = type;
      this.value = value;
    }
  };
  __name(StateEffect, "StateEffect");
  StateEffect.reconfigure = /* @__PURE__ */ StateEffect.define();
  StateEffect.appendConfig = /* @__PURE__ */ StateEffect.define();
  var Transaction = class Transaction1 {
    static create(startState, changes, selection, effects, annotations, scrollIntoView2) {
      return new Transaction(startState, changes, selection, effects, annotations, scrollIntoView2);
    }
    get newDoc() {
      return this._doc || (this._doc = this.changes.apply(this.startState.doc));
    }
    get newSelection() {
      return this.selection || this.startState.selection.map(this.changes);
    }
    get state() {
      if (!this._state) this.startState.applyTransaction(this);
      return this._state;
    }
    annotation(type) {
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.annotations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var ann = _step.value;
          if (ann.type == type) return ann.value;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return void 0;
    }
    get docChanged() {
      return !this.changes.empty;
    }
    get reconfigured() {
      return this.startState.config != this.state.config;
    }
    isUserEvent(event) {
      var e = this.annotation(Transaction.userEvent);
      return !!(e && (e == event || (e.length > event.length && e.slice(0, event.length) == event && e[event.length] == ".")));
    }
    constructor(startState, changes, selection, effects, annotations, scrollIntoView2) {
      this.startState = startState;
      this.changes = changes;
      this.selection = selection;
      this.effects = effects;
      this.annotations = annotations;
      this.scrollIntoView = scrollIntoView2;
      this._doc = null;
      this._state = null;
      if (selection) checkSelection(selection, changes.newLength);
      if (!annotations.some((a) => a.type == Transaction.time)) this.annotations = annotations.concat(Transaction.time.of(Date.now()));
    }
  };
  __name(Transaction, "Transaction");
  Transaction.time = /* @__PURE__ */ Annotation.define();
  Transaction.userEvent = /* @__PURE__ */ Annotation.define();
  Transaction.addToHistory = /* @__PURE__ */ Annotation.define();
  Transaction.remote = /* @__PURE__ */ Annotation.define();
  function joinRanges(a, b) {
    var result = [];
    for (var iA = 0, iB = 0; ; ) {
      var from = void 0,
        to = void 0;
      if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
        from = a[iA++];
        to = a[iA++];
      } else if (iB < b.length) {
        from = b[iB++];
        to = b[iB++];
      } else return result;
      if (!result.length || result[result.length - 1] < from) result.push(from, to);
      else if (result[result.length - 1] < to) result[result.length - 1] = to;
    }
  }
  __name(joinRanges, "joinRanges");
  function mergeTransaction(a, b, sequential) {
    var _a2;
    var mapForA, mapForB, changes;
    if (sequential) {
      mapForA = b.changes;
      mapForB = ChangeSet.empty(b.changes.length);
      changes = a.changes.compose(b.changes);
    } else {
      mapForA = b.changes.map(a.changes);
      mapForB = a.changes.mapDesc(b.changes, true);
      changes = a.changes.compose(mapForA);
    }
    return {
      changes,
      selection: b.selection ? b.selection.map(mapForB) : (_a2 = a.selection) === null || _a2 === void 0 ? void 0 : _a2.map(mapForA),
      effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
      annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
      scrollIntoView: a.scrollIntoView || b.scrollIntoView,
    };
  }
  __name(mergeTransaction, "mergeTransaction");
  function resolveTransactionInner(state, spec, docSize) {
    var sel = spec.selection,
      annotations = asArray(spec.annotations);
    if (spec.userEvent) annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
    return {
      changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
      selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
      effects: asArray(spec.effects),
      annotations,
      scrollIntoView: !!spec.scrollIntoView,
    };
  }
  __name(resolveTransactionInner, "resolveTransactionInner");
  function resolveTransaction(state, specs, filter) {
    var s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
    if (specs.length && specs[0].filter === false) filter = false;
    for (var i = 1; i < specs.length; i++) {
      if (specs[i].filter === false) filter = false;
      var seq = !!specs[i].sequential;
      s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);
    }
    var tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
    return extendTransaction(filter ? filterTransaction(tr) : tr);
  }
  __name(resolveTransaction, "resolveTransaction");
  function filterTransaction(tr) {
    var state = tr.startState;
    var result = true;
    var _iteratorNormalCompletion = true,
      _didIteratorError = false,
      _iteratorError = undefined;
    try {
      for (var _iterator = state.facet(changeFilter)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var filter = _step.value;
        var value = filter(tr);
        if (value === false) {
          result = false;
          break;
        }
        if (Array.isArray(value)) result = result === true ? value : joinRanges(result, value);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    if (result !== true) {
      var changes, back;
      if (result === false) {
        back = tr.changes.invertedDesc;
        changes = ChangeSet.empty(state.doc.length);
      } else {
        var filtered = tr.changes.filter(result);
        changes = filtered.changes;
        back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
      }
      tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
    }
    var filters = state.facet(transactionFilter);
    for (var i = filters.length - 1; i >= 0; i--) {
      var filtered1 = filters[i](tr);
      if (filtered1 instanceof Transaction) tr = filtered1;
      else if (Array.isArray(filtered1) && filtered1.length == 1 && filtered1[0] instanceof Transaction) tr = filtered1[0];
      else tr = resolveTransaction(state, asArray(filtered1), false);
    }
    return tr;
  }
  __name(filterTransaction, "filterTransaction");
  function extendTransaction(tr) {
    var state = tr.startState,
      extenders = state.facet(transactionExtender),
      spec = tr;
    for (var i = extenders.length - 1; i >= 0; i--) {
      var extension = extenders[i](tr);
      if (extension && Object.keys(extension).length) spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);
    }
    return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
  }
  __name(extendTransaction, "extendTransaction");
  var none = [];
  function asArray(value) {
    return value == null ? none : Array.isArray(value) ? value : [value];
  }
  __name(asArray, "asArray");
  var CharCategory = /* @__PURE__ */ (function (CharCategory2) {
    CharCategory2[(CharCategory2["Word"] = 0)] = "Word";
    CharCategory2[(CharCategory2["Space"] = 1)] = "Space";
    CharCategory2[(CharCategory2["Other"] = 2)] = "Other";
    return CharCategory2;
  })(CharCategory || (CharCategory = {}));
  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  var wordChar;
  try {
    wordChar = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
  } catch (_) {}
  function hasWordChar(str) {
    if (wordChar) return wordChar.test(str);
    for (var i = 0; i < str.length; i++) {
      var ch = str[i];
      if (/\w/.test(ch) || (ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))) return true;
    }
    return false;
  }
  __name(hasWordChar, "hasWordChar");
  function makeCategorizer(wordChars) {
    return (char) => {
      if (!/\S/.test(char)) return CharCategory.Space;
      if (hasWordChar(char)) return CharCategory.Word;
      for (var i = 0; i < wordChars.length; i++) if (char.indexOf(wordChars[i]) > -1) return CharCategory.Word;
      return CharCategory.Other;
    };
  }
  __name(makeCategorizer, "makeCategorizer");
  var EditorState = class EditorState1 {
    field(field) {
      var require2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var addr = this.config.address[field.id];
      if (addr == null) {
        if (require2) throw new RangeError("Field is not present in this state");
        return void 0;
      }
      ensureAddr(this, addr);
      return getAddr(this, addr);
    }
    update() {
      for (var _len = arguments.length, specs = new Array(_len), _key = 0; _key < _len; _key++) {
        specs[_key] = arguments[_key];
      }
      return resolveTransaction(this, specs, true);
    }
    applyTransaction(tr) {
      var conf = this.config,
        base2 = conf.base,
        compartments = conf.compartments;
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = tr.effects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var effect = _step.value;
          if (effect.is(Compartment.reconfigure)) {
            if (conf) {
              compartments = /* @__PURE__ */ new Map();
              conf.compartments.forEach((val, key) => compartments.set(key, val));
              conf = null;
            }
            compartments.set(effect.value.compartment, effect.value.extension);
          } else if (effect.is(StateEffect.reconfigure)) {
            conf = null;
            base2 = effect.value;
          } else if (effect.is(StateEffect.appendConfig)) {
            conf = null;
            base2 = asArray(base2).concat(effect.value);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      var startValues;
      if (!conf) {
        conf = Configuration.resolve(base2, compartments, this);
        var intermediateState = new EditorState(
          conf,
          this.doc,
          this.selection,
          conf.dynamicSlots.map(() => null),
          (state, slot) => slot.reconfigure(state, this),
          null
        );
        startValues = intermediateState.values;
      } else {
        startValues = tr.startState.values.slice();
      }
      new EditorState(conf, tr.newDoc, tr.newSelection, startValues, (state, slot) => slot.update(state, tr), tr);
    }
    replaceSelection(text2) {
      if (typeof text2 == "string") text2 = this.toText(text2);
      return this.changeByRange((range) => ({
        changes: {
          from: range.from,
          to: range.to,
          insert: text2,
        },
        range: EditorSelection.cursor(range.from + text2.length),
      }));
    }
    changeByRange(f) {
      var sel = this.selection;
      var result1 = f(sel.ranges[0]);
      var changes = this.changes(result1.changes),
        ranges = [result1.range];
      var effects = asArray(result1.effects);
      for (var i = 1; i < sel.ranges.length; i++) {
        var result = f(sel.ranges[i]);
        var newChanges = this.changes(result.changes),
          newMapped = newChanges.map(changes);
        for (var j = 0; j < i; j++) ranges[j] = ranges[j].map(newMapped);
        var mapBy = changes.mapDesc(newChanges, true);
        ranges.push(result.range.map(mapBy));
        changes = changes.compose(newMapped);
        effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
      }
      return {
        changes,
        selection: EditorSelection.create(ranges, sel.mainIndex),
        effects,
      };
    }
    changes() {
      var spec = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      if (spec instanceof ChangeSet) return spec;
      return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
    }
    toText(string2) {
      return Text.of(string2.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
    }
    sliceDoc() {
      var from = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0,
        to = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.doc.length;
      return this.doc.sliceString(from, to, this.lineBreak);
    }
    facet(facet) {
      var addr = this.config.address[facet.id];
      if (addr == null) return facet.default;
      ensureAddr(this, addr);
      return getAddr(this, addr);
    }
    toJSON(fields) {
      var result = {
        doc: this.sliceDoc(),
        selection: this.selection.toJSON(),
      };
      if (fields)
        for (var prop in fields) {
          var value = fields[prop];
          if (value instanceof StateField && this.config.address[value.id] != null) result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
        }
      return result;
    }
    static fromJSON(json) {
      var _loop = function (prop) {
        if (Object.prototype.hasOwnProperty.call(json, prop)) {
          var field = fields[prop],
            value = json[prop];
          fieldInit.push(field.init((state) => field.spec.fromJSON(value, state)));
        }
      };
      var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        fields = arguments.length > 2 ? arguments[2] : void 0;
      if (!json || typeof json.doc != "string") throw new RangeError("Invalid JSON representation for EditorState");
      var fieldInit = [];
      if (fields) for (var prop in fields) _loop(prop);
      return EditorState.create({
        doc: json.doc,
        selection: EditorSelection.fromJSON(json.selection),
        extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit,
      });
    }
    static create() {
      var config = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var configuration = Configuration.resolve(config.extensions || [], /* @__PURE__ */ new Map());
      var doc2 = config.doc instanceof Text ? config.doc : Text.of((config.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
      var selection = !config.selection ? EditorSelection.single(0) : config.selection instanceof EditorSelection ? config.selection : EditorSelection.single(config.selection.anchor, config.selection.head);
      checkSelection(selection, doc2.length);
      if (!configuration.staticFacet(allowMultipleSelections)) selection = selection.asSingle();
      return new EditorState(
        configuration,
        doc2,
        selection,
        configuration.dynamicSlots.map(() => null),
        (state, slot) => slot.create(state),
        null
      );
    }
    get tabSize() {
      return this.facet(EditorState.tabSize);
    }
    get lineBreak() {
      return this.facet(EditorState.lineSeparator) || "\n";
    }
    get readOnly() {
      return this.facet(readOnly);
    }
    phrase(phrase) {
      for (var _len = arguments.length, insert3 = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        insert3[_key - 1] = arguments[_key];
      }
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.facet(EditorState.phrases)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var map = _step.value;
          if (Object.prototype.hasOwnProperty.call(map, phrase)) {
            phrase = map[phrase];
            break;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      if (insert3.length)
        phrase = phrase.replace(/\$(\$|\d*)/g, (m, i) => {
          if (i == "$") return "$";
          var n = +(i || 1);
          return !n || n > insert3.length ? m : insert3[n - 1];
        });
      return phrase;
    }
    languageDataAt(name2, pos) {
      var side = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
      var values = [];
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.facet(languageData)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var provider = _step.value;
          var _iteratorNormalCompletion1 = true,
            _didIteratorError1 = false,
            _iteratorError1 = undefined;
          try {
            for (var _iterator1 = provider(this, pos, side)[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
              var result = _step1.value;
              if (Object.prototype.hasOwnProperty.call(result, name2)) values.push(result[name2]);
            }
          } catch (err) {
            _didIteratorError1 = true;
            _iteratorError1 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                _iterator1.return();
              }
            } finally {
              if (_didIteratorError1) {
                throw _iteratorError1;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return values;
    }
    charCategorizer(at) {
      return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
    }
    wordAt(pos) {
      var _this_doc_lineAt = this.doc.lineAt(pos),
        text2 = _this_doc_lineAt.text,
        from = _this_doc_lineAt.from,
        length = _this_doc_lineAt.length;
      var cat = this.charCategorizer(pos);
      var start = pos - from,
        end = pos - from;
      while (start > 0) {
        var prev = findClusterBreak(text2, start, false);
        if (cat(text2.slice(prev, start)) != CharCategory.Word) break;
        start = prev;
      }
      while (end < length) {
        var next = findClusterBreak(text2, end);
        if (cat(text2.slice(end, next)) != CharCategory.Word) break;
        end = next;
      }
      return start == end ? null : EditorSelection.range(start + from, end + from);
    }
    constructor(config, doc2, selection, values, computeSlot, tr) {
      this.config = config;
      this.doc = doc2;
      this.selection = selection;
      this.values = values;
      this.status = config.statusTemplate.slice();
      this.computeSlot = computeSlot;
      if (tr) tr._state = this;
      for (var i = 0; i < this.config.dynamicSlots.length; i++) ensureAddr(this, i << 1);
      this.computeSlot = null;
    }
  };
  __name(EditorState, "EditorState");
  EditorState.allowMultipleSelections = allowMultipleSelections;
  EditorState.tabSize = /* @__PURE__ */ Facet.define({
    combine: (values) => (values.length ? values[0] : 4),
  });
  EditorState.lineSeparator = lineSeparator;
  EditorState.readOnly = readOnly;
  EditorState.phrases = /* @__PURE__ */ Facet.define({
    compare(a, b) {
      var kA = Object.keys(a),
        kB = Object.keys(b);
      return kA.length == kB.length && kA.every((k) => a[k] == b[k]);
    },
  });
  EditorState.languageData = languageData;
  EditorState.changeFilter = changeFilter;
  EditorState.transactionFilter = transactionFilter;
  EditorState.transactionExtender = transactionExtender;
  Compartment.reconfigure = /* @__PURE__ */ StateEffect.define();
  function combineConfig(configs, defaults) {
    var combine = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var result = {};
    var _iteratorNormalCompletion = true,
      _didIteratorError = false,
      _iteratorError = undefined,
      _iteratorNormalCompletion1 = true,
      _didIteratorError1 = false,
      _iteratorError1 = undefined;
    try {
      for (var _iterator = configs[Symbol.iterator](), _step; !(_iteratorNormalCompletion1 = (_step = _iterator.next()).done); _iteratorNormalCompletion1 = true) {
        var config = _step.value;
        try {
          for (var _iterator1 = Object.keys(config)[Symbol.iterator](), _step1; !(_iteratorNormalCompletion = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion = true) {
            var key = _step1.value;
            var value = config[key],
              current = result[key];
            if (current === void 0) result[key] = value;
            else if (current === value || value === void 0);
            else if (Object.hasOwnProperty.call(combine, key)) result[key] = combine[key](current, value);
            else throw new Error("Config merge conflict for field " + key);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator1.return != null) {
              _iterator1.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError1 = true;
      _iteratorError1 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion1 && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError1) {
          throw _iteratorError1;
        }
      }
    }
    for (var key1 in defaults) if (result[key1] === void 0) result[key1] = defaults[key1];
    return result;
  }
  __name(combineConfig, "combineConfig");
  var RangeValue = class RangeValue {
    eq(other) {
      return this == other;
    }
    range(from) {
      var to = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : from;
      return Range.create(from, to, this);
    }
  };
  __name(RangeValue, "RangeValue");
  RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
  RangeValue.prototype.point = false;
  RangeValue.prototype.mapMode = MapMode.TrackDel;
  var Range = class Range1 {
    static create(from, to, value) {
      return new Range(from, to, value);
    }
    constructor(from, to, value) {
      this.from = from;
      this.to = to;
      this.value = value;
    }
  };
  __name(Range, "Range");
  function cmpRange(a, b) {
    return a.from - b.from || a.value.startSide - b.value.startSide;
  }
  __name(cmpRange, "cmpRange");
  var Chunk = class Chunk1 {
    get length() {
      return this.to[this.to.length - 1];
    }
    findIndex(pos, side, end) {
      var startAt = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      var arr = end ? this.to : this.from;
      for (var lo = startAt, hi = arr.length; ; ) {
        if (lo == hi) return lo;
        var mid = (lo + hi) >> 1;
        var diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
        if (mid == lo) return diff >= 0 ? lo : hi;
        if (diff >= 0) hi = mid;
        else lo = mid + 1;
      }
    }
    between(offset, from, to, f) {
      for (var i = this.findIndex(from, -1e9, true), e = this.findIndex(to, 1e9, false, i); i < e; i++) if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false) return false;
    }
    map(offset, changes) {
      var value = [],
        from = [],
        to = [],
        newPos = -1,
        maxPoint = -1;
      for (var i = 0; i < this.value.length; i++) {
        var val = this.value[i],
          curFrom = this.from[i] + offset,
          curTo = this.to[i] + offset,
          newFrom = void 0,
          newTo = void 0;
        if (curFrom == curTo) {
          var mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
          if (mapped == null) continue;
          newFrom = newTo = mapped;
          if (val.startSide != val.endSide) {
            newTo = changes.mapPos(curFrom, val.endSide);
            if (newTo < newFrom) continue;
          }
        } else {
          newFrom = changes.mapPos(curFrom, val.startSide);
          newTo = changes.mapPos(curTo, val.endSide);
          if (newFrom > newTo || (newFrom == newTo && val.startSide > 0 && val.endSide <= 0)) continue;
        }
        if ((newTo - newFrom || val.endSide - val.startSide) < 0) continue;
        if (newPos < 0) newPos = newFrom;
        if (val.point) maxPoint = Math.max(maxPoint, newTo - newFrom);
        value.push(val);
        from.push(newFrom - newPos);
        to.push(newTo - newPos);
      }
      return {
        mapped: value.length ? new Chunk(from, to, value, maxPoint) : null,
        pos: newPos,
      };
    }
    constructor(from, to, value, maxPoint) {
      this.from = from;
      this.to = to;
      this.value = value;
      this.maxPoint = maxPoint;
    }
  };
  __name(Chunk, "Chunk");
  var RangeSet = class RangeSet1 {
    static create(chunkPos, chunk, nextLayer, maxPoint) {
      return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);
    }
    get length() {
      var last = this.chunk.length - 1;
      return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
    }
    get size() {
      if (this.isEmpty) return 0;
      var size = this.nextLayer.size;
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.chunk[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var chunk = _step.value;
          size += chunk.value.length;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return size;
    }
    chunkEnd(index) {
      return this.chunkPos[index] + this.chunk[index].length;
    }
    update(updateSpec) {
      var tmp = updateSpec.add,
        add2 = tmp === void 0 ? [] : tmp,
        _updateSpec_sort = updateSpec.sort,
        sort = _updateSpec_sort === void 0 ? false : _updateSpec_sort,
        _updateSpec_filterFrom = updateSpec.filterFrom,
        filterFrom = _updateSpec_filterFrom === void 0 ? 0 : _updateSpec_filterFrom,
        _updateSpec_filterTo = updateSpec.filterTo,
        filterTo = _updateSpec_filterTo === void 0 ? this.length : _updateSpec_filterTo;
      var filter = updateSpec.filter;
      if (add2.length == 0 && !filter) return this;
      if (sort) add2 = add2.slice().sort(cmpRange);
      if (this.isEmpty) return add2.length ? RangeSet.of(add2) : this;
      var cur = new LayerCursor(this, null, -1).goto(0),
        i = 0,
        spill = [];
      var builder = new RangeSetBuilder();
      while (cur.value || i < add2.length) {
        if (i < add2.length && (cur.from - add2[i].from || cur.startSide - add2[i].value.startSide) >= 0) {
          var range = add2[i++];
          if (!builder.addInner(range.from, range.to, range.value)) spill.push(range);
        } else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length && (i == add2.length || this.chunkEnd(cur.chunkIndex) < add2[i].from) && (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) && builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {
          cur.nextChunk();
        } else {
          if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {
            if (!builder.addInner(cur.from, cur.to, cur.value)) spill.push(Range.create(cur.from, cur.to, cur.value));
          }
          cur.next();
        }
      }
      return builder.finishInner(
        this.nextLayer.isEmpty && !spill.length
          ? RangeSet.empty
          : this.nextLayer.update({
              add: spill,
              filter,
              filterFrom,
              filterTo,
            })
      );
    }
    map(changes) {
      if (changes.empty || this.isEmpty) return this;
      var chunks = [],
        chunkPos = [],
        maxPoint = -1;
      for (var i = 0; i < this.chunk.length; i++) {
        var start = this.chunkPos[i],
          chunk = this.chunk[i];
        var touch = changes.touchesRange(start, start + chunk.length);
        if (touch === false) {
          maxPoint = Math.max(maxPoint, chunk.maxPoint);
          chunks.push(chunk);
          chunkPos.push(changes.mapPos(start));
        } else if (touch === true) {
          var _chunk_map = chunk.map(start, changes),
            mapped = _chunk_map.mapped,
            pos = _chunk_map.pos;
          if (mapped) {
            maxPoint = Math.max(maxPoint, mapped.maxPoint);
            chunks.push(mapped);
            chunkPos.push(pos);
          }
        }
      }
      var next = this.nextLayer.map(changes);
      return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);
    }
    between(from, to, f) {
      if (this.isEmpty) return;
      for (var i = 0; i < this.chunk.length; i++) {
        var start = this.chunkPos[i],
          chunk = this.chunk[i];
        if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f) === false) return;
      }
      this.nextLayer.between(from, to, f);
    }
    iter() {
      var from = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return HeapCursor.from([this]).goto(from);
    }
    get isEmpty() {
      return this.nextLayer == this;
    }
    static iter(sets) {
      var from = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      return HeapCursor.from(sets).goto(from);
    }
    static compare(oldSets, newSets, textDiff, comparator) {
      var minPointSize = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : -1;
      var a = oldSets.filter((set) => set.maxPoint > 0 || (!set.isEmpty && set.maxPoint >= minPointSize));
      var b = newSets.filter((set) => set.maxPoint > 0 || (!set.isEmpty && set.maxPoint >= minPointSize));
      var sharedChunks = findSharedChunks(a, b, textDiff);
      var sideA = new SpanCursor(a, sharedChunks, minPointSize);
      var sideB = new SpanCursor(b, sharedChunks, minPointSize);
      textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
      if (textDiff.empty && textDiff.length == 0) compare(sideA, 0, sideB, 0, 0, comparator);
    }
    static eq(oldSets, newSets) {
      var from = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,
        to = arguments.length > 3 ? arguments[3] : void 0;
      if (to == null) to = 1e9 - 1;
      var a = oldSets.filter((set) => !set.isEmpty && newSets.indexOf(set) < 0);
      var b = newSets.filter((set) => !set.isEmpty && oldSets.indexOf(set) < 0);
      if (a.length != b.length) return false;
      if (!a.length) return true;
      var sharedChunks = findSharedChunks(a, b);
      var sideA = new SpanCursor(a, sharedChunks, 0).goto(from),
        sideB = new SpanCursor(b, sharedChunks, 0).goto(from);
      for (;;) {
        if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || (sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))) return false;
        if (sideA.to > to) return true;
        sideA.next();
        sideB.next();
      }
    }
    static spans(sets, from, to, iterator) {
      var minPointSize = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : -1;
      var cursor = new SpanCursor(sets, null, minPointSize).goto(from),
        pos = from;
      var openRanges = cursor.openStart;
      for (;;) {
        var curTo = Math.min(cursor.to, to);
        if (cursor.point) {
          var active = cursor.activeForPoint(cursor.to);
          var openCount = cursor.pointFrom < from ? active.length + 1 : Math.min(active.length, openRanges);
          iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);
          openRanges = Math.min(cursor.openEnd(curTo), active.length);
        } else if (curTo > pos) {
          iterator.span(pos, curTo, cursor.active, openRanges);
          openRanges = cursor.openEnd(curTo);
        }
        if (cursor.to > to) return openRanges + (cursor.point && cursor.to > to ? 1 : 0);
        pos = cursor.to;
        cursor.next();
      }
    }
    static of(ranges) {
      var sort = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var build = new RangeSetBuilder();
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = (ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var range = _step.value;
          build.add(range.from, range.to, range.value);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return build.finish();
    }
    constructor(chunkPos, chunk, nextLayer, maxPoint) {
      this.chunkPos = chunkPos;
      this.chunk = chunk;
      this.nextLayer = nextLayer;
      this.maxPoint = maxPoint;
    }
  };
  __name(RangeSet, "RangeSet");
  RangeSet.empty = /* @__PURE__ */ new RangeSet([], [], null, -1);
  function lazySort(ranges) {
    if (ranges.length > 1)
      for (var prev = ranges[0], i = 1; i < ranges.length; i++) {
        var cur = ranges[i];
        if (cmpRange(prev, cur) > 0) return ranges.slice().sort(cmpRange);
        prev = cur;
      }
    return ranges;
  }
  __name(lazySort, "lazySort");
  RangeSet.empty.nextLayer = RangeSet.empty;
  var RangeSetBuilder = class RangeSetBuilder1 {
    finishChunk(newArrays) {
      this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
      this.chunkPos.push(this.chunkStart);
      this.chunkStart = -1;
      this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
      this.maxPoint = -1;
      if (newArrays) {
        this.from = [];
        this.to = [];
        this.value = [];
      }
    }
    add(from, to, value) {
      if (!this.addInner(from, to, value)) (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from, to, value);
    }
    addInner(from, to, value) {
      var diff = from - this.lastTo || value.startSide - this.last.endSide;
      if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0) throw new Error("Ranges must be added sorted by `from` position and `startSide`");
      if (diff < 0) return false;
      if (this.from.length == 250) this.finishChunk(true);
      if (this.chunkStart < 0) this.chunkStart = from;
      this.from.push(from - this.chunkStart);
      this.to.push(to - this.chunkStart);
      this.last = value;
      this.lastFrom = from;
      this.lastTo = to;
      this.value.push(value);
      if (value.point) this.maxPoint = Math.max(this.maxPoint, to - from);
      return true;
    }
    addChunk(from, chunk) {
      if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0) return false;
      if (this.from.length) this.finishChunk(true);
      this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
      this.chunks.push(chunk);
      this.chunkPos.push(from);
      var last = chunk.value.length - 1;
      this.last = chunk.value[last];
      this.lastFrom = chunk.from[last] + from;
      this.lastTo = chunk.to[last] + from;
      return true;
    }
    finish() {
      return this.finishInner(RangeSet.empty);
    }
    finishInner(next) {
      if (this.from.length) this.finishChunk(false);
      if (this.chunks.length == 0) return next;
      var result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
      this.from = null;
      return result;
    }
    constructor() {
      this.chunks = [];
      this.chunkPos = [];
      this.chunkStart = -1;
      this.last = null;
      this.lastFrom = -1e9;
      this.lastTo = -1e9;
      this.from = [];
      this.to = [];
      this.value = [];
      this.maxPoint = -1;
      this.setMaxPoint = -1;
      this.nextLayer = null;
    }
  };
  __name(RangeSetBuilder, "RangeSetBuilder");
  function findSharedChunks(a, b, textDiff) {
    var inA = /* @__PURE__ */ new Map();
    var _iteratorNormalCompletion = true,
      _didIteratorError = false,
      _iteratorError = undefined;
    try {
      for (var _iterator = a[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var set = _step.value;
        for (var i = 0; i < set.chunk.length; i++) if (set.chunk[i].maxPoint <= 0) inA.set(set.chunk[i], set.chunkPos[i]);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    var shared = /* @__PURE__ */ new Set();
    var _iteratorNormalCompletion1 = true,
      _didIteratorError1 = false,
      _iteratorError1 = undefined;
    try {
      for (var _iterator1 = b[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
        var set1 = _step1.value;
        for (var i1 = 0; i1 < set1.chunk.length; i1++) {
          var known = inA.get(set1.chunk[i1]);
          if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set1.chunkPos[i1] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set1.chunk[i1].length))) shared.add(set1.chunk[i1]);
        }
      }
    } catch (err) {
      _didIteratorError1 = true;
      _iteratorError1 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
          _iterator1.return();
        }
      } finally {
        if (_didIteratorError1) {
          throw _iteratorError1;
        }
      }
    }
    return shared;
  }
  __name(findSharedChunks, "findSharedChunks");
  var LayerCursor = class LayerCursor {
    get startSide() {
      return this.value ? this.value.startSide : 0;
    }
    get endSide() {
      return this.value ? this.value.endSide : 0;
    }
    goto(pos) {
      var side = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1e9;
      this.chunkIndex = this.rangeIndex = 0;
      this.gotoInner(pos, side, false);
      return this;
    }
    gotoInner(pos, side, forward) {
      while (this.chunkIndex < this.layer.chunk.length) {
        var next = this.layer.chunk[this.chunkIndex];
        if (!((this.skip && this.skip.has(next)) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint)) break;
        this.chunkIndex++;
        forward = false;
      }
      if (this.chunkIndex < this.layer.chunk.length) {
        var rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
        if (!forward || this.rangeIndex < rangeIndex) this.setRangeIndex(rangeIndex);
      }
      this.next();
    }
    forward(pos, side) {
      if ((this.to - pos || this.endSide - side) < 0) this.gotoInner(pos, side, true);
    }
    next() {
      for (;;) {
        if (this.chunkIndex == this.layer.chunk.length) {
          this.from = this.to = 1e9;
          this.value = null;
          break;
        } else {
          var chunkPos = this.layer.chunkPos[this.chunkIndex],
            chunk = this.layer.chunk[this.chunkIndex];
          var from = chunkPos + chunk.from[this.rangeIndex];
          this.from = from;
          this.to = chunkPos + chunk.to[this.rangeIndex];
          this.value = chunk.value[this.rangeIndex];
          this.setRangeIndex(this.rangeIndex + 1);
          if (this.minPoint < 0 || (this.value.point && this.to - this.from >= this.minPoint)) break;
        }
      }
    }
    setRangeIndex(index) {
      if (index == this.layer.chunk[this.chunkIndex].value.length) {
        this.chunkIndex++;
        if (this.skip) {
          while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex])) this.chunkIndex++;
        }
        this.rangeIndex = 0;
      } else {
        this.rangeIndex = index;
      }
    }
    nextChunk() {
      this.chunkIndex++;
      this.rangeIndex = 0;
      this.next();
    }
    compare(other) {
      return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
    }
    constructor(layer2, skip, minPoint, ref) {
      var rank = ref === void 0 ? 0 : ref;
      this.layer = layer2;
      this.skip = skip;
      this.minPoint = minPoint;
      this.rank = rank;
    }
  };
  __name(LayerCursor, "LayerCursor");
  var HeapCursor = class HeapCursor1 {
    static from(sets) {
      var skip = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,
        minPoint = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
      var heap = [];
      for (var i = 0; i < sets.length; i++) {
        for (var cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {
          if (cur.maxPoint >= minPoint) heap.push(new LayerCursor(cur, skip, minPoint, i));
        }
      }
      return heap.length == 1 ? heap[0] : new HeapCursor(heap);
    }
    get startSide() {
      return this.value ? this.value.startSide : 0;
    }
    goto(pos) {
      var side = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1e9;
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.heap[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var cur = _step.value;
          cur.goto(pos, side);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      for (var i = this.heap.length >> 1; i >= 0; i--) heapBubble(this.heap, i);
      this.next();
      return this;
    }
    forward(pos, side) {
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.heap[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var cur = _step.value;
          cur.forward(pos, side);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      for (var i = this.heap.length >> 1; i >= 0; i--) heapBubble(this.heap, i);
      if ((this.to - pos || this.value.endSide - side) < 0) this.next();
    }
    next() {
      if (this.heap.length == 0) {
        this.from = this.to = 1e9;
        this.value = null;
        this.rank = -1;
      } else {
        var top2 = this.heap[0];
        this.from = top2.from;
        this.to = top2.to;
        this.value = top2.value;
        this.rank = top2.rank;
        if (top2.value) top2.next();
        heapBubble(this.heap, 0);
      }
    }
    constructor(heap) {
      this.heap = heap;
    }
  };
  __name(HeapCursor, "HeapCursor");
  function heapBubble(heap, index) {
    for (var cur = heap[index]; ; ) {
      var childIndex = (index << 1) + 1;
      if (childIndex >= heap.length) break;
      var child = heap[childIndex];
      if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
        child = heap[childIndex + 1];
        childIndex++;
      }
      if (cur.compare(child) < 0) break;
      heap[childIndex] = cur;
      heap[index] = child;
      index = childIndex;
    }
  }
  __name(heapBubble, "heapBubble");
  var SpanCursor = class SpanCursor {
    goto(pos) {
      var side = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1e9;
      this.cursor.goto(pos, side);
      this.active.length = this.activeTo.length = this.activeRank.length = 0;
      this.minActive = -1;
      this.to = pos;
      this.endSide = side;
      this.openStart = -1;
      this.next();
      return this;
    }
    forward(pos, side) {
      while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0) this.removeActive(this.minActive);
      this.cursor.forward(pos, side);
    }
    removeActive(index) {
      remove(this.active, index);
      remove(this.activeTo, index);
      remove(this.activeRank, index);
      this.minActive = findMinIndex(this.active, this.activeTo);
    }
    addActive(trackOpen) {
      var i = 0,
        _this_cursor = this.cursor,
        value = _this_cursor.value,
        to = _this_cursor.to,
        rank = _this_cursor.rank;
      while (i < this.activeRank.length && this.activeRank[i] <= rank) i++;
      insert2(this.active, i, value);
      insert2(this.activeTo, i, to);
      insert2(this.activeRank, i, rank);
      if (trackOpen) insert2(trackOpen, i, this.cursor.from);
      this.minActive = findMinIndex(this.active, this.activeTo);
    }
    next() {
      var from = this.to,
        wasPoint = this.point;
      this.point = null;
      var trackOpen = this.openStart < 0 ? [] : null;
      for (;;) {
        var a = this.minActive;
        if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
          if (this.activeTo[a] > from) {
            this.to = this.activeTo[a];
            this.endSide = this.active[a].endSide;
            break;
          }
          this.removeActive(a);
          if (trackOpen) remove(trackOpen, a);
        } else if (!this.cursor.value) {
          this.to = this.endSide = 1e9;
          break;
        } else if (this.cursor.from > from) {
          this.to = this.cursor.from;
          this.endSide = this.cursor.startSide;
          break;
        } else {
          var nextVal = this.cursor.value;
          if (!nextVal.point) {
            this.addActive(trackOpen);
            this.cursor.next();
          } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
            this.cursor.next();
          } else {
            this.point = nextVal;
            this.pointFrom = this.cursor.from;
            this.pointRank = this.cursor.rank;
            this.to = this.cursor.to;
            this.endSide = nextVal.endSide;
            this.cursor.next();
            this.forward(this.to, this.endSide);
            break;
          }
        }
      }
      if (trackOpen) {
        this.openStart = 0;
        for (var i = trackOpen.length - 1; i >= 0 && trackOpen[i] < from; i--) this.openStart++;
      }
    }
    activeForPoint(to) {
      if (!this.active.length) return this.active;
      var active = [];
      for (var i = this.active.length - 1; i >= 0; i--) {
        if (this.activeRank[i] < this.pointRank) break;
        if (this.activeTo[i] > to || (this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide)) active.push(this.active[i]);
      }
      return active.reverse();
    }
    openEnd(to) {
      var open = 0;
      for (var i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--) open++;
      return open;
    }
    constructor(sets, skip, minPoint) {
      this.minPoint = minPoint;
      this.active = [];
      this.activeTo = [];
      this.activeRank = [];
      this.minActive = -1;
      this.point = null;
      this.pointFrom = 0;
      this.pointRank = 0;
      this.to = -1e9;
      this.endSide = 0;
      this.openStart = -1;
      this.cursor = HeapCursor.from(sets, skip, minPoint);
    }
  };
  __name(SpanCursor, "SpanCursor");
  function compare(a, startA, b, startB, length, comparator) {
    a.goto(startA);
    b.goto(startB);
    var endB = startB + length;
    var pos = startB,
      dPos = startB - startA;
    for (;;) {
      var diff = a.to + dPos - b.to || a.endSide - b.endSide;
      var end = diff < 0 ? a.to + dPos : b.to,
        clipEnd = Math.min(end, endB);
      if (a.point || b.point) {
        if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to + dPos), b.activeForPoint(b.to)))) comparator.comparePoint(pos, clipEnd, a.point, b.point);
      } else {
        if (clipEnd > pos && !sameValues(a.active, b.active)) comparator.compareRange(pos, clipEnd, a.active, b.active);
      }
      if (end > endB) break;
      pos = end;
      if (diff <= 0) a.next();
      if (diff >= 0) b.next();
    }
  }
  __name(compare, "compare");
  function sameValues(a, b) {
    if (a.length != b.length) return false;
    for (var i = 0; i < a.length; i++) if (a[i] != b[i] && !a[i].eq(b[i])) return false;
    return true;
  }
  __name(sameValues, "sameValues");
  function remove(array, index) {
    for (var i = index, e = array.length - 1; i < e; i++) array[i] = array[i + 1];
    array.pop();
  }
  __name(remove, "remove");
  function insert2(array, index, value) {
    for (var i = array.length - 1; i >= index; i--) array[i + 1] = array[i];
    array[index] = value;
  }
  __name(insert2, "insert");
  function findMinIndex(value, array) {
    var found = -1,
      foundPos = 1e9;
    for (var i = 0; i < array.length; i++)
      if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {
        found = i;
        foundPos = array[i];
      }
    return found;
  }
  __name(findMinIndex, "findMinIndex");
  function countColumn(string2, tabSize) {
    var to = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : string2.length;
    var n = 0;
    for (var i = 0; i < to; ) {
      if (string2.charCodeAt(i) == 9) {
        n += tabSize - (n % tabSize);
        i++;
      } else {
        n++;
        i = findClusterBreak(string2, i);
      }
    }
    return n;
  }
  __name(countColumn, "countColumn");
  function findColumn(string2, col, tabSize, strict) {
    for (var i = 0, n = 0; ; ) {
      if (n >= col) return i;
      if (i == string2.length) break;
      n += string2.charCodeAt(i) == 9 ? tabSize - (n % tabSize) : 1;
      i = findClusterBreak(string2, i);
    }
    return strict === true ? -1 : string2.length;
  }
  __name(findColumn, "findColumn");
  // node_modules/style-mod/src/style-mod.js
  var C = "";
  var COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
  var SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
  var top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
  var StyleModule = class StyleModule {
    getRules() {
      return this.rules.join("\n");
    }
    static newName() {
      var id = top[COUNT] || 1;
      top[COUNT] = id + 1;
      return C + id.toString(36);
    }
    static mount(root, modules) {
      (root[SET] || new StyleSet(root)).mount(Array.isArray(modules) ? modules : [modules]);
    }
    constructor(spec, options) {
      this.rules = [];
      var finish = (options || {}).finish;
      function splitSelector(selector) {
        return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
      }
      __name(splitSelector, "splitSelector");
      function render(selectors, spec2, target, isKeyframes) {
        var local = [],
          isAt = /^@(\w+)\b/.exec(selectors[0]),
          keyframes = isAt && isAt[1] == "keyframes";
        if (isAt && spec2 == null) return target.push(selectors[0] + ";");
        for (var prop in spec2) {
          var value = spec2[prop];
          if (/&/.test(prop)) {
            render(
              prop
                .split(/,\s*/)
                .map((part) => selectors.map((sel) => part.replace(/&/, sel)))
                .reduce((a, b) => a.concat(b)),
              value,
              target
            );
          } else if (value && typeof value == "object") {
            if (!isAt) throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
            render(splitSelector(prop), value, local, keyframes);
          } else if (value != null) {
            local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, (l) => "-" + l.toLowerCase()) + ": " + value + ";");
          }
        }
        if (local.length || keyframes) {
          target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
        }
      }
      __name(render, "render");
      for (var prop in spec) render(splitSelector(prop), spec[prop], this.rules);
    }
  };
  __name(StyleModule, "StyleModule");
  var adoptedSet = null;
  var StyleSet = class StyleSet {
    mount(modules) {
      var sheet = this.sheet;
      var pos = 0,
        j = 0;
      for (var i = 0; i < modules.length; i++) {
        var mod = modules[i],
          index = this.modules.indexOf(mod);
        if (index < j && index > -1) {
          this.modules.splice(index, 1);
          j--;
          index = -1;
        }
        if (index == -1) {
          this.modules.splice(j++, 0, mod);
          if (sheet) for (var k = 0; k < mod.rules.length; k++) sheet.insertRule(mod.rules[k], pos++);
        } else {
          while (j < index) pos += this.modules[j++].rules.length;
          pos += mod.rules.length;
          j++;
        }
      }
      if (!sheet) {
        var text2 = "";
        for (var i1 = 0; i1 < this.modules.length; i1++) text2 += this.modules[i1].getRules() + "\n";
        this.styleTag.textContent = text2;
      }
    }
    constructor(root) {
      if (!root.head && root.adoptedStyleSheets && typeof CSSStyleSheet != "undefined") {
        if (adoptedSet) {
          root.adoptedStyleSheets = [adoptedSet.sheet].concat(root.adoptedStyleSheets);
          return (root[SET] = adoptedSet);
        }
        this.sheet = new CSSStyleSheet();
        root.adoptedStyleSheets = [this.sheet].concat(root.adoptedStyleSheets);
        adoptedSet = this;
      } else {
        this.styleTag = (root.ownerDocument || root).createElement("style");
        var target = root.head || root;
        target.insertBefore(this.styleTag, target.firstChild);
      }
      this.modules = [];
      root[SET] = this;
    }
  };
  __name(StyleSet, "StyleSet");
  // node_modules/w3c-keyname/index.es.js
  var base = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'",
  };
  var shift = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"',
  };
  var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
  var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
  var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
  var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  var brokenModifierNames = mac || (chrome && +chrome[1] < 57);
  for (i1 = 0; i1 < 10; i1++) base[48 + i1] = base[96 + i1] = String(i1);
  var i1;
  for (i1 = 1; i1 <= 24; i1++) base[i1 + 111] = "F" + i1;
  var i1;
  for (i1 = 65; i1 <= 90; i1++) {
    base[i1] = String.fromCharCode(i1 + 32);
    shift[i1] = String.fromCharCode(i1);
  }
  var i1;
  for (code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];
  var code;
  function keyName(event) {
    var ignoreKey = (brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey)) || (ie && event.shiftKey && event.key && event.key.length == 1) || event.key == "Unidentified";
    var name2 = (!ignoreKey && event.key) || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
    if (name2 == "Esc") name2 = "Escape";
    if (name2 == "Del") name2 = "Delete";
    if (name2 == "Left") name2 = "ArrowLeft";
    if (name2 == "Up") name2 = "ArrowUp";
    if (name2 == "Right") name2 = "ArrowRight";
    if (name2 == "Down") name2 = "ArrowDown";
    return name2;
  }
  __name(keyName, "keyName");
  // node_modules/@codemirror/view/dist/index.js
  function getSelection(root) {
    var target;
    if (root.nodeType == 11) {
      target = root.getSelection ? root : root.ownerDocument;
    } else {
      target = root;
    }
    return target.getSelection();
  }
  __name(getSelection, "getSelection");
  function contains(dom, node) {
    return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
  }
  __name(contains, "contains");
  function deepActiveElement(doc2) {
    var elt = doc2.activeElement;
    while (elt && elt.shadowRoot) elt = elt.shadowRoot.activeElement;
    return elt;
  }
  __name(deepActiveElement, "deepActiveElement");
  function hasSelection(dom, selection) {
    if (!selection.anchorNode) return false;
    try {
      return contains(dom, selection.anchorNode);
    } catch (_) {
      return false;
    }
  }
  __name(hasSelection, "hasSelection");
  function clientRectsFor(dom) {
    if (dom.nodeType == 3) return textRange(dom, 0, dom.nodeValue.length).getClientRects();
    else if (dom.nodeType == 1) return dom.getClientRects();
    else return [];
  }
  __name(clientRectsFor, "clientRectsFor");
  function isEquivalentPosition(node, off, targetNode, targetOff) {
    return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;
  }
  __name(isEquivalentPosition, "isEquivalentPosition");
  function domIndex(node) {
    for (var index = 0; ; index++) {
      node = node.previousSibling;
      if (!node) return index;
    }
  }
  __name(domIndex, "domIndex");
  function scanFor(node, off, targetNode, targetOff, dir) {
    for (;;) {
      if (node == targetNode && off == targetOff) return true;
      if (off == (dir < 0 ? 0 : maxOffset(node))) {
        if (node.nodeName == "DIV") return false;
        var parent = node.parentNode;
        if (!parent || parent.nodeType != 1) return false;
        off = domIndex(node) + (dir < 0 ? 0 : 1);
        node = parent;
      } else if (node.nodeType == 1) {
        node = node.childNodes[off + (dir < 0 ? -1 : 0)];
        if (node.nodeType == 1 && node.contentEditable == "false") return false;
        off = dir < 0 ? maxOffset(node) : 0;
      } else {
        return false;
      }
    }
  }
  __name(scanFor, "scanFor");
  function maxOffset(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
  }
  __name(maxOffset, "maxOffset");
  var Rect0 = {
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
  };
  function flattenRect(rect, left) {
    var x = left ? rect.left : rect.right;
    return {
      left: x,
      right: x,
      top: rect.top,
      bottom: rect.bottom,
    };
  }
  __name(flattenRect, "flattenRect");
  function windowRect(win) {
    return {
      left: 0,
      right: win.innerWidth,
      top: 0,
      bottom: win.innerHeight,
    };
  }
  __name(windowRect, "windowRect");
  function scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {
    var doc2 = dom.ownerDocument,
      win = doc2.defaultView || window;
    for (var cur = dom; cur; ) {
      if (cur.nodeType == 1) {
        var bounding = void 0,
          top2 = cur == doc2.body;
        if (top2) {
          bounding = windowRect(win);
        } else {
          if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {
            cur = cur.assignedSlot || cur.parentNode;
            continue;
          }
          var rect2 = cur.getBoundingClientRect();
          bounding = {
            left: rect2.left,
            right: rect2.left + cur.clientWidth,
            top: rect2.top,
            bottom: rect2.top + cur.clientHeight,
          };
        }
        var moveX = 0,
          moveY = 0;
        if (y == "nearest") {
          if (rect.top < bounding.top) {
            moveY = -(bounding.top - rect.top + yMargin);
            if (side > 0 && rect.bottom > bounding.bottom + moveY) moveY = rect.bottom - bounding.bottom + moveY + yMargin;
          } else if (rect.bottom > bounding.bottom) {
            moveY = rect.bottom - bounding.bottom + yMargin;
            if (side < 0 && rect.top - moveY < bounding.top) moveY = -(bounding.top + moveY - rect.top + yMargin);
          }
        } else {
          var rectHeight = rect.bottom - rect.top,
            boundingHeight = bounding.bottom - bounding.top;
          var targetTop = y == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y == "start" || (y == "center" && side < 0) ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;
          moveY = targetTop - bounding.top;
        }
        if (x == "nearest") {
          if (rect.left < bounding.left) {
            moveX = -(bounding.left - rect.left + xMargin);
            if (side > 0 && rect.right > bounding.right + moveX) moveX = rect.right - bounding.right + moveX + xMargin;
          } else if (rect.right > bounding.right) {
            moveX = rect.right - bounding.right + xMargin;
            if (side < 0 && rect.left < bounding.left + moveX) moveX = -(bounding.left + moveX - rect.left + xMargin);
          }
        } else {
          var targetLeft = x == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : (x == "start") == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;
          moveX = targetLeft - bounding.left;
        }
        if (moveX || moveY) {
          if (top2) {
            win.scrollBy(moveX, moveY);
          } else {
            var movedX = 0,
              movedY = 0;
            if (moveY) {
              var start = cur.scrollTop;
              cur.scrollTop += moveY;
              movedY = cur.scrollTop - start;
            }
            if (moveX) {
              var start1 = cur.scrollLeft;
              cur.scrollLeft += moveX;
              movedX = cur.scrollLeft - start1;
            }
            rect = {
              left: rect.left - movedX,
              top: rect.top - movedY,
              right: rect.right - movedX,
              bottom: rect.bottom - movedY,
            };
            if (movedX && Math.abs(movedX - moveX) < 1) x = "nearest";
            if (movedY && Math.abs(movedY - moveY) < 1) y = "nearest";
          }
        }
        if (top2) break;
        cur = cur.assignedSlot || cur.parentNode;
      } else if (cur.nodeType == 11) {
        cur = cur.host;
      } else {
        break;
      }
    }
  }
  __name(scrollRectIntoView, "scrollRectIntoView");
  var DOMSelectionState = class DOMSelectionState {
    eq(domSel) {
      return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
    }
    setRange(range) {
      this.set(range.anchorNode, range.anchorOffset, range.focusNode, range.focusOffset);
    }
    set(anchorNode, anchorOffset, focusNode, focusOffset) {
      this.anchorNode = anchorNode;
      this.anchorOffset = anchorOffset;
      this.focusNode = focusNode;
      this.focusOffset = focusOffset;
    }
    constructor() {
      this.anchorNode = null;
      this.anchorOffset = 0;
      this.focusNode = null;
      this.focusOffset = 0;
    }
  };
  __name(DOMSelectionState, "DOMSelectionState");
  var preventScrollSupported = null;
  function focusPreventScroll(dom) {
    if (dom.setActive) return dom.setActive();
    if (preventScrollSupported) return dom.focus(preventScrollSupported);
    var stack = [];
    for (var cur = dom; cur; cur = cur.parentNode) {
      stack.push(cur, cur.scrollTop, cur.scrollLeft);
      if (cur == cur.ownerDocument) break;
    }
    dom.focus(
      preventScrollSupported == null
        ? {
            get preventScroll() {
              preventScrollSupported = {
                preventScroll: true,
              };
              return true;
            },
          }
        : void 0
    );
    if (!preventScrollSupported) {
      preventScrollSupported = false;
      for (var i = 0; i < stack.length; ) {
        var elt = stack[i++],
          top2 = stack[i++],
          left = stack[i++];
        if (elt.scrollTop != top2) elt.scrollTop = top2;
        if (elt.scrollLeft != left) elt.scrollLeft = left;
      }
    }
  }
  __name(focusPreventScroll, "focusPreventScroll");
  var scratchRange;
  function textRange(node, from) {
    var to = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : from;
    var range = scratchRange || (scratchRange = document.createRange());
    range.setEnd(node, to);
    range.setStart(node, from);
    return range;
  }
  __name(textRange, "textRange");
  function dispatchKey(elt, name2, code) {
    var options = {
      key: name2,
      code: name2,
      keyCode: code,
      which: code,
      cancelable: true,
    };
    var down = new KeyboardEvent("keydown", options);
    down.synthetic = true;
    elt.dispatchEvent(down);
    var up = new KeyboardEvent("keyup", options);
    up.synthetic = true;
    elt.dispatchEvent(up);
    return down.defaultPrevented || up.defaultPrevented;
  }
  __name(dispatchKey, "dispatchKey");
  function getRoot(node) {
    while (node) {
      if (node && (node.nodeType == 9 || (node.nodeType == 11 && node.host))) return node;
      node = node.assignedSlot || node.parentNode;
    }
    return null;
  }
  __name(getRoot, "getRoot");
  function clearAttributes(node) {
    while (node.attributes.length) node.removeAttributeNode(node.attributes[0]);
  }
  __name(clearAttributes, "clearAttributes");
  function atElementStart(doc2, selection) {
    var node = selection.focusNode,
      offset = selection.focusOffset;
    if (!node || selection.anchorNode != node || selection.anchorOffset != offset) return false;
    for (;;) {
      if (offset) {
        if (node.nodeType != 1) return false;
        var prev = node.childNodes[offset - 1];
        if (prev.contentEditable == "false") offset--;
        else {
          node = prev;
          offset = maxOffset(node);
        }
      } else if (node == doc2) {
        return true;
      } else {
        offset = domIndex(node);
        node = node.parentNode;
      }
    }
  }
  __name(atElementStart, "atElementStart");
  var DOMPos = class DOMPos1 {
    static before(dom, precise) {
      return new DOMPos(dom.parentNode, domIndex(dom), precise);
    }
    static after(dom, precise) {
      return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
    }
    constructor(node, offset, ref) {
      var precise = ref === void 0 ? true : ref;
      this.node = node;
      this.offset = offset;
      this.precise = precise;
    }
  };
  __name(DOMPos, "DOMPos");
  var noChildren = [];
  var ContentView = class ContentView1 {
    get editorView() {
      if (!this.parent) throw new Error("Accessing view in orphan content view");
      return this.parent.editorView;
    }
    get overrideDOMText() {
      return null;
    }
    get posAtStart() {
      return this.parent ? this.parent.posBefore(this) : 0;
    }
    get posAtEnd() {
      return this.posAtStart + this.length;
    }
    posBefore(view) {
      var pos = this.posAtStart;
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var child = _step.value;
          if (child == view) return pos;
          pos += child.length + child.breakAfter;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      throw new RangeError("Invalid child in posBefore");
    }
    posAfter(view) {
      return this.posBefore(view) + view.length;
    }
    coordsAt(_pos, _side) {
      return null;
    }
    sync(track) {
      if (this.dirty & 2) {
        var parent = this.dom;
        var prev = null,
          next;
        var _iteratorNormalCompletion = true,
          _didIteratorError = false,
          _iteratorError = undefined;
        try {
          for (var _iterator = this.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var child = _step.value;
            if (child.dirty) {
              if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
                var contentView = ContentView.get(next);
                if (!contentView || (!contentView.parent && contentView.canReuseDOM(child))) child.reuseDOM(next);
              }
              child.sync(track);
              child.dirty = 0;
            }
            next = prev ? prev.nextSibling : parent.firstChild;
            if (track && !track.written && track.node == parent && next != child.dom) track.written = true;
            if (child.dom.parentNode == parent) {
              while (next && next != child.dom) next = rm$1(next);
            } else {
              parent.insertBefore(child.dom, next);
            }
            prev = child.dom;
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        next = prev ? prev.nextSibling : parent.firstChild;
        if (next && track && track.node == parent) track.written = true;
        while (next) next = rm$1(next);
      } else if (this.dirty & 1) {
        var _iteratorNormalCompletion1 = true,
          _didIteratorError1 = false,
          _iteratorError1 = undefined;
        try {
          for (var _iterator1 = this.children[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
            var child1 = _step1.value;
            if (child1.dirty) {
              child1.sync(track);
              child1.dirty = 0;
            }
          }
        } catch (err) {
          _didIteratorError1 = true;
          _iteratorError1 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
              _iterator1.return();
            }
          } finally {
            if (_didIteratorError1) {
              throw _iteratorError1;
            }
          }
        }
      }
    }
    reuseDOM(_dom) {}
    localPosFromDOM(node, offset) {
      var after;
      if (node == this.dom) {
        after = this.dom.childNodes[offset];
      } else {
        var bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
        for (;;) {
          var parent = node.parentNode;
          if (parent == this.dom) break;
          if (bias == 0 && parent.firstChild != parent.lastChild) {
            if (node == parent.firstChild) bias = -1;
            else bias = 1;
          }
          node = parent;
        }
        if (bias < 0) after = node;
        else after = node.nextSibling;
      }
      if (after == this.dom.firstChild) return 0;
      while (after && !ContentView.get(after)) after = after.nextSibling;
      if (!after) return this.length;
      for (var i = 0, pos = 0; ; i++) {
        var child = this.children[i];
        if (child.dom == after) return pos;
        pos += child.length + child.breakAfter;
      }
    }
    domBoundsAround(from, to) {
      var offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var fromI = -1,
        fromStart = -1,
        toI = -1,
        toEnd = -1;
      for (var i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {
        var child = this.children[i],
          end = pos + child.length;
        if (pos < from && end > to) return child.domBoundsAround(from, to, pos);
        if (end >= from && fromI == -1) {
          fromI = i;
          fromStart = pos;
        }
        if (pos > to && child.dom.parentNode == this.dom) {
          toI = i;
          toEnd = prevEnd;
          break;
        }
        prevEnd = end;
        pos = end + child.breakAfter;
      }
      return {
        from: fromStart,
        to: toEnd < 0 ? offset + this.length : toEnd,
        startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
        endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null,
      };
    }
    markDirty() {
      var andParent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      this.dirty |= 2;
      this.markParentsDirty(andParent);
    }
    markParentsDirty(childList) {
      for (var parent = this.parent; parent; parent = parent.parent) {
        if (childList) parent.dirty |= 2;
        if (parent.dirty & 1) return;
        parent.dirty |= 1;
        childList = false;
      }
    }
    setParent(parent) {
      if (this.parent != parent) {
        this.parent = parent;
        if (this.dirty) this.markParentsDirty(true);
      }
    }
    setDOM(dom) {
      if (this.dom) this.dom.cmView = null;
      this.dom = dom;
      dom.cmView = this;
    }
    get rootView() {
      for (var v = this; ; ) {
        var parent = v.parent;
        if (!parent) return v;
        v = parent;
      }
    }
    replaceChildren(from, to) {
      var children2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : noChildren;
      this.markDirty();
      for (var i = from; i < to; i++) {
        var child = this.children[i];
        if (child.parent == this) child.destroy();
      }
      this.children.splice(from, to - from, ...children2);
      for (var i1 = 0; i1 < children2.length; i1++) children2[i1].setParent(this);
    }
    ignoreMutation(_rec) {
      return false;
    }
    ignoreEvent(_event) {
      return false;
    }
    childCursor() {
      var pos = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.length;
      return new ChildCursor(this.children, pos, this.children.length);
    }
    childPos(pos) {
      var bias = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      return this.childCursor().findPos(pos, bias);
    }
    toString() {
      var name2 = this.constructor.name.replace("View", "");
      return name2 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name2 == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
    }
    static get(node) {
      return node.cmView;
    }
    get isEditable() {
      return true;
    }
    merge(from, to, source, hasStart, openStart, openEnd) {
      return false;
    }
    become(other) {
      return false;
    }
    canReuseDOM(other) {
      return other.constructor == this.constructor;
    }
    getSide() {
      return 0;
    }
    destroy() {
      this.parent = null;
    }
    constructor() {
      this.parent = null;
      this.dom = null;
      this.dirty = 2;
    }
  };
  __name(ContentView, "ContentView");
  ContentView.prototype.breakAfter = 0;
  function rm$1(dom) {
    var next = dom.nextSibling;
    dom.parentNode.removeChild(dom);
    return next;
  }
  __name(rm$1, "rm$1");
  var ChildCursor = class ChildCursor {
    findPos(pos) {
      var bias = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      for (;;) {
        if (pos > this.pos || (pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))) {
          this.off = pos - this.pos;
          return this;
        }
        var next = this.children[--this.i];
        this.pos -= next.length + next.breakAfter;
      }
    }
    constructor(children2, pos, i) {
      this.children = children2;
      this.pos = pos;
      this.i = i;
      this.off = 0;
    }
  };
  __name(ChildCursor, "ChildCursor");
  function replaceRange(parent, fromI, fromOff, toI, toOff, insert3, breakAtStart, openStart, openEnd) {
    var children2 = parent.children;
    var before = children2.length ? children2[fromI] : null;
    var last = insert3.length ? insert3[insert3.length - 1] : null;
    var breakAtEnd = last ? last.breakAfter : breakAtStart;
    if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert3.length < 2 && before.merge(fromOff, toOff, insert3.length ? last : null, fromOff == 0, openStart, openEnd)) return;
    if (toI < children2.length) {
      var after = children2[toI];
      if (after && toOff < after.length) {
        if (fromI == toI) {
          after = after.split(toOff);
          toOff = 0;
        }
        if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
          insert3[insert3.length - 1] = after;
        } else {
          if (toOff) after.merge(0, toOff, null, false, 0, openEnd);
          insert3.push(after);
        }
      } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
        if (last) last.breakAfter = 1;
        else breakAtStart = 1;
      }
      toI++;
    }
    if (before) {
      before.breakAfter = breakAtStart;
      if (fromOff > 0) {
        if (!breakAtStart && insert3.length && before.merge(fromOff, before.length, insert3[0], false, openStart, 0)) {
          before.breakAfter = insert3.shift().breakAfter;
        } else if (fromOff < before.length || (before.children.length && before.children[before.children.length - 1].length == 0)) {
          before.merge(fromOff, before.length, null, false, openStart, 0);
        }
        fromI++;
      }
    }
    while (fromI < toI && insert3.length) {
      if (children2[toI - 1].become(insert3[insert3.length - 1])) {
        toI--;
        insert3.pop();
        openEnd = insert3.length ? 0 : openStart;
      } else if (children2[fromI].become(insert3[0])) {
        fromI++;
        insert3.shift();
        openStart = insert3.length ? 0 : openEnd;
      } else {
        break;
      }
    }
    if (!insert3.length && fromI && toI < children2.length && !children2[fromI - 1].breakAfter && children2[toI].merge(0, 0, children2[fromI - 1], false, openStart, openEnd)) fromI--;
    if (fromI < toI || insert3.length) parent.replaceChildren(fromI, toI, insert3);
  }
  __name(replaceRange, "replaceRange");
  function mergeChildrenInto(parent, from, to, insert3, openStart, openEnd) {
    var cur = parent.childCursor();
    var _cur_findPos = cur.findPos(to, 1),
      toI = _cur_findPos.i,
      toOff = _cur_findPos.off;
    var _cur_findPos1 = cur.findPos(from, -1),
      fromI = _cur_findPos1.i,
      fromOff = _cur_findPos1.off;
    var dLen = from - to;
    var _iteratorNormalCompletion = true,
      _didIteratorError = false,
      _iteratorError = undefined;
    try {
      for (var _iterator = insert3[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var view = _step.value;
        dLen += view.length;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    parent.length += dLen;
    replaceRange(parent, fromI, fromOff, toI, toOff, insert3, 0, openStart, openEnd);
  }
  __name(mergeChildrenInto, "mergeChildrenInto");
  var nav =
    typeof navigator != "undefined"
      ? navigator
      : {
          userAgent: "",
          vendor: "",
          platform: "",
        };
  var doc =
    typeof document != "undefined"
      ? document
      : {
          documentElement: {
            style: {},
          },
        };
  var ie_edge = /* @__PURE__ */ /Edge\/(\d+)/.exec(nav.userAgent);
  var ie_upto10 = /* @__PURE__ */ /MSIE \d/.test(nav.userAgent);
  var ie_11up = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
  var ie2 = !!(ie_upto10 || ie_11up || ie_edge);
  var gecko2 = !ie2 && /* @__PURE__ */ /gecko\/(\d+)/i.test(nav.userAgent);
  var chrome2 = !ie2 && /* @__PURE__ */ /Chrome\/(\d+)/.exec(nav.userAgent);
  var webkit = "webkitFontSmoothing" in doc.documentElement.style;
  var safari = !ie2 && /* @__PURE__ */ /Apple Computer/.test(nav.vendor);
  var ios = safari && /* @__PURE__ */ (/Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
  var browser = {
    mac: ios || /* @__PURE__ */ /Mac/.test(nav.platform),
    windows: /* @__PURE__ */ /Win/.test(nav.platform),
    linux: /* @__PURE__ */ /Linux|X11/.test(nav.platform),
    ie: ie2,
    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
    gecko: gecko2,
    gecko_version: gecko2 ? +(/* @__PURE__ */ (/Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1]) : 0,
    chrome: !!chrome2,
    chrome_version: chrome2 ? +chrome2[1] : 0,
    ios,
    android: /* @__PURE__ */ /Android\b/.test(nav.userAgent),
    webkit,
    safari,
    webkit_version: webkit ? +(/* @__PURE__ */ (/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1]) : 0,
    tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size",
  };
  var MaxJoinLen = 256;
  var TextView = class TextView1 extends ContentView {
    get length() {
      return this.text.length;
    }
    createDOM(textDOM) {
      this.setDOM(textDOM || document.createTextNode(this.text));
    }
    sync(track) {
      if (!this.dom) this.createDOM();
      if (this.dom.nodeValue != this.text) {
        if (track && track.node == this.dom) track.written = true;
        this.dom.nodeValue = this.text;
      }
    }
    reuseDOM(dom) {
      if (dom.nodeType == 3) this.createDOM(dom);
    }
    merge(from, to, source) {
      if (source && (!(source instanceof TextView) || this.length - (to - from) + source.length > MaxJoinLen)) return false;
      this.text = this.text.slice(0, from) + (source ? source.text : "") + this.text.slice(to);
      this.markDirty();
      return true;
    }
    split(from) {
      var result = new TextView(this.text.slice(from));
      this.text = this.text.slice(0, from);
      this.markDirty();
      return result;
    }
    localPosFromDOM(node, offset) {
      return node == this.dom ? offset : offset ? this.text.length : 0;
    }
    domAtPos(pos) {
      return new DOMPos(this.dom, pos);
    }
    domBoundsAround(_from, _to, offset) {
      return {
        from: offset,
        to: offset + this.length,
        startDOM: this.dom,
        endDOM: this.dom.nextSibling,
      };
    }
    coordsAt(pos, side) {
      return textCoords(this.dom, pos, side);
    }
    constructor(text2) {
      super();
      this.text = text2;
    }
  };
  __name(TextView, "TextView");
  var MarkView = class MarkView1 extends ContentView {
    setAttrs(dom) {
      clearAttributes(dom);
      if (this.mark.class) dom.className = this.mark.class;
      if (this.mark.attrs) for (var name2 in this.mark.attrs) dom.setAttribute(name2, this.mark.attrs[name2]);
      return dom;
    }
    reuseDOM(node) {
      if (node.nodeName == this.mark.tagName.toUpperCase()) {
        this.setDOM(node);
        this.dirty |= 4 | 2;
      }
    }
    sync(track) {
      if (!this.dom) this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
      else if (this.dirty & 4) this.setAttrs(this.dom);
      super.sync(track);
    }
    merge(from, to, source, _hasStart, openStart, openEnd) {
      if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) || (from && openStart <= 0) || (to < this.length && openEnd <= 0))) return false;
      mergeChildrenInto(this, from, to, source ? source.children : [], openStart - 1, openEnd - 1);
      this.markDirty();
      return true;
    }
    split(from) {
      var result = [],
        off = 0,
        detachFrom = -1,
        i = 0;
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var elt = _step.value;
          var end = off + elt.length;
          if (end > from) result.push(off < from ? elt.split(from - off) : elt);
          if (detachFrom < 0 && off >= from) detachFrom = i;
          off = end;
          i++;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      var length = this.length - from;
      this.length = from;
      if (detachFrom > -1) {
        this.children.length = detachFrom;
        this.markDirty();
      }
      return new MarkView(this.mark, result, length);
    }
    domAtPos(pos) {
      return inlineDOMAtPos(this, pos);
    }
    coordsAt(pos, side) {
      return coordsInChildren(this, pos, side);
    }
    constructor(mark, ref, ref1) {
      var children2 = ref === void 0 ? [] : ref,
        length = ref1 === void 0 ? 0 : ref1;
      super();
      this.mark = mark;
      this.children = children2;
      this.length = length;
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = children2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var ch = _step.value;
          ch.setParent(this);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  };
  __name(MarkView, "MarkView");
  function textCoords(text2, pos, side) {
    var length = text2.nodeValue.length;
    if (pos > length) pos = length;
    var from = pos,
      to = pos,
      flatten2 = 0;
    if ((pos == 0 && side < 0) || (pos == length && side >= 0)) {
      if (!(browser.chrome || browser.gecko)) {
        if (pos) {
          from--;
          flatten2 = 1;
        } else if (to < length) {
          to++;
          flatten2 = -1;
        }
      }
    } else {
      if (side < 0) from--;
      else if (to < length) to++;
    }
    var rects = textRange(text2, from, to).getClientRects();
    if (!rects.length) return Rect0;
    var rect = rects[(flatten2 ? flatten2 < 0 : side >= 0) ? 0 : rects.length - 1];
    if (browser.safari && !flatten2 && rect.width == 0) rect = Array.prototype.find.call(rects, (r) => r.width) || rect;
    return flatten2 ? flattenRect(rect, flatten2 < 0) : rect || null;
  }
  __name(textCoords, "textCoords");
  var WidgetView = class WidgetView1 extends ContentView {
    static create(widget, length, side) {
      return new (widget.customView || WidgetView)(widget, length, side);
    }
    split(from) {
      var result = WidgetView.create(this.widget, this.length - from, this.side);
      this.length -= from;
      return result;
    }
    sync() {
      if (!this.dom || !this.widget.updateDOM(this.dom)) {
        if (this.dom && this.prevWidget) this.prevWidget.destroy(this.dom);
        this.prevWidget = null;
        this.setDOM(this.widget.toDOM(this.editorView));
        this.dom.contentEditable = "false";
      }
    }
    getSide() {
      return this.side;
    }
    merge(from, to, source, hasStart, openStart, openEnd) {
      if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) || (from > 0 && openStart <= 0) || (to < this.length && openEnd <= 0))) return false;
      this.length = from + (source ? source.length : 0) + (this.length - to);
      return true;
    }
    become(other) {
      if (other.length == this.length && other instanceof WidgetView && other.side == this.side) {
        if (this.widget.constructor == other.widget.constructor) {
          if (!this.widget.eq(other.widget)) this.markDirty(true);
          if (this.dom && !this.prevWidget) this.prevWidget = this.widget;
          this.widget = other.widget;
          return true;
        }
      }
      return false;
    }
    ignoreMutation() {
      return true;
    }
    ignoreEvent(event) {
      return this.widget.ignoreEvent(event);
    }
    get overrideDOMText() {
      if (this.length == 0) return Text.empty;
      var top2 = this;
      while (top2.parent) top2 = top2.parent;
      var view = top2.editorView,
        text2 = view && view.state.doc,
        start = this.posAtStart;
      return text2 ? text2.slice(start, start + this.length) : Text.empty;
    }
    domAtPos(pos) {
      return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    domBoundsAround() {
      return null;
    }
    coordsAt(pos, side) {
      var rects = this.dom.getClientRects(),
        rect = null;
      if (!rects.length) return Rect0;
      for (var i = pos > 0 ? rects.length - 1 : 0; ; i += pos > 0 ? -1 : 1) {
        rect = rects[i];
        if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom) break;
      }
      return this.length ? rect : flattenRect(rect, this.side > 0);
    }
    get isEditable() {
      return false;
    }
    destroy() {
      super.destroy();
      if (this.dom) this.widget.destroy(this.dom);
    }
    constructor(widget, length, side) {
      super();
      this.widget = widget;
      this.length = length;
      this.side = side;
      this.prevWidget = null;
    }
  };
  __name(WidgetView, "WidgetView");
  var CompositionView = class CompositionView extends WidgetView {
    domAtPos(pos) {
      var _this_widget = this.widget,
        topView = _this_widget.topView,
        text2 = _this_widget.text;
      if (!topView) return new DOMPos(text2, Math.min(pos, text2.nodeValue.length));
      return scanCompositionTree(
        pos,
        0,
        topView,
        text2,
        (v, p) => v.domAtPos(p),
        (p) => new DOMPos(text2, Math.min(p, text2.nodeValue.length))
      );
    }
    sync() {
      this.setDOM(this.widget.toDOM());
    }
    localPosFromDOM(node, offset) {
      var _this_widget = this.widget,
        topView = _this_widget.topView,
        text2 = _this_widget.text;
      if (!topView) return Math.min(offset, this.length);
      return posFromDOMInCompositionTree(node, offset, topView, text2);
    }
    ignoreMutation() {
      return false;
    }
    get overrideDOMText() {
      return null;
    }
    coordsAt(pos, side) {
      var _this_widget = this.widget,
        topView = _this_widget.topView,
        text2 = _this_widget.text;
      if (!topView) return textCoords(text2, pos, side);
      return scanCompositionTree(
        pos,
        side,
        topView,
        text2,
        (v, pos2, side2) => v.coordsAt(pos2, side2),
        (pos2, side2) => textCoords(text2, pos2, side2)
      );
    }
    destroy() {
      var _a2;
      super.destroy();
      (_a2 = this.widget.topView) === null || _a2 === void 0 ? void 0 : _a2.destroy();
    }
    get isEditable() {
      return true;
    }
    canReuseDOM() {
      return true;
    }
  };
  __name(CompositionView, "CompositionView");
  function scanCompositionTree(pos, side, view, text2, enterView, fromText) {
    if (view instanceof MarkView) {
      for (var child = view.dom.firstChild; child; child = child.nextSibling) {
        var desc = ContentView.get(child);
        if (!desc) return fromText(pos, side);
        var hasComp = contains(child, text2);
        var len = desc.length + (hasComp ? text2.nodeValue.length : 0);
        if (pos < len || (pos == len && desc.getSide() <= 0)) return hasComp ? scanCompositionTree(pos, side, desc, text2, enterView, fromText) : enterView(desc, pos, side);
        pos -= len;
      }
      return enterView(view, view.length, -1);
    } else if (view.dom == text2) {
      return fromText(pos, side);
    } else {
      return enterView(view, pos, side);
    }
  }
  __name(scanCompositionTree, "scanCompositionTree");
  function posFromDOMInCompositionTree(node, offset, view, text2) {
    if (view instanceof MarkView) {
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = view.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var child = _step.value;
          var pos = 0,
            hasComp = contains(child.dom, text2);
          if (contains(child.dom, node)) return pos + (hasComp ? posFromDOMInCompositionTree(node, offset, child, text2) : child.localPosFromDOM(node, offset));
          pos += hasComp ? text2.nodeValue.length : child.length;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    } else if (view.dom == text2) {
      return Math.min(offset, text2.nodeValue.length);
    }
    return view.localPosFromDOM(node, offset);
  }
  __name(posFromDOMInCompositionTree, "posFromDOMInCompositionTree");
  var WidgetBufferView = class WidgetBufferView1 extends ContentView {
    get length() {
      return 0;
    }
    merge() {
      return false;
    }
    become(other) {
      return other instanceof WidgetBufferView && other.side == this.side;
    }
    split() {
      return new WidgetBufferView(this.side);
    }
    sync() {
      if (!this.dom) {
        var dom = document.createElement("img");
        dom.className = "cm-widgetBuffer";
        dom.setAttribute("aria-hidden", "true");
        this.setDOM(dom);
      }
    }
    getSide() {
      return this.side;
    }
    domAtPos(pos) {
      return DOMPos.before(this.dom);
    }
    localPosFromDOM() {
      return 0;
    }
    domBoundsAround() {
      return null;
    }
    coordsAt(pos) {
      var imgRect = this.dom.getBoundingClientRect();
      var siblingRect = inlineSiblingRect(this, this.side > 0 ? -1 : 1);
      return siblingRect && siblingRect.top < imgRect.bottom && siblingRect.bottom > imgRect.top
        ? {
            left: imgRect.left,
            right: imgRect.right,
            top: siblingRect.top,
            bottom: siblingRect.bottom,
          }
        : imgRect;
    }
    get overrideDOMText() {
      return Text.empty;
    }
    constructor(side) {
      super();
      this.side = side;
    }
  };
  __name(WidgetBufferView, "WidgetBufferView");
  TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
  function inlineSiblingRect(view, side) {
    var parent = view.parent,
      index = parent ? parent.children.indexOf(view) : -1;
    while (parent && index >= 0) {
      if (side < 0 ? index > 0 : index < parent.children.length) {
        var next = parent.children[index + side];
        if (next instanceof TextView) {
          var nextRect = next.coordsAt(side < 0 ? next.length : 0, side);
          if (nextRect) return nextRect;
        }
        index += side;
      } else if (parent instanceof MarkView && parent.parent) {
        index = parent.parent.children.indexOf(parent) + (side < 0 ? 0 : 1);
        parent = parent.parent;
      } else {
        var last = parent.dom.lastChild;
        if (last && last.nodeName == "BR") return last.getClientRects()[0];
        break;
      }
    }
    return void 0;
  }
  __name(inlineSiblingRect, "inlineSiblingRect");
  function inlineDOMAtPos(parent, pos) {
    var dom = parent.dom,
      children2 = parent.children,
      i = 0;
    for (var off = 0; i < children2.length; i++) {
      var child = children2[i],
        end = off + child.length;
      if (end == off && child.getSide() <= 0) continue;
      if (pos > off && pos < end && child.dom.parentNode == dom) return child.domAtPos(pos - off);
      if (pos <= off) break;
      off = end;
    }
    for (var j = i; j > 0; j--) {
      var prev = children2[j - 1];
      if (prev.dom.parentNode == dom) return prev.domAtPos(prev.length);
    }
    for (var j1 = i; j1 < children2.length; j1++) {
      var next = children2[j1];
      if (next.dom.parentNode == dom) return next.domAtPos(0);
    }
    return new DOMPos(dom, 0);
  }
  __name(inlineDOMAtPos, "inlineDOMAtPos");
  function joinInlineInto(parent, view, open) {
    var last,
      children2 = parent.children;
    if (open > 0 && view instanceof MarkView && children2.length && (last = children2[children2.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {
      joinInlineInto(last, view.children[0], open - 1);
    } else {
      children2.push(view);
      view.setParent(parent);
    }
    parent.length += view.length;
  }
  __name(joinInlineInto, "joinInlineInto");
  function coordsInChildren(view, pos, side) {
    var before = null,
      beforePos = -1,
      after = null,
      afterPos = -1;
    function scan(view2, pos2) {
      for (var i = 0, off = 0; i < view2.children.length && off <= pos2; i++) {
        var child = view2.children[i],
          end = off + child.length;
        if (end >= pos2) {
          if (child.children.length) {
            scan(child, pos2 - off);
          } else if (!after && (end > pos2 || (off == end && child.getSide() > 0))) {
            after = child;
            afterPos = pos2 - off;
          } else if (off < pos2 || (off == end && child.getSide() < 0)) {
            before = child;
            beforePos = pos2 - off;
          }
        }
        off = end;
      }
    }
    __name(scan, "scan");
    scan(view, pos);
    var target = (side < 0 ? before : after) || before || after;
    if (target) return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);
    return fallbackRect(view);
  }
  __name(coordsInChildren, "coordsInChildren");
  function fallbackRect(view) {
    var last = view.dom.lastChild;
    if (!last) return view.dom.getBoundingClientRect();
    var rects = clientRectsFor(last);
    return rects[rects.length - 1] || null;
  }
  __name(fallbackRect, "fallbackRect");
  function combineAttrs(source, target) {
    for (var name2 in source) {
      if (name2 == "class" && target.class) target.class += " " + source.class;
      else if (name2 == "style" && target.style) target.style += ";" + source.style;
      else target[name2] = source[name2];
    }
    return target;
  }
  __name(combineAttrs, "combineAttrs");
  function attrsEq(a, b) {
    if (a == b) return true;
    if (!a || !b) return false;
    var keysA = Object.keys(a),
      keysB = Object.keys(b);
    if (keysA.length != keysB.length) return false;
    var _iteratorNormalCompletion = true,
      _didIteratorError = false,
      _iteratorError = undefined;
    try {
      for (var _iterator = keysA[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var key = _step.value;
        if (keysB.indexOf(key) == -1 || a[key] !== b[key]) return false;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    return true;
  }
  __name(attrsEq, "attrsEq");
  function updateAttrs(dom, prev, attrs) {
    var changed = null;
    if (prev) {
      for (var name2 in prev) if (!(attrs && name2 in attrs)) dom.removeAttribute((changed = name2));
    }
    if (attrs) {
      for (var name21 in attrs) if (!(prev && prev[name21] == attrs[name21])) dom.setAttribute((changed = name21), attrs[name21]);
    }
    return !!changed;
  }
  __name(updateAttrs, "updateAttrs");
  var WidgetType = class WidgetType {
    eq(widget) {
      return false;
    }
    updateDOM(dom) {
      return false;
    }
    compare(other) {
      return this == other || (this.constructor == other.constructor && this.eq(other));
    }
    get estimatedHeight() {
      return -1;
    }
    ignoreEvent(event) {
      return true;
    }
    get customView() {
      return null;
    }
    destroy(dom) {}
  };
  __name(WidgetType, "WidgetType");
  var BlockType = /* @__PURE__ */ (function (BlockType2) {
    BlockType2[(BlockType2["Text"] = 0)] = "Text";
    BlockType2[(BlockType2["WidgetBefore"] = 1)] = "WidgetBefore";
    BlockType2[(BlockType2["WidgetAfter"] = 2)] = "WidgetAfter";
    BlockType2[(BlockType2["WidgetRange"] = 3)] = "WidgetRange";
    return BlockType2;
  })(BlockType || (BlockType = {}));
  var Decoration = class Decoration extends RangeValue {
    get heightRelevant() {
      return false;
    }
    static mark(spec) {
      return new MarkDecoration(spec);
    }
    static widget(spec) {
      var side = spec.side || 0,
        block = !!spec.block;
      side += block ? (side > 0 ? 3e8 : -4e8) : side > 0 ? 1e8 : -1e8;
      return new PointDecoration(spec, side, side, block, spec.widget || null, false);
    }
    static replace(spec) {
      var block = !!spec.block,
        startSide,
        endSide;
      if (spec.isBlockGap) {
        startSide = -5e8;
        endSide = 4e8;
      } else {
        var _getInclusive = getInclusive(spec, block),
          start = _getInclusive.start,
          end = _getInclusive.end;
        startSide = (start ? (block ? -3e8 : -1) : 5e8) - 1;
        endSide = (end ? (block ? 2e8 : 1) : -6e8) + 1;
      }
      return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
    }
    static line(spec) {
      return new LineDecoration(spec);
    }
    static set(of) {
      var sort = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return RangeSet.of(of, sort);
    }
    hasHeight() {
      return this.widget ? this.widget.estimatedHeight > -1 : false;
    }
    constructor(startSide, endSide, widget, spec) {
      super();
      this.startSide = startSide;
      this.endSide = endSide;
      this.widget = widget;
      this.spec = spec;
    }
  };
  __name(Decoration, "Decoration");
  Decoration.none = RangeSet.empty;
  var MarkDecoration = class MarkDecoration1 extends Decoration {
    eq(other) {
      return this == other || (other instanceof MarkDecoration && this.tagName == other.tagName && this.class == other.class && attrsEq(this.attrs, other.attrs));
    }
    range(from) {
      var to = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : from;
      if (from >= to) throw new RangeError("Mark decorations may not be empty");
      return super.range(from, to);
    }
    constructor(spec) {
      var _getInclusive = getInclusive(spec),
        start = _getInclusive.start,
        end = _getInclusive.end;
      super(start ? -1 : 5e8, end ? 1 : -6e8, null, spec);
      this.tagName = spec.tagName || "span";
      this.class = spec.class || "";
      this.attrs = spec.attributes || null;
    }
  };
  __name(MarkDecoration, "MarkDecoration");
  MarkDecoration.prototype.point = false;
  var LineDecoration = class LineDecoration1 extends Decoration {
    eq(other) {
      return other instanceof LineDecoration && attrsEq(this.spec.attributes, other.spec.attributes);
    }
    range(from) {
      var to = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : from;
      if (to != from) throw new RangeError("Line decoration ranges must be zero-length");
      return super.range(from, to);
    }
    constructor(spec) {
      super(-2e8, -2e8, null, spec);
    }
  };
  __name(LineDecoration, "LineDecoration");
  LineDecoration.prototype.mapMode = MapMode.TrackBefore;
  LineDecoration.prototype.point = true;
  var PointDecoration = class PointDecoration1 extends Decoration {
    get type() {
      return this.startSide < this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
    }
    get heightRelevant() {
      return this.block || (!!this.widget && this.widget.estimatedHeight >= 5);
    }
    eq(other) {
      return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
    }
    range(from) {
      var to = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : from;
      if (this.isReplace && (from > to || (from == to && this.startSide > 0 && this.endSide <= 0))) throw new RangeError("Invalid range for replacement decoration");
      if (!this.isReplace && to != from) throw new RangeError("Widget decorations can only have zero-length ranges");
      return super.range(from, to);
    }
    constructor(spec, startSide, endSide, block, widget, isReplace) {
      super(startSide, endSide, widget, spec);
      this.block = block;
      this.isReplace = isReplace;
      this.mapMode = !block ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
    }
  };
  __name(PointDecoration, "PointDecoration");
  PointDecoration.prototype.point = true;
  function getInclusive(spec) {
    var block = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var start = spec.inclusiveStart,
      end = spec.inclusiveEnd;
    if (start == null) start = spec.inclusive;
    if (end == null) end = spec.inclusive;
    return {
      start: start !== null && start !== void 0 ? start : block,
      end: end !== null && end !== void 0 ? end : block,
    };
  }
  __name(getInclusive, "getInclusive");
  function widgetsEq(a, b) {
    return a == b || !!(a && b && a.compare(b));
  }
  __name(widgetsEq, "widgetsEq");
  function addRange(from, to, ranges) {
    var margin = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    var last = ranges.length - 1;
    if (last >= 0 && ranges[last] + margin >= from) ranges[last] = Math.max(ranges[last], to);
    else ranges.push(from, to);
  }
  __name(addRange, "addRange");
  var LineView = class LineView1 extends ContentView {
    merge(from, to, source, hasStart, openStart, openEnd) {
      if (source) {
        if (!(source instanceof LineView)) return false;
        if (!this.dom) source.transferDOM(this);
      }
      if (hasStart) this.setDeco(source ? source.attrs : null);
      mergeChildrenInto(this, from, to, source ? source.children : [], openStart, openEnd);
      return true;
    }
    split(at) {
      var end = new LineView();
      end.breakAfter = this.breakAfter;
      if (this.length == 0) return end;
      var _this_childPos = this.childPos(at),
        i = _this_childPos.i,
        off = _this_childPos.off;
      if (off) {
        end.append(this.children[i].split(off), 0);
        this.children[i].merge(off, this.children[i].length, null, false, 0, 0);
        i++;
      }
      for (var j = i; j < this.children.length; j++) end.append(this.children[j], 0);
      while (i > 0 && this.children[i - 1].length == 0) this.children[--i].destroy();
      this.children.length = i;
      this.markDirty();
      this.length = at;
      return end;
    }
    transferDOM(other) {
      if (!this.dom) return;
      this.markDirty();
      other.setDOM(this.dom);
      other.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs;
      this.prevAttrs = void 0;
      this.dom = null;
    }
    setDeco(attrs) {
      if (!attrsEq(this.attrs, attrs)) {
        if (this.dom) {
          this.prevAttrs = this.attrs;
          this.markDirty();
        }
        this.attrs = attrs;
      }
    }
    append(child, openStart) {
      joinInlineInto(this, child, openStart);
    }
    addLineDeco(deco) {
      var attrs = deco.spec.attributes,
        cls = deco.spec.class;
      if (attrs) this.attrs = combineAttrs(attrs, this.attrs || {});
      if (cls)
        this.attrs = combineAttrs(
          {
            class: cls,
          },
          this.attrs || {}
        );
    }
    domAtPos(pos) {
      return inlineDOMAtPos(this, pos);
    }
    reuseDOM(node) {
      if (node.nodeName == "DIV") {
        this.setDOM(node);
        this.dirty |= 4 | 2;
      }
    }
    sync(track) {
      var _a2;
      if (!this.dom) {
        this.setDOM(document.createElement("div"));
        this.dom.className = "cm-line";
        this.prevAttrs = this.attrs ? null : void 0;
      } else if (this.dirty & 4) {
        clearAttributes(this.dom);
        this.dom.className = "cm-line";
        this.prevAttrs = this.attrs ? null : void 0;
      }
      if (this.prevAttrs !== void 0) {
        updateAttrs(this.dom, this.prevAttrs, this.attrs);
        this.dom.classList.add("cm-line");
        this.prevAttrs = void 0;
      }
      super.sync(track);
      var last = this.dom.lastChild;
      while (last && ContentView.get(last) instanceof MarkView) last = last.lastChild;
      if (!last || !this.length || (last.nodeName != "BR" && ((_a2 = ContentView.get(last)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) == false && (!browser.ios || !this.children.some((ch) => ch instanceof TextView)))) {
        var hack = document.createElement("BR");
        hack.cmIgnore = true;
        this.dom.appendChild(hack);
      }
    }
    measureTextSize() {
      if (this.children.length == 0 || this.length > 20) return null;
      var totalWidth = 0;
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var child = _step.value;
          if (!(child instanceof TextView) || /[^ -~]/.test(child.text)) return null;
          var rects = clientRectsFor(child.dom);
          if (rects.length != 1) return null;
          totalWidth += rects[0].width;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return !totalWidth
        ? null
        : {
            lineHeight: this.dom.getBoundingClientRect().height,
            charWidth: totalWidth / this.length,
          };
    }
    coordsAt(pos, side) {
      return coordsInChildren(this, pos, side);
    }
    become(_other) {
      return false;
    }
    get type() {
      return BlockType.Text;
    }
    static find(docView, pos) {
      for (var i = 0, off = 0; i < docView.children.length; i++) {
        var block = docView.children[i],
          end = off + block.length;
        if (end >= pos) {
          if (block instanceof LineView) return block;
          if (end > pos) break;
        }
        off = end + block.breakAfter;
      }
      return null;
    }
    constructor() {
      super(...arguments);
      this.children = [];
      this.length = 0;
      this.prevAttrs = void 0;
      this.attrs = null;
      this.breakAfter = 0;
    }
  };
  __name(LineView, "LineView");
  var BlockWidgetView = class BlockWidgetView1 extends ContentView {
    merge(from, to, source, _takeDeco, openStart, openEnd) {
      if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) || (from > 0 && openStart <= 0) || (to < this.length && openEnd <= 0))) return false;
      this.length = from + (source ? source.length : 0) + (this.length - to);
      return true;
    }
    domAtPos(pos) {
      return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    split(at) {
      var len = this.length - at;
      this.length = at;
      var end = new BlockWidgetView(this.widget, len, this.type);
      end.breakAfter = this.breakAfter;
      return end;
    }
    get children() {
      return noChildren;
    }
    sync() {
      if (!this.dom || !this.widget.updateDOM(this.dom)) {
        if (this.dom && this.prevWidget) this.prevWidget.destroy(this.dom);
        this.prevWidget = null;
        this.setDOM(this.widget.toDOM(this.editorView));
        this.dom.contentEditable = "false";
      }
    }
    get overrideDOMText() {
      return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text.empty;
    }
    domBoundsAround() {
      return null;
    }
    become(other) {
      if (other instanceof BlockWidgetView && other.type == this.type && other.widget.constructor == this.widget.constructor) {
        if (!other.widget.eq(this.widget)) this.markDirty(true);
        if (this.dom && !this.prevWidget) this.prevWidget = this.widget;
        this.widget = other.widget;
        this.length = other.length;
        this.breakAfter = other.breakAfter;
        return true;
      }
      return false;
    }
    ignoreMutation() {
      return true;
    }
    ignoreEvent(event) {
      return this.widget.ignoreEvent(event);
    }
    destroy() {
      super.destroy();
      if (this.dom) this.widget.destroy(this.dom);
    }
    constructor(widget, length, type) {
      super();
      this.widget = widget;
      this.length = length;
      this.type = type;
      this.breakAfter = 0;
      this.prevWidget = null;
    }
  };
  __name(BlockWidgetView, "BlockWidgetView");
  var ContentBuilder = class ContentBuilder1 {
    posCovered() {
      if (this.content.length == 0) return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
      var last = this.content[this.content.length - 1];
      return !last.breakAfter && !(last instanceof BlockWidgetView && last.type == BlockType.WidgetBefore);
    }
    getLine() {
      if (!this.curLine) {
        this.content.push((this.curLine = new LineView()));
        this.atCursorPos = true;
      }
      return this.curLine;
    }
    flushBuffer() {
      var active = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.bufferMarks;
      if (this.pendingBuffer) {
        this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
        this.pendingBuffer = 0;
      }
    }
    addBlockWidget(view) {
      this.flushBuffer();
      this.curLine = null;
      this.content.push(view);
    }
    finish(openEnd) {
      if (this.pendingBuffer && openEnd <= this.bufferMarks.length) this.flushBuffer();
      else this.pendingBuffer = 0;
      if (!this.posCovered()) this.getLine();
    }
    buildText(length, active, openStart) {
      while (length > 0) {
        if (this.textOff == this.text.length) {
          var _this_cursor_next = this.cursor.next(this.skip),
            value = _this_cursor_next.value,
            lineBreak = _this_cursor_next.lineBreak,
            done = _this_cursor_next.done;
          this.skip = 0;
          if (done) throw new Error("Ran out of text content when drawing inline views");
          if (lineBreak) {
            if (!this.posCovered()) this.getLine();
            if (this.content.length) this.content[this.content.length - 1].breakAfter = 1;
            else this.breakAtStart = 1;
            this.flushBuffer();
            this.curLine = null;
            this.atCursorPos = true;
            length--;
            continue;
          } else {
            this.text = value;
            this.textOff = 0;
          }
        }
        var take = Math.min(this.text.length - this.textOff, length, 512);
        this.flushBuffer(active.slice(active.length - openStart));
        this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
        this.atCursorPos = true;
        this.textOff += take;
        length -= take;
        openStart = 0;
      }
    }
    span(from, to, active, openStart) {
      this.buildText(to - from, active, openStart);
      this.pos = to;
      if (this.openStart < 0) this.openStart = openStart;
    }
    point(from, to, deco, active, openStart, index) {
      if (this.disallowBlockEffectsFor[index] && deco instanceof PointDecoration) {
        if (deco.block) throw new RangeError("Block decorations may not be specified via plugins");
        if (to > this.doc.lineAt(this.pos).to) throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
      }
      var len = to - from;
      if (deco instanceof PointDecoration) {
        if (deco.block) {
          var type = deco.type;
          if (type == BlockType.WidgetAfter && !this.posCovered()) this.getLine();
          this.addBlockWidget(new BlockWidgetView(deco.widget || new NullWidget("div"), len, type));
        } else {
          var view = WidgetView.create(deco.widget || new NullWidget("span"), len, len ? 0 : deco.startSide);
          var cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from < to || deco.startSide > 0);
          var cursorAfter = !view.isEditable && (from < to || openStart > active.length || deco.startSide <= 0);
          var line = this.getLine();
          if (this.pendingBuffer == 2 && !cursorBefore) this.pendingBuffer = 0;
          this.flushBuffer(active);
          if (cursorBefore) {
            line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
            openStart = active.length + Math.max(0, openStart - active.length);
          }
          line.append(wrapMarks(view, active), openStart);
          this.atCursorPos = cursorAfter;
          this.pendingBuffer = !cursorAfter ? 0 : from < to || openStart > active.length ? 1 : 2;
          if (this.pendingBuffer) this.bufferMarks = active.slice();
        }
      } else if (this.doc.lineAt(this.pos).from == this.pos) {
        this.getLine().addLineDeco(deco);
      }
      if (len) {
        if (this.textOff + len <= this.text.length) {
          this.textOff += len;
        } else {
          this.skip += len - (this.text.length - this.textOff);
          this.text = "";
          this.textOff = 0;
        }
        this.pos = to;
      }
      if (this.openStart < 0) this.openStart = openStart;
    }
    static build(text2, from, to, decorations2, dynamicDecorationMap) {
      var builder = new ContentBuilder(text2, from, to, dynamicDecorationMap);
      builder.openEnd = RangeSet.spans(decorations2, from, to, builder);
      if (builder.openStart < 0) builder.openStart = builder.openEnd;
      builder.finish(builder.openEnd);
      return builder;
    }
    constructor(doc2, pos, end, disallowBlockEffectsFor) {
      this.doc = doc2;
      this.pos = pos;
      this.end = end;
      this.disallowBlockEffectsFor = disallowBlockEffectsFor;
      this.content = [];
      this.curLine = null;
      this.breakAtStart = 0;
      this.pendingBuffer = 0;
      this.bufferMarks = [];
      this.atCursorPos = true;
      this.openStart = -1;
      this.openEnd = -1;
      this.text = "";
      this.textOff = 0;
      this.cursor = doc2.iter();
      this.skip = pos;
    }
  };
  __name(ContentBuilder, "ContentBuilder");
  function wrapMarks(view, active) {
    var _iteratorNormalCompletion = true,
      _didIteratorError = false,
      _iteratorError = undefined;
    try {
      for (var _iterator = active[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var mark = _step.value;
        view = new MarkView(mark, [view], view.length);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    return view;
  }
  __name(wrapMarks, "wrapMarks");
  var NullWidget = class NullWidget extends WidgetType {
    eq(other) {
      return other.tag == this.tag;
    }
    toDOM() {
      return document.createElement(this.tag);
    }
    updateDOM(elt) {
      return elt.nodeName.toLowerCase() == this.tag;
    }
    constructor(tag) {
      super();
      this.tag = tag;
    }
  };
  __name(NullWidget, "NullWidget");
  var clickAddsSelectionRange = /* @__PURE__ */ Facet.define();
  var dragMovesSelection$1 = /* @__PURE__ */ Facet.define();
  var mouseSelectionStyle = /* @__PURE__ */ Facet.define();
  var exceptionSink = /* @__PURE__ */ Facet.define();
  var updateListener = /* @__PURE__ */ Facet.define();
  var inputHandler = /* @__PURE__ */ Facet.define();
  var perLineTextDirection = /* @__PURE__ */ Facet.define({
    combine: (values) => values.some((x) => x),
  });
  var nativeSelectionHidden = /* @__PURE__ */ Facet.define({
    combine: (values) => values.some((x) => x),
  });
  var ScrollTarget = class ScrollTarget1 {
    map(changes) {
      return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin);
    }
    constructor(range, ref, ref1, ref2, ref3) {
      var y = ref === void 0 ? "nearest" : ref,
        x = ref1 === void 0 ? "nearest" : ref1,
        yMargin = ref2 === void 0 ? 5 : ref2,
        xMargin = ref3 === void 0 ? 5 : ref3;
      this.range = range;
      this.y = y;
      this.x = x;
      this.yMargin = yMargin;
      this.xMargin = xMargin;
    }
  };
  __name(ScrollTarget, "ScrollTarget");
  var scrollIntoView = /* @__PURE__ */ StateEffect.define({
    map: (t2, ch) => t2.map(ch),
  });
  function logException(state, exception, context) {
    var handler = state.facet(exceptionSink);
    if (handler.length) handler[0](exception);
    else if (window.onerror) window.onerror(String(exception), context, void 0, void 0, exception);
    else if (context) console.error(context + ":", exception);
    else console.error(exception);
  }
  __name(logException, "logException");
  var editable = /* @__PURE__ */ Facet.define({
    combine: (values) => (values.length ? values[0] : true),
  });
  var nextPluginID = 0;
  var viewPlugin = /* @__PURE__ */ Facet.define();
  var ViewPlugin = class ViewPlugin1 {
    static define(create, spec) {
      var _ref = spec || {},
        eventHandlers = _ref.eventHandlers,
        provide = _ref.provide,
        deco = _ref.decorations;
      return new ViewPlugin(nextPluginID++, create, eventHandlers, (plugin) => {
        var ext = [viewPlugin.of(plugin)];
        if (deco)
          ext.push(
            decorations.of((view) => {
              var pluginInst = view.plugin(plugin);
              return pluginInst ? deco(pluginInst) : Decoration.none;
            })
          );
        if (provide) ext.push(provide(plugin));
        return ext;
      });
    }
    static fromClass(cls, spec) {
      return ViewPlugin.define((view) => new cls(view), spec);
    }
    constructor(id, create, domEventHandlers, buildExtensions) {
      this.id = id;
      this.create = create;
      this.domEventHandlers = domEventHandlers;
      this.extension = buildExtensions(this);
    }
  };
  __name(ViewPlugin, "ViewPlugin");
  var PluginInstance = class PluginInstance {
    update(view) {
      if (!this.value) {
        if (this.spec) {
          try {
            this.value = this.spec.create(view);
          } catch (e) {
            logException(view.state, e, "CodeMirror plugin crashed");
            this.deactivate();
          }
        }
      } else if (this.mustUpdate) {
        var update2 = this.mustUpdate;
        this.mustUpdate = null;
        if (this.value.update) {
          try {
            this.value.update(update2);
          } catch (e1) {
            logException(update2.state, e1, "CodeMirror plugin crashed");
            if (this.value.destroy)
              try {
                this.value.destroy();
              } catch (_) {}
            this.deactivate();
          }
        }
      }
      return this;
    }
    destroy(view) {
      var _a2;
      if ((_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.destroy) {
        try {
          this.value.destroy();
        } catch (e) {
          logException(view.state, e, "CodeMirror plugin crashed");
        }
      }
    }
    deactivate() {
      this.spec = this.value = null;
    }
    constructor(spec) {
      this.spec = spec;
      this.mustUpdate = null;
      this.value = null;
    }
  };
  __name(PluginInstance, "PluginInstance");
  var editorAttributes = /* @__PURE__ */ Facet.define();
  var contentAttributes = /* @__PURE__ */ Facet.define();
  var decorations = /* @__PURE__ */ Facet.define();
  var atomicRanges = /* @__PURE__ */ Facet.define();
  var scrollMargins = /* @__PURE__ */ Facet.define();
  var styleModule = /* @__PURE__ */ Facet.define();
  var ChangedRange = class ChangedRange1 {
    join(other) {
      return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
    }
    addToSet(set) {
      var i = set.length,
        me = this;
      for (; i > 0; i--) {
        var range = set[i - 1];
        if (range.fromA > me.toA) continue;
        if (range.toA < me.fromA) break;
        me = me.join(range);
        set.splice(i - 1, 1);
      }
      set.splice(i, 0, me);
      return set;
    }
    static extendWithRanges(diff, ranges) {
      if (ranges.length == 0) return diff;
      var result = [];
      for (var dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
        var next = dI == diff.length ? null : diff[dI],
          off = posA - posB;
        var end = next ? next.fromB : 1e9;
        while (rI < ranges.length && ranges[rI] < end) {
          var from = ranges[rI],
            to = ranges[rI + 1];
          var fromB = Math.max(posB, from),
            toB = Math.min(end, to);
          if (fromB <= toB) new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
          if (to > end) break;
          else rI += 2;
        }
        if (!next) return result;
        new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
        posA = next.toA;
        posB = next.toB;
      }
    }
    constructor(fromA, toA, fromB, toB) {
      this.fromA = fromA;
      this.toA = toA;
      this.fromB = fromB;
      this.toB = toB;
    }
  };
  __name(ChangedRange, "ChangedRange");
  var ViewUpdate = class ViewUpdate1 {
    static create(view, state, transactions) {
      return new ViewUpdate(view, state, transactions);
    }
    get viewportChanged() {
      return (this.flags & 4) > 0;
    }
    get heightChanged() {
      return (this.flags & 2) > 0;
    }
    get geometryChanged() {
      return this.docChanged || (this.flags & (8 | 2)) > 0;
    }
    get focusChanged() {
      return (this.flags & 1) > 0;
    }
    get docChanged() {
      return !this.changes.empty;
    }
    get selectionSet() {
      return this.transactions.some((tr) => tr.selection);
    }
    get empty() {
      return this.flags == 0 && this.transactions.length == 0;
    }
    constructor(view, state, transactions) {
      this.view = view;
      this.state = state;
      this.transactions = transactions;
      this.flags = 0;
      this.startState = view.state;
      this.changes = ChangeSet.empty(this.startState.doc.length);
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = transactions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var tr = _step.value;
          this.changes = this.changes.compose(tr.changes);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      var changedRanges = [];
      this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
      this.changedRanges = changedRanges;
      var focus = view.hasFocus;
      if (focus != view.inputState.notifiedFocused) {
        view.inputState.notifiedFocused = focus;
        this.flags |= 1;
      }
    }
  };
  __name(ViewUpdate, "ViewUpdate");
  var Direction = /* @__PURE__ */ (function (Direction2) {
    Direction2[(Direction2["LTR"] = 0)] = "LTR";
    Direction2[(Direction2["RTL"] = 1)] = "RTL";
    return Direction2;
  })(Direction || (Direction = {}));
  var LTR = Direction.LTR;
  var RTL = Direction.RTL;
  function dec(str) {
    var result = [];
    for (var i = 0; i < str.length; i++) result.push(1 << +str[i]);
    return result;
  }
  __name(dec, "dec");
  var LowTypes = /* @__PURE__ */ dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
  var ArabicTypes = /* @__PURE__ */ dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
  var Brackets = /* @__PURE__ */ Object.create(null);
  var BracketStack = [];
  for (var _i = 0, _iter = ["()", "[]", "{}"]; _i < _iter.length; _i++) {
    var p = _iter[_i];
    var l = /* @__PURE__ */ p.charCodeAt(0),
      r = /* @__PURE__ */ p.charCodeAt(1);
    Brackets[l] = r;
    Brackets[r] = -l;
  }
  function charType(ch) {
    return ch <= 247 ? LowTypes[ch] : 1424 <= ch && ch <= 1524 ? 2 : 1536 <= ch && ch <= 1785 ? ArabicTypes[ch - 1536] : 1774 <= ch && ch <= 2220 ? 4 : 8192 <= ch && ch <= 8203 ? 256 : 64336 <= ch && ch <= 65023 ? 4 : ch == 8204 ? 256 : 1;
  }
  __name(charType, "charType");
  var BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
  var BidiSpan = class BidiSpan {
    get dir() {
      return this.level % 2 ? RTL : LTR;
    }
    side(end, dir) {
      return (this.dir == dir) == end ? this.to : this.from;
    }
    static find(order, index, level, assoc) {
      var maybe = -1;
      for (var i = 0; i < order.length; i++) {
        var span = order[i];
        if (span.from <= index && span.to >= index) {
          if (span.level == level) return i;
          if (maybe < 0 || (assoc != 0 ? (assoc < 0 ? span.from < index : span.to > index) : order[maybe].level > span.level)) maybe = i;
        }
      }
      if (maybe < 0) throw new RangeError("Index out of range");
      return maybe;
    }
    constructor(from, to, level) {
      this.from = from;
      this.to = to;
      this.level = level;
    }
  };
  __name(BidiSpan, "BidiSpan");
  var types = [];
  function computeOrder(line, direction) {
    var len = line.length,
      outerType = direction == LTR ? 1 : 2,
      oppositeType = direction == LTR ? 2 : 1;
    if (!line || (outerType == 1 && !BidiRE.test(line))) return trivialOrder(len);
    for (var i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {
      var type = charType(line.charCodeAt(i));
      if (type == 512) type = prev;
      else if (type == 8 && prevStrong == 4) type = 16;
      types[i] = type == 4 ? 2 : type;
      if (type & 7) prevStrong = type;
      prev = type;
    }
    for (var i1 = 0, prev1 = outerType, prevStrong1 = outerType; i1 < len; i1++) {
      var type1 = types[i1];
      if (type1 == 128) {
        if (i1 < len - 1 && prev1 == types[i1 + 1] && prev1 & 24) type1 = types[i1] = prev1;
        else types[i1] = 256;
      } else if (type1 == 64) {
        var end = i1 + 1;
        while (end < len && types[end] == 64) end++;
        var replace = (i1 && prev1 == 8) || (end < len && types[end] == 8) ? (prevStrong1 == 1 ? 1 : 8) : 256;
        for (var j = i1; j < end; j++) types[j] = replace;
        i1 = end - 1;
      } else if (type1 == 8 && prevStrong1 == 1) {
        types[i1] = 1;
      }
      prev1 = type1;
      if (type1 & 7) prevStrong1 = type1;
    }
    for (var i2 = 0, sI = 0, context = 0, ch, br, type2; i2 < len; i2++) {
      if ((br = Brackets[(ch = line.charCodeAt(i2))])) {
        if (br < 0) {
          for (var sJ = sI - 3; sJ >= 0; sJ -= 3) {
            if (BracketStack[sJ + 1] == -br) {
              var flags = BracketStack[sJ + 2];
              var type21 = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
              if (type21) types[i2] = types[BracketStack[sJ]] = type21;
              sI = sJ;
              break;
            }
          }
        } else if (BracketStack.length == 189) {
          break;
        } else {
          BracketStack[sI++] = i2;
          BracketStack[sI++] = ch;
          BracketStack[sI++] = context;
        }
      } else if ((type2 = types[i2]) == 2 || type2 == 1) {
        var embed = type2 == outerType;
        context = embed ? 0 : 1;
        for (var sJ1 = sI - 3; sJ1 >= 0; sJ1 -= 3) {
          var cur = BracketStack[sJ1 + 2];
          if (cur & 2) break;
          if (embed) {
            BracketStack[sJ1 + 2] |= 2;
          } else {
            if (cur & 4) break;
            BracketStack[sJ1 + 2] |= 4;
          }
        }
      }
    }
    for (var i3 = 0; i3 < len; i3++) {
      if (types[i3] == 256) {
        var end1 = i3 + 1;
        while (end1 < len && types[end1] == 256) end1++;
        var beforeL = (i3 ? types[i3 - 1] : outerType) == 1;
        var afterL = (end1 < len ? types[end1] : outerType) == 1;
        var replace1 = beforeL == afterL ? (beforeL ? 1 : 2) : outerType;
        for (var j1 = i3; j1 < end1; j1++) types[j1] = replace1;
        i3 = end1 - 1;
      }
    }
    var order = [];
    if (outerType == 1) {
      for (var i4 = 0; i4 < len; ) {
        var start = i4,
          rtl = types[i4++] != 1;
        while (i4 < len && rtl == (types[i4] != 1)) i4++;
        if (rtl) {
          for (var j2 = i4; j2 > start; ) {
            var end2 = j2,
              l = types[--j2] != 2;
            while (j2 > start && l == (types[j2 - 1] != 2)) j2--;
            order.push(new BidiSpan(j2, end2, l ? 2 : 1));
          }
        } else {
          order.push(new BidiSpan(start, i4, 0));
        }
      }
    } else {
      for (var i5 = 0; i5 < len; ) {
        var start1 = i5,
          rtl1 = types[i5++] == 2;
        while (i5 < len && rtl1 == (types[i5] == 2)) i5++;
        order.push(new BidiSpan(start1, i5, rtl1 ? 1 : 2));
      }
    }
    return order;
  }
  __name(computeOrder, "computeOrder");
  function trivialOrder(length) {
    return [new BidiSpan(0, length, 0)];
  }
  __name(trivialOrder, "trivialOrder");
  var movedOver = "";
  function moveVisually(line, order, dir, start, forward) {
    var _a2;
    var startIndex = start.head - line.from,
      spanI = -1;
    if (startIndex == 0) {
      if (!forward || !line.length) return null;
      if (order[0].level != dir) {
        startIndex = order[0].side(false, dir);
        spanI = 0;
      }
    } else if (startIndex == line.length) {
      if (forward) return null;
      var last = order[order.length - 1];
      if (last.level != dir) {
        startIndex = last.side(true, dir);
        spanI = order.length - 1;
      }
    }
    if (spanI < 0) spanI = BidiSpan.find(order, startIndex, (_a2 = start.bidiLevel) !== null && _a2 !== void 0 ? _a2 : -1, start.assoc);
    var span = order[spanI];
    if (startIndex == span.side(forward, dir)) {
      span = order[(spanI += forward ? 1 : -1)];
      startIndex = span.side(!forward, dir);
    }
    var indexForward = forward == (span.dir == dir);
    var nextIndex = findClusterBreak(line.text, startIndex, indexForward);
    movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
    if (nextIndex != span.side(forward, dir)) return EditorSelection.cursor(nextIndex + line.from, indexForward ? -1 : 1, span.level);
    var nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
    if (!nextSpan && span.level != dir) return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1, dir);
    if (nextSpan && nextSpan.level < span.level) return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, forward ? 1 : -1, nextSpan.level);
    return EditorSelection.cursor(nextIndex + line.from, forward ? -1 : 1, span.level);
  }
  __name(moveVisually, "moveVisually");
  var LineBreakPlaceholder = "";
  var DOMReader = class DOMReader {
    append(text2) {
      this.text += text2;
    }
    lineBreak() {
      this.text += LineBreakPlaceholder;
    }
    readRange(start, end) {
      if (!start) return this;
      var parent = start.parentNode;
      for (var cur = start; ; ) {
        this.findPointBefore(parent, cur);
        this.readNode(cur);
        var next = cur.nextSibling;
        if (next == end) break;
        var view = ContentView.get(cur),
          nextView = ContentView.get(next);
        if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur)) || (isBlockElement(next) && (cur.nodeName != "BR" || cur.cmIgnore))) this.lineBreak();
        cur = next;
      }
      this.findPointBefore(parent, end);
      return this;
    }
    readTextNode(node) {
      var text2 = node.nodeValue;
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.points[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var point = _step.value;
          if (point.node == node) point.pos = this.text.length + Math.min(point.offset, text2.length);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      for (var off = 0, re = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
        var nextBreak = -1,
          breakSize = 1,
          m = void 0;
        if (this.lineSeparator) {
          nextBreak = text2.indexOf(this.lineSeparator, off);
          breakSize = this.lineSeparator.length;
        } else if ((m = re.exec(text2))) {
          nextBreak = m.index;
          breakSize = m[0].length;
        }
        this.append(text2.slice(off, nextBreak < 0 ? text2.length : nextBreak));
        if (nextBreak < 0) break;
        this.lineBreak();
        if (breakSize > 1) {
          var _iteratorNormalCompletion1 = true,
            _didIteratorError1 = false,
            _iteratorError1 = undefined;
          try {
            for (var _iterator1 = this.points[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
              var point1 = _step1.value;
              if (point1.node == node && point1.pos > this.text.length) point1.pos -= breakSize - 1;
            }
          } catch (err) {
            _didIteratorError1 = true;
            _iteratorError1 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                _iterator1.return();
              }
            } finally {
              if (_didIteratorError1) {
                throw _iteratorError1;
              }
            }
          }
        }
        off = nextBreak + breakSize;
      }
    }
    readNode(node) {
      if (node.cmIgnore) return;
      var view = ContentView.get(node);
      var fromView = view && view.overrideDOMText;
      if (fromView != null) {
        this.findPointInside(node, fromView.length);
        for (var i = fromView.iter(); !i.next().done; ) {
          if (i.lineBreak) this.lineBreak();
          else this.append(i.value);
        }
      } else if (node.nodeType == 3) {
        this.readTextNode(node);
      } else if (node.nodeName == "BR") {
        if (node.nextSibling) this.lineBreak();
      } else if (node.nodeType == 1) {
        this.readRange(node.firstChild, null);
      }
    }
    findPointBefore(node, next) {
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.points[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var point = _step.value;
          if (point.node == node && node.childNodes[point.offset] == next) point.pos = this.text.length;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    findPointInside(node, maxLen) {
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.points[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var point = _step.value;
          if (node.nodeType == 3 ? point.node == node : node.contains(point.node)) point.pos = this.text.length + Math.min(maxLen, point.offset);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    constructor(points, state) {
      this.points = points;
      this.text = "";
      this.lineSeparator = state.facet(EditorState.lineSeparator);
    }
  };
  __name(DOMReader, "DOMReader");
  function isBlockElement(node) {
    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
  }
  __name(isBlockElement, "isBlockElement");
  var DOMPoint = class DOMPoint {
    constructor(node, offset) {
      this.node = node;
      this.offset = offset;
      this.pos = -1;
    }
  };
  __name(DOMPoint, "DOMPoint");
  var DocView = class DocView extends ContentView {
    get editorView() {
      return this.view;
    }
    get length() {
      return this.view.state.doc.length;
    }
    update(update2) {
      var changedRanges = update2.changedRanges;
      if (this.minWidth > 0 && changedRanges.length) {
        if (
          !changedRanges.every((param) => {
            var fromA = param.fromA,
              toA = param.toA;
            return toA < this.minWidthFrom || fromA > this.minWidthTo;
          })
        ) {
          this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
        } else {
          this.minWidthFrom = update2.changes.mapPos(this.minWidthFrom, 1);
          this.minWidthTo = update2.changes.mapPos(this.minWidthTo, 1);
        }
      }
      if (this.view.inputState.composing < 0) this.compositionDeco = Decoration.none;
      else if (update2.transactions.length || this.dirty) this.compositionDeco = computeCompositionDeco(this.view, update2.changes);
      if ((browser.ie || browser.chrome) && !this.compositionDeco.size && update2 && update2.state.doc.lines != update2.startState.doc.lines) this.forceSelection = true;
      var prevDeco = this.decorations,
        deco = this.updateDeco();
      var decoDiff = findChangedDeco(prevDeco, deco, update2.changes);
      changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
      if (this.dirty == 0 && changedRanges.length == 0) {
        return false;
      } else {
        this.updateInner(changedRanges, update2.startState.doc.length);
        if (update2.transactions.length) this.lastUpdate = Date.now();
        return true;
      }
    }
    updateInner(changes, oldLength) {
      this.view.viewState.mustMeasureContent = true;
      this.updateChildren(changes, oldLength);
      var observer = this.view.observer;
      observer.ignore(() => {
        this.dom.style.height = this.view.viewState.contentHeight + "px";
        this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
        var track =
          browser.chrome || browser.ios
            ? {
                node: observer.selectionRange.focusNode,
                written: false,
              }
            : void 0;
        this.sync(track);
        this.dirty = 0;
        if (track && (track.written || observer.selectionRange.focusNode != track.node)) this.forceSelection = true;
        this.dom.style.height = "";
      });
      var gaps = [];
      if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
        var _iteratorNormalCompletion = true,
          _didIteratorError = false,
          _iteratorError = undefined;
        try {
          for (var _iterator = this.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var child = _step.value;
            if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget) gaps.push(child.dom);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
      observer.updateGaps(gaps);
    }
    updateChildren(changes, oldLength) {
      var cursor = this.childCursor(oldLength);
      for (var i = changes.length - 1; ; i--) {
        var next = i >= 0 ? changes[i] : null;
        if (!next) break;
        var fromA = next.fromA,
          toA = next.toA,
          fromB = next.fromB,
          toB = next.toB;
        var _ContentBuilder_build = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap),
          content2 = _ContentBuilder_build.content,
          breakAtStart = _ContentBuilder_build.breakAtStart,
          openStart = _ContentBuilder_build.openStart,
          openEnd = _ContentBuilder_build.openEnd;
        var _cursor_findPos = cursor.findPos(toA, 1),
          toI = _cursor_findPos.i,
          toOff = _cursor_findPos.off;
        var _cursor_findPos1 = cursor.findPos(fromA, -1),
          fromI = _cursor_findPos1.i,
          fromOff = _cursor_findPos1.off;
        replaceRange(this, fromI, fromOff, toI, toOff, content2, breakAtStart, openStart, openEnd);
      }
    }
    updateSelection() {
      var mustRead = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false,
        fromPointer = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (mustRead || !this.view.observer.selectionRange.focusNode) this.view.observer.readSelectionRange();
      if (!(fromPointer || this.mayControlSelection())) return;
      var force = this.forceSelection;
      this.forceSelection = false;
      var main = this.view.state.selection.main;
      var anchor = this.domAtPos(main.anchor);
      var head = main.empty ? anchor : this.domAtPos(main.head);
      if (browser.gecko && main.empty && betweenUneditable(anchor)) {
        var dummy = document.createTextNode("");
        this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
        anchor = head = new DOMPos(dummy, 0);
        force = true;
      }
      var domSel = this.view.observer.selectionRange;
      if (force || !domSel.focusNode || !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {
        this.view.observer.ignore(() => {
          if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {
            this.dom.blur();
            this.dom.focus({
              preventScroll: true,
            });
          }
          var rawSel = getSelection(this.view.root);
          if (!rawSel);
          else if (main.empty) {
            if (browser.gecko) {
              var nextTo = nextToUneditable(anchor.node, anchor.offset);
              if (nextTo && nextTo != (1 | 2)) {
                var text2 = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 ? 1 : -1);
                if (text2) anchor = new DOMPos(text2, nextTo == 1 ? 0 : text2.nodeValue.length);
              }
            }
            rawSel.collapse(anchor.node, anchor.offset);
            if (main.bidiLevel != null && domSel.cursorBidiLevel != null) domSel.cursorBidiLevel = main.bidiLevel;
          } else if (rawSel.extend) {
            rawSel.collapse(anchor.node, anchor.offset);
            try {
              rawSel.extend(head.node, head.offset);
            } catch (_) {}
          } else {
            var range = document.createRange();
            var ref;
            if (main.anchor > main.head) (ref = [head, anchor]), (anchor = ref[0]), (head = ref[1]), ref;
            range.setEnd(head.node, head.offset);
            range.setStart(anchor.node, anchor.offset);
            rawSel.removeAllRanges();
            rawSel.addRange(range);
          }
        });
        this.view.observer.setSelectionRange(anchor, head);
      }
      this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
      this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
    }
    enforceCursorAssoc() {
      if (this.compositionDeco.size) return;
      var view = this.view,
        cursor = view.state.selection.main;
      var sel = getSelection(view.root);
      var _view_observer_selectionRange = view.observer.selectionRange,
        anchorNode = _view_observer_selectionRange.anchorNode,
        anchorOffset = _view_observer_selectionRange.anchorOffset;
      if (!sel || !cursor.empty || !cursor.assoc || !sel.modify) return;
      var line = LineView.find(this, cursor.head);
      if (!line) return;
      var lineStart = line.posAtStart;
      if (cursor.head == lineStart || cursor.head == lineStart + line.length) return;
      var before = this.coordsAt(cursor.head, -1),
        after = this.coordsAt(cursor.head, 1);
      if (!before || !after || before.bottom > after.top) return;
      var dom = this.domAtPos(cursor.head + cursor.assoc);
      sel.collapse(dom.node, dom.offset);
      sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
      view.observer.readSelectionRange();
      var newRange = view.observer.selectionRange;
      if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from) sel.collapse(anchorNode, anchorOffset);
    }
    mayControlSelection() {
      var active = this.view.root.activeElement;
      return active == this.dom || (hasSelection(this.dom, this.view.observer.selectionRange) && !(active && this.dom.contains(active)));
    }
    nearest(dom) {
      for (var cur = dom; cur; ) {
        var domView = ContentView.get(cur);
        if (domView && domView.rootView == this) return domView;
        cur = cur.parentNode;
      }
      return null;
    }
    posFromDOM(node, offset) {
      var view = this.nearest(node);
      if (!view) throw new RangeError("Trying to find position for a DOM position outside of the document");
      return view.localPosFromDOM(node, offset) + view.posAtStart;
    }
    domAtPos(pos) {
      var _this_childCursor_findPos = this.childCursor().findPos(pos, -1),
        i = _this_childCursor_findPos.i,
        off = _this_childCursor_findPos.off;
      for (; i < this.children.length - 1; ) {
        var child = this.children[i];
        if (off < child.length || child instanceof LineView) break;
        i++;
        off = 0;
      }
      return this.children[i].domAtPos(off);
    }
    coordsAt(pos, side) {
      for (var off = this.length, i = this.children.length - 1; ; i--) {
        var child = this.children[i],
          start = off - child.breakAfter - child.length;
        if (pos > start || (pos == start && child.type != BlockType.WidgetBefore && child.type != BlockType.WidgetAfter && (!i || side == 2 || this.children[i - 1].breakAfter || (this.children[i - 1].type == BlockType.WidgetBefore && side > -2)))) return child.coordsAt(pos - start, side);
        off = start;
      }
    }
    measureVisibleLineHeights(viewport) {
      var result = [],
        from = viewport.from,
        to = viewport.to;
      var contentWidth = this.view.contentDOM.clientWidth;
      var isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
      var widest = -1,
        ltr = this.view.textDirection == Direction.LTR;
      for (var pos = 0, i = 0; i < this.children.length; i++) {
        var child = this.children[i],
          end = pos + child.length;
        if (end > to) break;
        if (pos >= from) {
          var childRect = child.dom.getBoundingClientRect();
          result.push(childRect.height);
          if (isWider) {
            var last = child.dom.lastChild;
            var rects = last ? clientRectsFor(last) : [];
            if (rects.length) {
              var rect = rects[rects.length - 1];
              var width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
              if (width > widest) {
                widest = width;
                this.minWidth = contentWidth;
                this.minWidthFrom = pos;
                this.minWidthTo = end;
              }
            }
          }
        }
        pos = end + child.breakAfter;
      }
      return result;
    }
    textDirectionAt(pos) {
      var i = this.childPos(pos, 1).i;
      return getComputedStyle(this.children[i].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
    }
    measureTextSize() {
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var child = _step.value;
          if (child instanceof LineView) {
            var measure = child.measureTextSize();
            if (measure) return measure;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      var dummy = document.createElement("div"),
        lineHeight,
        charWidth;
      dummy.className = "cm-line";
      dummy.style.width = "99999px";
      dummy.textContent = "abc def ghi jkl mno pqr stu";
      this.view.observer.ignore(() => {
        this.dom.appendChild(dummy);
        var rect = clientRectsFor(dummy.firstChild)[0];
        lineHeight = dummy.getBoundingClientRect().height;
        charWidth = rect ? rect.width / 27 : 7;
        dummy.remove();
      });
      return {
        lineHeight,
        charWidth,
      };
    }
    childCursor() {
      var pos = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.length;
      var i = this.children.length;
      if (i) pos -= this.children[--i].length;
      return new ChildCursor(this.children, pos, i);
    }
    computeBlockGapDeco() {
      var deco = [],
        vs = this.view.viewState;
      for (var pos = 0, i = 0; ; i++) {
        var next = i == vs.viewports.length ? null : vs.viewports[i];
        var end = next ? next.from - 1 : this.length;
        if (end > pos) {
          var height = vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top;
          deco.push(
            Decoration.replace({
              widget: new BlockGapWidget(height),
              block: true,
              inclusive: true,
              isBlockGap: true,
            }).range(pos, end)
          );
        }
        if (!next) break;
        pos = next.to + 1;
      }
      return Decoration.set(deco);
    }
    updateDeco() {
      var allDeco = this.view.state.facet(decorations).map((d, i) => {
        var dynamic = (this.dynamicDecorationMap[i] = typeof d == "function");
        return dynamic ? d(this.view) : d;
      });
      for (var i = allDeco.length; i < allDeco.length + 3; i++) this.dynamicDecorationMap[i] = false;
      return (this.decorations = [...allDeco, this.compositionDeco, this.computeBlockGapDeco(), this.view.viewState.lineGapDeco]);
    }
    scrollIntoView(target) {
      var range = target.range;
      var rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1),
        other;
      if (!rect) return;
      if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))
        rect = {
          left: Math.min(rect.left, other.left),
          top: Math.min(rect.top, other.top),
          right: Math.max(rect.right, other.right),
          bottom: Math.max(rect.bottom, other.bottom),
        };
      var mLeft = 0,
        mRight = 0,
        mTop = 0,
        mBottom = 0;
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (
          var _iterator = this.view.state
              .facet(scrollMargins)
              .map((f) => f(this.view))
              [Symbol.iterator](),
            _step;
          !(_iteratorNormalCompletion = (_step = _iterator.next()).done);
          _iteratorNormalCompletion = true
        ) {
          var margins = _step.value;
          if (margins) {
            var left = margins.left,
              right = margins.right,
              top2 = margins.top,
              bottom = margins.bottom;
            if (left != null) mLeft = Math.max(mLeft, left);
            if (right != null) mRight = Math.max(mRight, right);
            if (top2 != null) mTop = Math.max(mTop, top2);
            if (bottom != null) mBottom = Math.max(mBottom, bottom);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      var targetRect = {
        left: rect.left - mLeft,
        top: rect.top - mTop,
        right: rect.right + mRight,
        bottom: rect.bottom + mBottom,
      };
      scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, target.xMargin, target.yMargin, this.view.textDirection == Direction.LTR);
    }
    constructor(view) {
      super();
      this.view = view;
      this.compositionDeco = Decoration.none;
      this.decorations = [];
      this.dynamicDecorationMap = [];
      this.minWidth = 0;
      this.minWidthFrom = 0;
      this.minWidthTo = 0;
      this.impreciseAnchor = null;
      this.impreciseHead = null;
      this.forceSelection = false;
      this.lastUpdate = Date.now();
      this.setDOM(view.contentDOM);
      this.children = [new LineView()];
      this.children[0].setParent(this);
      this.updateDeco();
      this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0);
    }
  };
  __name(DocView, "DocView");
  function betweenUneditable(pos) {
    return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
  }
  __name(betweenUneditable, "betweenUneditable");
  var BlockGapWidget = class BlockGapWidget extends WidgetType {
    toDOM() {
      var elt = document.createElement("div");
      this.updateDOM(elt);
      return elt;
    }
    eq(other) {
      return other.height == this.height;
    }
    updateDOM(elt) {
      elt.style.height = this.height + "px";
      return true;
    }
    get estimatedHeight() {
      return this.height;
    }
    constructor(height) {
      super();
      this.height = height;
    }
  };
  __name(BlockGapWidget, "BlockGapWidget");
  function compositionSurroundingNode(view) {
    var sel = view.observer.selectionRange;
    var textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);
    if (!textNode) return null;
    var cView = view.docView.nearest(textNode);
    if (!cView) return null;
    if (cView instanceof LineView) {
      var topNode = textNode;
      while (topNode.parentNode != cView.dom) topNode = topNode.parentNode;
      var prev = topNode.previousSibling;
      while (prev && !ContentView.get(prev)) prev = prev.previousSibling;
      var pos = prev ? ContentView.get(prev).posAtEnd : cView.posAtStart;
      return {
        from: pos,
        to: pos,
        node: topNode,
        text: textNode,
      };
    } else {
      for (;;) {
        var parent = cView.parent;
        if (!parent) return null;
        if (parent instanceof LineView) break;
        cView = parent;
      }
      var from = cView.posAtStart;
      return {
        from,
        to: from + cView.length,
        node: cView.dom,
        text: textNode,
      };
    }
  }
  __name(compositionSurroundingNode, "compositionSurroundingNode");
  function computeCompositionDeco(view, changes) {
    var surrounding = compositionSurroundingNode(view);
    if (!surrounding) return Decoration.none;
    var from = surrounding.from,
      to = surrounding.to,
      node = surrounding.node,
      textNode = surrounding.text;
    var newFrom = changes.mapPos(from, 1),
      newTo = Math.max(newFrom, changes.mapPos(to, -1));
    var state = view.state,
      text2 = node.nodeType == 3 ? node.nodeValue : new DOMReader([], state).readRange(node.firstChild, null).text;
    if (newTo - newFrom < text2.length) {
      if (state.doc.sliceString(newFrom, Math.min(state.doc.length, newFrom + text2.length), LineBreakPlaceholder) == text2) newTo = newFrom + text2.length;
      else if (state.doc.sliceString(Math.max(0, newTo - text2.length), newTo, LineBreakPlaceholder) == text2) newFrom = newTo - text2.length;
      else return Decoration.none;
    } else if (state.doc.sliceString(newFrom, newTo, LineBreakPlaceholder) != text2) {
      return Decoration.none;
    }
    var topView = ContentView.get(node);
    if (topView instanceof CompositionView) topView = topView.widget.topView;
    else if (topView) topView.parent = null;
    return Decoration.set(
      Decoration.replace({
        widget: new CompositionWidget(node, textNode, topView),
        inclusive: true,
      }).range(newFrom, newTo)
    );
  }
  __name(computeCompositionDeco, "computeCompositionDeco");
  var CompositionWidget = class CompositionWidget extends WidgetType {
    eq(other) {
      return this.top == other.top && this.text == other.text;
    }
    toDOM() {
      return this.top;
    }
    ignoreEvent() {
      return false;
    }
    get customView() {
      return CompositionView;
    }
    constructor(top2, text2, topView) {
      super();
      this.top = top2;
      this.text = text2;
      this.topView = topView;
    }
  };
  __name(CompositionWidget, "CompositionWidget");
  function nearbyTextNode(node, offset, side) {
    for (;;) {
      if (node.nodeType == 3) return node;
      if (node.nodeType == 1 && offset > 0 && side <= 0) {
        node = node.childNodes[offset - 1];
        offset = maxOffset(node);
      } else if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {
        node = node.childNodes[offset];
        offset = 0;
      } else {
        return null;
      }
    }
  }
  __name(nearbyTextNode, "nearbyTextNode");
  function nextToUneditable(node, offset) {
    if (node.nodeType != 1) return 0;
    return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 : 0);
  }
  __name(nextToUneditable, "nextToUneditable");
  var DecorationComparator$1 = class DecorationComparator$1 {
    compareRange(from, to) {
      addRange(from, to, this.changes);
    }
    comparePoint(from, to) {
      addRange(from, to, this.changes);
    }
    constructor() {
      this.changes = [];
    }
  };
  __name(DecorationComparator$1, "DecorationComparator$1");
  function findChangedDeco(a, b, diff) {
    var comp = new DecorationComparator$1();
    RangeSet.compare(a, b, diff, comp);
    return comp.changes;
  }
  __name(findChangedDeco, "findChangedDeco");
  function inUneditable(node, inside2) {
    for (var cur = node; cur && cur != inside2; cur = cur.assignedSlot || cur.parentNode) {
      if (cur.nodeType == 1 && cur.contentEditable == "false") {
        return true;
      }
    }
    return false;
  }
  __name(inUneditable, "inUneditable");
  function groupAt(state, pos) {
    var bias = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    var categorize = state.charCategorizer(pos);
    var line = state.doc.lineAt(pos),
      linePos = pos - line.from;
    if (line.length == 0) return EditorSelection.cursor(pos);
    if (linePos == 0) bias = 1;
    else if (linePos == line.length) bias = -1;
    var from = linePos,
      to = linePos;
    if (bias < 0) from = findClusterBreak(line.text, linePos, false);
    else to = findClusterBreak(line.text, linePos);
    var cat = categorize(line.text.slice(from, to));
    while (from > 0) {
      var prev = findClusterBreak(line.text, from, false);
      if (categorize(line.text.slice(prev, from)) != cat) break;
      from = prev;
    }
    while (to < line.length) {
      var next = findClusterBreak(line.text, to);
      if (categorize(line.text.slice(to, next)) != cat) break;
      to = next;
    }
    return EditorSelection.range(from + line.from, to + line.from);
  }
  __name(groupAt, "groupAt");
  function getdx(x, rect) {
    return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);
  }
  __name(getdx, "getdx");
  function getdy(y, rect) {
    return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);
  }
  __name(getdy, "getdy");
  function yOverlap(a, b) {
    return a.top < b.bottom - 1 && a.bottom > b.top + 1;
  }
  __name(yOverlap, "yOverlap");
  function upTop(rect, top2) {
    return top2 < rect.top
      ? {
          top: top2,
          left: rect.left,
          right: rect.right,
          bottom: rect.bottom,
        }
      : rect;
  }
  __name(upTop, "upTop");
  function upBot(rect, bottom) {
    return bottom > rect.bottom
      ? {
          top: rect.top,
          left: rect.left,
          right: rect.right,
          bottom,
        }
      : rect;
  }
  __name(upBot, "upBot");
  function domPosAtCoords(parent, x, y) {
    var closest,
      closestRect,
      closestX,
      closestY,
      closestOverlap = false;
    var above, below, aboveRect, belowRect;
    for (var child = parent.firstChild; child; child = child.nextSibling) {
      var rects = clientRectsFor(child);
      for (var i = 0; i < rects.length; i++) {
        var rect = rects[i];
        if (closestRect && yOverlap(closestRect, rect)) rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
        var dx = getdx(x, rect),
          dy = getdy(y, rect);
        if (dx == 0 && dy == 0) return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);
        if (!closest || closestY > dy || (closestY == dy && closestX > dx)) {
          closest = child;
          closestRect = rect;
          closestX = dx;
          closestY = dy;
          closestOverlap = !dx || (dx > 0 ? i < rects.length - 1 : i > 0);
        }
        if (dx == 0) {
          if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
            above = child;
            aboveRect = rect;
          } else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {
            below = child;
            belowRect = rect;
          }
        } else if (aboveRect && yOverlap(aboveRect, rect)) {
          aboveRect = upBot(aboveRect, rect.bottom);
        } else if (belowRect && yOverlap(belowRect, rect)) {
          belowRect = upTop(belowRect, rect.top);
        }
      }
    }
    if (aboveRect && aboveRect.bottom >= y) {
      closest = above;
      closestRect = aboveRect;
    } else if (belowRect && belowRect.top <= y) {
      closest = below;
      closestRect = belowRect;
    }
    if (!closest)
      return {
        node: parent,
        offset: 0,
      };
    var clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));
    if (closest.nodeType == 3) return domPosInText(closest, clipX, y);
    if (closestOverlap && closest.contentEditable != "false") return domPosAtCoords(closest, clipX, y);
    var offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
    return {
      node: parent,
      offset,
    };
  }
  __name(domPosAtCoords, "domPosAtCoords");
  function domPosInText(node, x, y) {
    var len = node.nodeValue.length;
    var closestOffset = -1,
      closestDY = 1e9,
      generalSide = 0;
    for (var i = 0; i < len; i++) {
      var rects = textRange(node, i, i + 1).getClientRects();
      for (var j = 0; j < rects.length; j++) {
        var rect = rects[j];
        if (rect.top == rect.bottom) continue;
        if (!generalSide) generalSide = x - rect.left;
        var dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;
        if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {
          var right = x >= (rect.left + rect.right) / 2,
            after = right;
          if (browser.chrome || browser.gecko) {
            var rectBefore = textRange(node, i).getBoundingClientRect();
            if (rectBefore.left == rect.right) after = !right;
          }
          if (dy <= 0)
            return {
              node,
              offset: i + (after ? 1 : 0),
            };
          closestOffset = i + (after ? 1 : 0);
          closestDY = dy;
        }
      }
    }
    return {
      node,
      offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0,
    };
  }
  __name(domPosInText, "domPosInText");
  function posAtCoords(view, param, precise) {
    var x = param.x,
      y = param.y,
      bias = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : -1;
    var _a2;
    var content2 = view.contentDOM.getBoundingClientRect(),
      docTop = content2.top + view.viewState.paddingTop;
    var block,
      docHeight = view.viewState.docHeight;
    var yOffset = y - docTop;
    if (yOffset < 0) return 0;
    if (yOffset > docHeight) return view.state.doc.length;
    for (var halfLine = view.defaultLineHeight / 2, bounced = false; ; ) {
      block = view.elementAtHeight(yOffset);
      if (block.type == BlockType.Text) break;
      for (;;) {
        yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
        if (yOffset >= 0 && yOffset <= docHeight) break;
        if (bounced) return precise ? null : 0;
        bounced = true;
        bias = -bias;
      }
    }
    y = docTop + yOffset;
    var lineStart = block.from;
    if (lineStart < view.viewport.from) return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content2, block, x, y);
    if (lineStart > view.viewport.to) return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content2, block, x, y);
    var doc2 = view.dom.ownerDocument;
    var root = view.root.elementFromPoint ? view.root : doc2;
    var element2 = root.elementFromPoint(x, y);
    if (element2 && !view.contentDOM.contains(element2)) element2 = null;
    if (!element2) {
      x = Math.max(content2.left + 1, Math.min(content2.right - 1, x));
      element2 = root.elementFromPoint(x, y);
      if (element2 && !view.contentDOM.contains(element2)) element2 = null;
    }
    var node,
      offset = -1;
    if (element2 && ((_a2 = view.docView.nearest(element2)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) != false) {
      if (doc2.caretPositionFromPoint) {
        var pos = doc2.caretPositionFromPoint(x, y);
        var ref;
        if (pos) (ref = pos), (node = ref.offsetNode), (offset = ref.offset), ref;
      } else if (doc2.caretRangeFromPoint) {
        var range = doc2.caretRangeFromPoint(x, y);
        if (range) {
          var ref1;
          (ref1 = range), (node = ref1.startContainer), (offset = ref1.startOffset), ref1;
          if (!view.contentDOM.contains(node) || (browser.safari && isSuspiciousSafariCaretResult(node, offset, x)) || (browser.chrome && isSuspiciousChromeCaretResult(node, offset, x))) node = void 0;
        }
      }
    }
    if (!node || !view.docView.dom.contains(node)) {
      var line = LineView.find(view.docView, lineStart);
      if (!line) return yOffset > block.top + block.height / 2 ? block.to : block.from;
      var ref2;
      (ref2 = domPosAtCoords(line.dom, x, y)), (node = ref2.node), (offset = ref2.offset), ref2;
    }
    return view.docView.posFromDOM(node, offset);
  }
  __name(posAtCoords, "posAtCoords");
  function posAtCoordsImprecise(view, contentRect, block, x, y) {
    var into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);
    if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
      var line = Math.floor((y - block.top) / view.defaultLineHeight);
      into += line * view.viewState.heightOracle.lineLength;
    }
    var content2 = view.state.sliceDoc(block.from, block.to);
    return block.from + findColumn(content2, into, view.state.tabSize);
  }
  __name(posAtCoordsImprecise, "posAtCoordsImprecise");
  function isSuspiciousSafariCaretResult(node, offset, x) {
    var len;
    if (node.nodeType != 3 || offset != (len = node.nodeValue.length)) return false;
    for (var next = node.nextSibling; next; next = next.nextSibling) if (next.nodeType != 1 || next.nodeName != "BR") return false;
    return textRange(node, len - 1, len).getBoundingClientRect().left > x;
  }
  __name(isSuspiciousSafariCaretResult, "isSuspiciousSafariCaretResult");
  function isSuspiciousChromeCaretResult(node, offset, x) {
    if (offset != 0) return false;
    for (var cur = node; ; ) {
      var parent = cur.parentNode;
      if (!parent || parent.nodeType != 1 || parent.firstChild != cur) return false;
      if (parent.classList.contains("cm-line")) break;
      cur = parent;
    }
    var rect = node.nodeType == 1 ? node.getBoundingClientRect() : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();
    return x - rect.left > 5;
  }
  __name(isSuspiciousChromeCaretResult, "isSuspiciousChromeCaretResult");
  function moveToLineBoundary(view, start, forward, includeWrap) {
    var line = view.state.doc.lineAt(start.head);
    var coords = !includeWrap || !view.lineWrapping ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
    if (coords) {
      var editorRect = view.dom.getBoundingClientRect();
      var direction = view.textDirectionAt(line.from);
      var pos = view.posAtCoords({
        x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
        y: (coords.top + coords.bottom) / 2,
      });
      if (pos != null) return EditorSelection.cursor(pos, forward ? -1 : 1);
    }
    var lineView = LineView.find(view.docView, start.head);
    var end = lineView ? (forward ? lineView.posAtEnd : lineView.posAtStart) : forward ? line.to : line.from;
    return EditorSelection.cursor(end, forward ? -1 : 1);
  }
  __name(moveToLineBoundary, "moveToLineBoundary");
  function moveByChar(view, start, forward, by) {
    var line = view.state.doc.lineAt(start.head),
      spans = view.bidiSpans(line);
    var direction = view.textDirectionAt(line.from);
    for (var cur = start, check = null; ; ) {
      var next = moveVisually(line, spans, direction, cur, forward),
        char = movedOver;
      if (!next) {
        if (line.number == (forward ? view.state.doc.lines : 1)) return cur;
        char = "\n";
        line = view.state.doc.line(line.number + (forward ? 1 : -1));
        spans = view.bidiSpans(line);
        next = EditorSelection.cursor(forward ? line.from : line.to);
      }
      if (!check) {
        if (!by) return next;
        check = by(char);
      } else if (!check(char)) {
        return cur;
      }
      cur = next;
    }
  }
  __name(moveByChar, "moveByChar");
  function byGroup(view, pos, start) {
    var categorize = view.state.charCategorizer(pos);
    var cat = categorize(start);
    return (next) => {
      var nextCat = categorize(next);
      if (cat == CharCategory.Space) cat = nextCat;
      return cat == nextCat;
    };
  }
  __name(byGroup, "byGroup");
  function moveVertically(view, start, forward, distance) {
    var startPos = start.head,
      dir = forward ? 1 : -1;
    if (startPos == (forward ? view.state.doc.length : 0)) return EditorSelection.cursor(startPos, start.assoc);
    var goal = start.goalColumn,
      startY;
    var rect = view.contentDOM.getBoundingClientRect();
    var startCoords = view.coordsAtPos(startPos),
      docTop = view.documentTop;
    if (startCoords) {
      if (goal == null) goal = startCoords.left - rect.left;
      startY = dir < 0 ? startCoords.top : startCoords.bottom;
    } else {
      var line = view.viewState.lineBlockAt(startPos);
      if (goal == null) goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
      startY = (dir < 0 ? line.top : line.bottom) + docTop;
    }
    var resolvedGoal = rect.left + goal;
    var dist = distance !== null && distance !== void 0 ? distance : view.defaultLineHeight >> 1;
    for (var extra = 0; ; extra += 10) {
      var curY = startY + (dist + extra) * dir;
      var pos = posAtCoords(
        view,
        {
          x: resolvedGoal,
          y: curY,
        },
        false,
        dir
      );
      if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) return EditorSelection.cursor(pos, start.assoc, void 0, goal);
    }
  }
  __name(moveVertically, "moveVertically");
  function skipAtoms(view, oldPos, pos) {
    var atoms = view.state.facet(atomicRanges).map((f) => f(view));
    for (;;) {
      var moved = false;
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = atoms[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var set = _step.value;
          set.between(pos.from - 1, pos.from + 1, (from, to, value) => {
            if (pos.from > from && pos.from < to) {
              pos = oldPos.head > pos.from ? EditorSelection.cursor(from, 1) : EditorSelection.cursor(to, -1);
              moved = true;
            }
          });
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      if (!moved) return pos;
    }
  }
  __name(skipAtoms, "skipAtoms");
  var InputState = class InputState {
    setSelectionOrigin(origin) {
      this.lastSelectionOrigin = origin;
      this.lastSelectionTime = Date.now();
    }
    ensureHandlers(view, plugins) {
      var _a2;
      var handlers2;
      this.customHandlers = [];
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = plugins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var plugin = _step.value;
          if ((handlers2 = (_a2 = plugin.update(view).spec) === null || _a2 === void 0 ? void 0 : _a2.domEventHandlers)) {
            var _this = this,
              _loop = function (type) {
                if (_this.registeredEvents.indexOf(type) < 0 && type != "scroll") {
                  _this.registeredEvents.push(type);
                  view.contentDOM.addEventListener(type, (event) => {
                    if (!eventBelongsToEditor(view, event)) return;
                    if (_this.runCustomHandlers(type, view, event)) event.preventDefault();
                  });
                }
              };
            this.customHandlers.push({
              plugin: plugin.value,
              handlers: handlers2,
            });
            for (var type in handlers2) _loop(type);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    runCustomHandlers(type, view, event) {
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.customHandlers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var set = _step.value;
          var handler = set.handlers[type];
          if (handler) {
            try {
              if (handler.call(set.plugin, event, view) || event.defaultPrevented) return true;
            } catch (e) {
              logException(view.state, e);
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return false;
    }
    runScrollHandlers(view, event) {
      this.lastScrollTop = view.scrollDOM.scrollTop;
      this.lastScrollLeft = view.scrollDOM.scrollLeft;
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.customHandlers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var set = _step.value;
          var handler = set.handlers.scroll;
          if (handler) {
            try {
              handler.call(set.plugin, event, view);
            } catch (e) {
              logException(view.state, e);
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    keydown(view, event) {
      this.lastKeyCode = event.keyCode;
      this.lastKeyTime = Date.now();
      if (event.keyCode == 9 && Date.now() < this.lastEscPress + 2e3) return true;
      if (browser.android && browser.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {
        view.observer.delayAndroidKey(event.key, event.keyCode);
        return true;
      }
      var pending;
      if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey && (((pending = PendingKeys.find((key) => key.keyCode == event.keyCode)) && !event.ctrlKey) || (EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey))) {
        this.pendingIOSKey = pending || event;
        setTimeout(() => this.flushIOSKey(view), 250);
        return true;
      }
      return false;
    }
    flushIOSKey(view) {
      var key = this.pendingIOSKey;
      if (!key) return false;
      this.pendingIOSKey = void 0;
      return dispatchKey(view.contentDOM, key.key, key.keyCode);
    }
    ignoreDuringComposition(event) {
      if (!/^key/.test(event.type)) return false;
      if (this.composing > 0) return true;
      if (browser.safari && !browser.ios && Date.now() - this.compositionEndedAt < 100) {
        this.compositionEndedAt = 0;
        return true;
      }
      return false;
    }
    mustFlushObserver(event) {
      return event.type == "keydown" && event.keyCode != 229;
    }
    startMouseSelection(mouseSelection) {
      if (this.mouseSelection) this.mouseSelection.destroy();
      this.mouseSelection = mouseSelection;
    }
    update(update2) {
      if (this.mouseSelection) this.mouseSelection.update(update2);
      if (update2.transactions.length) this.lastKeyCode = this.lastSelectionTime = 0;
    }
    destroy() {
      if (this.mouseSelection) this.mouseSelection.destroy();
    }
    constructor(view) {
      var _this = this,
        _loop = function (type) {
          var handler = handlers[type];
          view.contentDOM.addEventListener(
            type,
            (event) => {
              if (!eventBelongsToEditor(view, event) || _this.ignoreDuringComposition(event)) return;
              if (type == "keydown" && _this.keydown(view, event)) return;
              if (_this.mustFlushObserver(event)) view.observer.forceFlush();
              if (_this.runCustomHandlers(type, view, event)) event.preventDefault();
              else handler(view, event);
            },
            handlerOptions[type]
          );
          _this.registeredEvents.push(type);
        };
      this.lastKeyCode = 0;
      this.lastKeyTime = 0;
      this.lastTouchTime = 0;
      this.lastFocusTime = 0;
      this.lastScrollTop = 0;
      this.lastScrollLeft = 0;
      this.chromeScrollHack = -1;
      this.pendingIOSKey = void 0;
      this.lastSelectionOrigin = null;
      this.lastSelectionTime = 0;
      this.lastEscPress = 0;
      this.lastContextMenu = 0;
      this.scrollHandlers = [];
      this.registeredEvents = [];
      this.customHandlers = [];
      this.composing = -1;
      this.compositionFirstChange = null;
      this.compositionEndedAt = 0;
      this.mouseSelection = null;
      for (var type in handlers) _loop(type);
      if (browser.chrome && browser.chrome_version == 102) {
        view.scrollDOM.addEventListener(
          "wheel",
          () => {
            if (this.chromeScrollHack < 0) view.contentDOM.style.pointerEvents = "none";
            else window.clearTimeout(this.chromeScrollHack);
            this.chromeScrollHack = setTimeout(() => {
              this.chromeScrollHack = -1;
              view.contentDOM.style.pointerEvents = "";
            }, 100);
          },
          {
            passive: true,
          }
        );
      }
      this.notifiedFocused = view.hasFocus;
      if (browser.safari) view.contentDOM.addEventListener("input", () => null);
    }
  };
  __name(InputState, "InputState");
  var PendingKeys = [
    {
      key: "Backspace",
      keyCode: 8,
      inputType: "deleteContentBackward",
    },
    {
      key: "Enter",
      keyCode: 13,
      inputType: "insertParagraph",
    },
    {
      key: "Delete",
      keyCode: 46,
      inputType: "deleteContentForward",
    },
  ];
  var EmacsyPendingKeys = "dthko";
  var modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
  var MouseSelection = class MouseSelection {
    move(event) {
      if (event.buttons == 0) return this.destroy();
      if (this.dragging !== false) return;
      this.select((this.lastEvent = event));
    }
    up(event) {
      if (this.dragging == null) this.select(this.lastEvent);
      if (!this.dragging) event.preventDefault();
      this.destroy();
    }
    destroy() {
      var doc2 = this.view.contentDOM.ownerDocument;
      doc2.removeEventListener("mousemove", this.move);
      doc2.removeEventListener("mouseup", this.up);
      this.view.inputState.mouseSelection = null;
    }
    select(event) {
      var selection = this.style.get(event, this.extend, this.multiple);
      if (this.mustSelect || !selection.eq(this.view.state.selection) || selection.main.assoc != this.view.state.selection.main.assoc)
        this.view.dispatch({
          selection,
          userEvent: "select.pointer",
          scrollIntoView: true,
        });
      this.mustSelect = false;
    }
    update(update2) {
      if (update2.docChanged && this.dragging) this.dragging = this.dragging.map(update2.changes);
      if (this.style.update(update2)) setTimeout(() => this.select(this.lastEvent), 20);
    }
    constructor(view, startEvent, style, mustSelect) {
      this.view = view;
      this.style = style;
      this.mustSelect = mustSelect;
      this.lastEvent = startEvent;
      var doc2 = view.contentDOM.ownerDocument;
      doc2.addEventListener("mousemove", (this.move = this.move.bind(this)));
      doc2.addEventListener("mouseup", (this.up = this.up.bind(this)));
      this.extend = startEvent.shiftKey;
      this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
      this.dragMove = dragMovesSelection(view, startEvent);
      this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
      if (this.dragging === false) {
        startEvent.preventDefault();
        this.select(startEvent);
      }
    }
  };
  __name(MouseSelection, "MouseSelection");
  function addsSelectionRange(view, event) {
    var facet = view.state.facet(clickAddsSelectionRange);
    return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
  }
  __name(addsSelectionRange, "addsSelectionRange");
  function dragMovesSelection(view, event) {
    var facet = view.state.facet(dragMovesSelection$1);
    return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
  }
  __name(dragMovesSelection, "dragMovesSelection");
  function isInPrimarySelection(view, event) {
    var main = view.state.selection.main;
    if (main.empty) return false;
    var sel = getSelection(view.root);
    if (!sel || sel.rangeCount == 0) return true;
    var rects = sel.getRangeAt(0).getClientRects();
    for (var i = 0; i < rects.length; i++) {
      var rect = rects[i];
      if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY) return true;
    }
    return false;
  }
  __name(isInPrimarySelection, "isInPrimarySelection");
  function eventBelongsToEditor(view, event) {
    if (!event.bubbles) return true;
    if (event.defaultPrevented) return false;
    for (var node = event.target, cView; node != view.contentDOM; node = node.parentNode) if (!node || node.nodeType == 11 || ((cView = ContentView.get(node)) && cView.ignoreEvent(event))) return false;
    return true;
  }
  __name(eventBelongsToEditor, "eventBelongsToEditor");
  var handlers = /* @__PURE__ */ Object.create(null);
  var handlerOptions = /* @__PURE__ */ Object.create(null);
  var brokenClipboardAPI = (browser.ie && browser.ie_version < 15) || (browser.ios && browser.webkit_version < 604);
  function capturePaste(view) {
    var parent = view.dom.parentNode;
    if (!parent) return;
    var target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.focus();
    setTimeout(() => {
      view.focus();
      target.remove();
      doPaste(view, target.value);
    }, 50);
  }
  __name(capturePaste, "capturePaste");
  function doPaste(view, input) {
    var state = view.state,
      changes,
      i = 1,
      text2 = state.toText(input);
    var byLine = text2.lines == state.selection.ranges.length;
    var linewise = lastLinewiseCopy != null && state.selection.ranges.every((r) => r.empty) && lastLinewiseCopy == text2.toString();
    if (linewise) {
      var lastLine = -1;
      changes = state.changeByRange((range) => {
        var line = state.doc.lineAt(range.from);
        if (line.from == lastLine)
          return {
            range,
          };
        lastLine = line.from;
        var insert3 = state.toText((byLine ? text2.line(i++).text : input) + state.lineBreak);
        return {
          changes: {
            from: line.from,
            insert: insert3,
          },
          range: EditorSelection.cursor(range.from + insert3.length),
        };
      });
    } else if (byLine) {
      changes = state.changeByRange((range) => {
        var line = text2.line(i++);
        return {
          changes: {
            from: range.from,
            to: range.to,
            insert: line.text,
          },
          range: EditorSelection.cursor(range.from + line.length),
        };
      });
    } else {
      changes = state.replaceSelection(text2);
    }
    view.dispatch(changes, {
      userEvent: "input.paste",
      scrollIntoView: true,
    });
  }
  __name(doPaste, "doPaste");
  handlers.keydown = (view, event) => {
    view.inputState.setSelectionOrigin("select");
    if (event.keyCode == 27) view.inputState.lastEscPress = Date.now();
    else if (modifierCodes.indexOf(event.keyCode) < 0) view.inputState.lastEscPress = 0;
  };
  handlers.touchstart = (view, e) => {
    view.inputState.lastTouchTime = Date.now();
    view.inputState.setSelectionOrigin("select.pointer");
  };
  handlers.touchmove = (view) => {
    view.inputState.setSelectionOrigin("select.pointer");
  };
  handlerOptions.touchstart = handlerOptions.touchmove = {
    passive: true,
  };
  handlers.mousedown = (view, event) => {
    view.observer.flush();
    if (view.inputState.lastTouchTime > Date.now() - 2e3) return;
    var style = null;
    var _iteratorNormalCompletion = true,
      _didIteratorError = false,
      _iteratorError = undefined;
    try {
      for (var _iterator = view.state.facet(mouseSelectionStyle)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var makeStyle = _step.value;
        style = makeStyle(view, event);
        if (style) break;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    if (!style && event.button == 0) style = basicMouseSelection(view, event);
    if (style) {
      var mustFocus = view.root.activeElement != view.contentDOM;
      if (mustFocus) view.observer.ignore(() => focusPreventScroll(view.contentDOM));
      view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));
    }
  };
  function rangeForClick(view, pos, bias, type) {
    if (type == 1) {
      return EditorSelection.cursor(pos, bias);
    } else if (type == 2) {
      return groupAt(view.state, pos, bias);
    } else {
      var visual = LineView.find(view.docView, pos),
        line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
      var from = visual ? visual.posAtStart : line.from,
        to = visual ? visual.posAtEnd : line.to;
      if (to < view.state.doc.length && to == line.to) to++;
      return EditorSelection.range(from, to);
    }
  }
  __name(rangeForClick, "rangeForClick");
  var insideY = /* @__PURE__ */ __name((y, rect) => y >= rect.top && y <= rect.bottom, "insideY");
  var inside = /* @__PURE__ */ __name((x, y, rect) => insideY(y, rect) && x >= rect.left && x <= rect.right, "inside");
  function findPositionSide(view, pos, x, y) {
    var line = LineView.find(view.docView, pos);
    if (!line) return 1;
    var off = pos - line.posAtStart;
    if (off == 0) return 1;
    if (off == line.length) return -1;
    var before = line.coordsAt(off, -1);
    if (before && inside(x, y, before)) return -1;
    var after = line.coordsAt(off, 1);
    if (after && inside(x, y, after)) return 1;
    return before && insideY(y, before) ? -1 : 1;
  }
  __name(findPositionSide, "findPositionSide");
  function queryPos(view, event) {
    var pos = view.posAtCoords(
      {
        x: event.clientX,
        y: event.clientY,
      },
      false
    );
    return {
      pos,
      bias: findPositionSide(view, pos, event.clientX, event.clientY),
    };
  }
  __name(queryPos, "queryPos");
  var BadMouseDetail = browser.ie && browser.ie_version <= 11;
  var lastMouseDown = null;
  var lastMouseDownCount = 0;
  var lastMouseDownTime = 0;
  function getClickType(event) {
    if (!BadMouseDetail) return event.detail;
    var last = lastMouseDown,
      lastTime = lastMouseDownTime;
    lastMouseDown = event;
    lastMouseDownTime = Date.now();
    return (lastMouseDownCount = !last || (lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2) ? (lastMouseDownCount + 1) % 3 : 1);
  }
  __name(getClickType, "getClickType");
  function basicMouseSelection(view, event) {
    var start = queryPos(view, event),
      type = getClickType(event);
    var startSel = view.state.selection;
    var last = start,
      lastEvent = event;
    return {
      update(update2) {
        if (update2.docChanged) {
          start.pos = update2.changes.mapPos(start.pos);
          startSel = startSel.map(update2.changes);
          lastEvent = null;
        }
      },
      get(event2, extend2, multiple) {
        var cur;
        if (lastEvent && event2.clientX == lastEvent.clientX && event2.clientY == lastEvent.clientY) cur = last;
        else {
          cur = last = queryPos(view, event2);
          lastEvent = event2;
        }
        var range = rangeForClick(view, cur.pos, cur.bias, type);
        if (start.pos != cur.pos && !extend2) {
          var startRange = rangeForClick(view, start.pos, start.bias, type);
          var from = Math.min(startRange.from, range.from),
            to = Math.max(startRange.to, range.to);
          range = from < range.from ? EditorSelection.range(from, to) : EditorSelection.range(to, from);
        }
        if (extend2) return startSel.replaceRange(startSel.main.extend(range.from, range.to));
        else if (multiple && startSel.ranges.length > 1 && startSel.ranges.some((r) => r.eq(range))) return removeRange(startSel, range);
        else if (multiple) return startSel.addRange(range);
        else return EditorSelection.create([range]);
      },
    };
  }
  __name(basicMouseSelection, "basicMouseSelection");
  function removeRange(sel, range) {
    for (var i = 0; ; i++) {
      if (sel.ranges[i].eq(range)) return EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));
    }
  }
  __name(removeRange, "removeRange");
  handlers.dragstart = (view, event) => {
    var _view_state = view.state,
      main = _view_state.selection.main;
    var mouseSelection = view.inputState.mouseSelection;
    if (mouseSelection) mouseSelection.dragging = main;
    if (event.dataTransfer) {
      event.dataTransfer.setData("Text", view.state.sliceDoc(main.from, main.to));
      event.dataTransfer.effectAllowed = "copyMove";
    }
  };
  function dropText(view, event, text2, direct) {
    if (!text2) return;
    var dropPos = view.posAtCoords(
      {
        x: event.clientX,
        y: event.clientY,
      },
      false
    );
    event.preventDefault();
    var mouseSelection = view.inputState.mouseSelection;
    var del =
      direct && mouseSelection && mouseSelection.dragging && mouseSelection.dragMove
        ? {
            from: mouseSelection.dragging.from,
            to: mouseSelection.dragging.to,
          }
        : null;
    var ins = {
      from: dropPos,
      insert: text2,
    };
    var changes = view.state.changes(del ? [del, ins] : ins);
    view.focus();
    view.dispatch({
      changes,
      selection: {
        anchor: changes.mapPos(dropPos, -1),
        head: changes.mapPos(dropPos, 1),
      },
      userEvent: del ? "move.drop" : "input.drop",
    });
  }
  __name(dropText, "dropText");
  handlers.drop = (view, event) => {
    if (!event.dataTransfer) return;
    if (view.state.readOnly) return event.preventDefault();
    var files = event.dataTransfer.files;
    if (files && files.length) {
      var _loop = function (i) {
        var reader = new FileReader();
        reader.onerror = finishFile;
        reader.onload = () => {
          if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result)) text2[i] = reader.result;
          finishFile();
        };
        reader.readAsText(files[i]);
      };
      event.preventDefault();
      var text2 = Array(files.length),
        read = 0;
      var finishFile = /* @__PURE__ */ __name(() => {
        if (++read == files.length) dropText(view, event, text2.filter((s) => s != null).join(view.state.lineBreak), false);
      }, "finishFile");
      for (var i = 0; i < files.length; i++) _loop(i);
    } else {
      dropText(view, event, event.dataTransfer.getData("Text"), true);
    }
  };
  handlers.paste = (view, event) => {
    if (view.state.readOnly) return event.preventDefault();
    view.observer.flush();
    var data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
      doPaste(view, data.getData("text/plain"));
      event.preventDefault();
    } else {
      capturePaste(view);
    }
  };
  function captureCopy(view, text2) {
    var parent = view.dom.parentNode;
    if (!parent) return;
    var target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.value = text2;
    target.focus();
    target.selectionEnd = text2.length;
    target.selectionStart = 0;
    setTimeout(() => {
      target.remove();
      view.focus();
    }, 50);
  }
  __name(captureCopy, "captureCopy");
  function copiedRange(state) {
    var content2 = [],
      ranges = [],
      linewise = false;
    var _iteratorNormalCompletion = true,
      _didIteratorError = false,
      _iteratorError = undefined;
    try {
      for (var _iterator = state.selection.ranges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var range = _step.value;
        if (!range.empty) {
          content2.push(state.sliceDoc(range.from, range.to));
          ranges.push(range);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    if (!content2.length) {
      var upto = -1;
      var _iteratorNormalCompletion1 = true,
        _didIteratorError1 = false,
        _iteratorError1 = undefined;
      try {
        for (var _iterator1 = state.selection.ranges[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
          var from = _step1.value.from;
          var line = state.doc.lineAt(from);
          if (line.number > upto) {
            content2.push(line.text);
            ranges.push({
              from: line.from,
              to: Math.min(state.doc.length, line.to + 1),
            });
          }
          upto = line.number;
        }
      } catch (err) {
        _didIteratorError1 = true;
        _iteratorError1 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
            _iterator1.return();
          }
        } finally {
          if (_didIteratorError1) {
            throw _iteratorError1;
          }
        }
      }
      linewise = true;
    }
    return {
      text: content2.join(state.lineBreak),
      ranges,
      linewise,
    };
  }
  __name(copiedRange, "copiedRange");
  var lastLinewiseCopy = null;
  handlers.copy = handlers.cut = (view, event) => {
    var _copiedRange = copiedRange(view.state),
      text2 = _copiedRange.text,
      ranges = _copiedRange.ranges,
      linewise = _copiedRange.linewise;
    if (!text2 && !linewise) return;
    lastLinewiseCopy = linewise ? text2 : null;
    var data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
      event.preventDefault();
      data.clearData();
      data.setData("text/plain", text2);
    } else {
      captureCopy(view, text2);
    }
    if (event.type == "cut" && !view.state.readOnly)
      view.dispatch({
        changes: ranges,
        scrollIntoView: true,
        userEvent: "delete.cut",
      });
  };
  function updateForFocusChange(view) {
    setTimeout(() => {
      if (view.hasFocus != view.inputState.notifiedFocused) view.update([]);
    }, 10);
  }
  __name(updateForFocusChange, "updateForFocusChange");
  handlers.focus = (view) => {
    view.inputState.lastFocusTime = Date.now();
    if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
      view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
      view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
    }
    updateForFocusChange(view);
  };
  handlers.blur = (view) => {
    view.observer.clearSelectionRange();
    updateForFocusChange(view);
  };
  handlers.compositionstart = handlers.compositionupdate = (view) => {
    if (view.inputState.compositionFirstChange == null) view.inputState.compositionFirstChange = true;
    if (view.inputState.composing < 0) {
      view.inputState.composing = 0;
    }
  };
  handlers.compositionend = (view) => {
    view.inputState.composing = -1;
    view.inputState.compositionEndedAt = Date.now();
    view.inputState.compositionFirstChange = null;
    if (browser.chrome && browser.android) view.observer.flushSoon();
    setTimeout(() => {
      if (view.inputState.composing < 0 && view.docView.compositionDeco.size) view.update([]);
    }, 50);
  };
  handlers.contextmenu = (view) => {
    view.inputState.lastContextMenu = Date.now();
  };
  handlers.beforeinput = (view, event) => {
    var _a2;
    var pending;
    if (browser.chrome && browser.android && (pending = PendingKeys.find((key) => key.inputType == event.inputType))) {
      view.observer.delayAndroidKey(pending.key, pending.keyCode);
      if (pending.key == "Backspace" || pending.key == "Delete") {
        var startViewHeight = ((_a2 = window.visualViewport) === null || _a2 === void 0 ? void 0 : _a2.height) || 0;
        setTimeout(() => {
          var _a3;
          if ((((_a3 = window.visualViewport) === null || _a3 === void 0 ? void 0 : _a3.height) || 0) > startViewHeight + 10 && view.hasFocus) {
            view.contentDOM.blur();
            view.focus();
          }
        }, 100);
      }
    }
  };
  var wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
  var HeightOracle = class HeightOracle {
    heightForGap(from, to) {
      var lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
      if (this.lineWrapping) lines += Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength);
      return this.lineHeight * lines;
    }
    heightForLine(length) {
      if (!this.lineWrapping) return this.lineHeight;
      var lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));
      return lines * this.lineHeight;
    }
    setDoc(doc2) {
      this.doc = doc2;
      return this;
    }
    mustRefreshForWrapping(whiteSpace) {
      return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;
    }
    mustRefreshForHeights(lineHeights) {
      var newHeight = false;
      for (var i = 0; i < lineHeights.length; i++) {
        var h = lineHeights[i];
        if (h < 0) {
          i++;
        } else if (!this.heightSamples[Math.floor(h * 10)]) {
          newHeight = true;
          this.heightSamples[Math.floor(h * 10)] = true;
        }
      }
      return newHeight;
    }
    refresh(whiteSpace, lineHeight, charWidth, lineLength, knownHeights) {
      var lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
      var changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
      this.lineWrapping = lineWrapping;
      this.lineHeight = lineHeight;
      this.charWidth = charWidth;
      this.lineLength = lineLength;
      if (changed) {
        this.heightSamples = {};
        for (var i = 0; i < knownHeights.length; i++) {
          var h = knownHeights[i];
          if (h < 0) i++;
          else this.heightSamples[Math.floor(h * 10)] = true;
        }
      }
      return changed;
    }
    constructor(lineWrapping) {
      this.lineWrapping = lineWrapping;
      this.doc = Text.empty;
      this.heightSamples = {};
      this.lineHeight = 14;
      this.charWidth = 7;
      this.lineLength = 30;
      this.heightChanged = false;
    }
  };
  __name(HeightOracle, "HeightOracle");
  var MeasuredHeights = class MeasuredHeights {
    get more() {
      return this.index < this.heights.length;
    }
    constructor(from, heights) {
      this.from = from;
      this.heights = heights;
      this.index = 0;
    }
  };
  __name(MeasuredHeights, "MeasuredHeights");
  var BlockInfo = class BlockInfo1 {
    get to() {
      return this.from + this.length;
    }
    get bottom() {
      return this.top + this.height;
    }
    join(other) {
      var detail = (Array.isArray(this.type) ? this.type : [this]).concat(Array.isArray(other.type) ? other.type : [other]);
      return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, detail);
    }
    constructor(from, length, top2, height, type) {
      this.from = from;
      this.length = length;
      this.top = top2;
      this.height = height;
      this.type = type;
    }
  };
  __name(BlockInfo, "BlockInfo");
  var QueryType = /* @__PURE__ */ (function (QueryType2) {
    QueryType2[(QueryType2["ByPos"] = 0)] = "ByPos";
    QueryType2[(QueryType2["ByHeight"] = 1)] = "ByHeight";
    QueryType2[(QueryType2["ByPosNoHeight"] = 2)] = "ByPosNoHeight";
    return QueryType2;
  })(QueryType || (QueryType = {}));
  var Epsilon = 1e-3;
  var HeightMap = class HeightMap1 {
    get outdated() {
      return (this.flags & 2) > 0;
    }
    set outdated(value) {
      this.flags = (value ? 2 : 0) | (this.flags & ~2);
    }
    setHeight(oracle, height) {
      if (this.height != height) {
        if (Math.abs(this.height - height) > Epsilon) oracle.heightChanged = true;
        this.height = height;
      }
    }
    replace(_from, _to, nodes) {
      return HeightMap.of(nodes);
    }
    decomposeLeft(_to, result) {
      result.push(this);
    }
    decomposeRight(_from, result) {
      result.push(this);
    }
    applyChanges(decorations2, oldDoc, oracle, changes) {
      var me = this;
      for (var i = changes.length - 1; i >= 0; i--) {
        var _changes_i = changes[i],
          fromA = _changes_i.fromA,
          toA = _changes_i.toA,
          fromB = _changes_i.fromB,
          toB = _changes_i.toB;
        var start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
        var end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
        toB += end.to - toA;
        toA = end.to;
        while (i > 0 && start.from <= changes[i - 1].toA) {
          fromA = changes[i - 1].fromA;
          fromB = changes[i - 1].fromB;
          i--;
          if (fromA < start.from) start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
        }
        fromB += start.from - fromA;
        fromA = start.from;
        var nodes = NodeBuilder.build(oracle, decorations2, fromB, toB);
        me = me.replace(fromA, toA, nodes);
      }
      return me.updateHeight(oracle, 0);
    }
    static empty() {
      return new HeightMapText(0, 0);
    }
    static of(nodes) {
      if (nodes.length == 1) return nodes[0];
      var i = 0,
        j = nodes.length,
        before = 0,
        after = 0;
      for (;;) {
        if (i == j) {
          if (before > after * 2) {
            var split = nodes[i - 1];
            if (split.break) nodes.splice(--i, 1, split.left, null, split.right);
            else nodes.splice(--i, 1, split.left, split.right);
            j += 1 + split.break;
            before -= split.size;
          } else if (after > before * 2) {
            var split1 = nodes[j];
            if (split1.break) nodes.splice(j, 1, split1.left, null, split1.right);
            else nodes.splice(j, 1, split1.left, split1.right);
            j += 2 + split1.break;
            after -= split1.size;
          } else {
            break;
          }
        } else if (before < after) {
          var next = nodes[i++];
          if (next) before += next.size;
        } else {
          var next1 = nodes[--j];
          if (next1) after += next1.size;
        }
      }
      var brk = 0;
      if (nodes[i - 1] == null) {
        brk = 1;
        i--;
      } else if (nodes[i] == null) {
        brk = 1;
        j++;
      }
      return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));
    }
    constructor(length, height, ref) {
      var flags = ref === void 0 ? 2 : ref;
      this.length = length;
      this.height = height;
      this.flags = flags;
    }
  };
  __name(HeightMap, "HeightMap");
  HeightMap.prototype.size = 1;
  var HeightMapBlock = class HeightMapBlock extends HeightMap {
    blockAt(_height, _doc, top2, offset) {
      return new BlockInfo(offset, this.length, top2, this.height, this.type);
    }
    lineAt(_value, _type, doc2, top2, offset) {
      return this.blockAt(0, doc2, top2, offset);
    }
    forEachLine(from, to, doc2, top2, offset, f) {
      if (from <= offset + this.length && to >= offset) f(this.blockAt(0, doc2, top2, offset));
    }
    updateHeight(oracle) {
      var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
        _force = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false,
        measured = arguments.length > 3 ? arguments[3] : void 0;
      if (measured && measured.from <= offset && measured.more) this.setHeight(oracle, measured.heights[measured.index++]);
      this.outdated = false;
      return this;
    }
    toString() {
      return "block(".concat(this.length, ")");
    }
    constructor(length, height, type) {
      super(length, height);
      this.type = type;
    }
  };
  __name(HeightMapBlock, "HeightMapBlock");
  var HeightMapText = class HeightMapText1 extends HeightMapBlock {
    replace(_from, _to, nodes) {
      var node = nodes[0];
      if (nodes.length == 1 && (node instanceof HeightMapText || (node instanceof HeightMapGap && node.flags & 4)) && Math.abs(this.length - node.length) < 10) {
        if (node instanceof HeightMapGap) node = new HeightMapText(node.length, this.height);
        else node.height = this.height;
        if (!this.outdated) node.outdated = false;
        return node;
      } else {
        return HeightMap.of(nodes);
      }
    }
    updateHeight(oracle) {
      var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
        force = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false,
        measured = arguments.length > 3 ? arguments[3] : void 0;
      if (measured && measured.from <= offset && measured.more) this.setHeight(oracle, measured.heights[measured.index++]);
      else if (force || this.outdated) this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)));
      this.outdated = false;
      return this;
    }
    toString() {
      return "line("
        .concat(this.length)
        .concat(this.collapsed ? -this.collapsed : "")
        .concat(this.widgetHeight ? ":" + this.widgetHeight : "", ")");
    }
    constructor(length, height) {
      super(length, height, BlockType.Text);
      this.collapsed = 0;
      this.widgetHeight = 0;
    }
  };
  __name(HeightMapText, "HeightMapText");
  var HeightMapGap = class HeightMapGap1 extends HeightMap {
    lines(doc2, offset) {
      var firstLine = doc2.lineAt(offset).number,
        lastLine = doc2.lineAt(offset + this.length).number;
      return {
        firstLine,
        lastLine,
        lineHeight: this.height / (lastLine - firstLine + 1),
      };
    }
    blockAt(height, doc2, top2, offset) {
      var _this_lines = this.lines(doc2, offset),
        firstLine = _this_lines.firstLine,
        lastLine = _this_lines.lastLine,
        lineHeight = _this_lines.lineHeight;
      var line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top2) / lineHeight)));
      var _doc2_line = doc2.line(firstLine + line),
        from = _doc2_line.from,
        length = _doc2_line.length;
      return new BlockInfo(from, length, top2 + lineHeight * line, lineHeight, BlockType.Text);
    }
    lineAt(value, type, doc2, top2, offset) {
      if (type == QueryType.ByHeight) return this.blockAt(value, doc2, top2, offset);
      if (type == QueryType.ByPosNoHeight) {
        var _doc2_lineAt = doc2.lineAt(value),
          from2 = _doc2_lineAt.from,
          to = _doc2_lineAt.to;
        return new BlockInfo(from2, to - from2, 0, 0, BlockType.Text);
      }
      var _this_lines = this.lines(doc2, offset),
        firstLine = _this_lines.firstLine,
        lineHeight = _this_lines.lineHeight;
      var _doc2_lineAt1 = doc2.lineAt(value),
        from = _doc2_lineAt1.from,
        length = _doc2_lineAt1.length,
        number2 = _doc2_lineAt1.number;
      return new BlockInfo(from, length, top2 + lineHeight * (number2 - firstLine), lineHeight, BlockType.Text);
    }
    forEachLine(from, to, doc2, top2, offset, f) {
      var _this_lines = this.lines(doc2, offset),
        firstLine = _this_lines.firstLine,
        lineHeight = _this_lines.lineHeight;
      for (var pos = Math.max(from, offset), end = Math.min(offset + this.length, to); pos <= end; ) {
        var line = doc2.lineAt(pos);
        if (pos == from) top2 += lineHeight * (line.number - firstLine);
        f(new BlockInfo(line.from, line.length, top2, lineHeight, BlockType.Text));
        top2 += lineHeight;
        pos = line.to + 1;
      }
    }
    replace(from, to, nodes) {
      var after = this.length - to;
      if (after > 0) {
        var last = nodes[nodes.length - 1];
        if (last instanceof HeightMapGap) nodes[nodes.length - 1] = new HeightMapGap(last.length + after);
        else nodes.push(null, new HeightMapGap(after - 1));
      }
      if (from > 0) {
        var first = nodes[0];
        if (first instanceof HeightMapGap) nodes[0] = new HeightMapGap(from + first.length);
        else nodes.unshift(new HeightMapGap(from - 1), null);
      }
      return HeightMap.of(nodes);
    }
    decomposeLeft(to, result) {
      result.push(new HeightMapGap(to - 1), null);
    }
    decomposeRight(from, result) {
      result.push(null, new HeightMapGap(this.length - from - 1));
    }
    updateHeight(oracle) {
      var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
        force = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false,
        measured = arguments.length > 3 ? arguments[3] : void 0;
      var end = offset + this.length;
      if (measured && measured.from <= offset + this.length && measured.more) {
        var nodes = [],
          pos = Math.max(offset, measured.from),
          singleHeight = -1;
        var wasChanged = oracle.heightChanged;
        if (measured.from > offset) nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
        while (pos <= end && measured.more) {
          var len = oracle.doc.lineAt(pos).length;
          if (nodes.length) nodes.push(null);
          var height = measured.heights[measured.index++];
          if (singleHeight == -1) singleHeight = height;
          else if (Math.abs(height - singleHeight) >= Epsilon) singleHeight = -2;
          var line = new HeightMapText(len, height);
          line.outdated = false;
          nodes.push(line);
          pos += len + 1;
        }
        if (pos <= end) nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
        var result = HeightMap.of(nodes);
        oracle.heightChanged = wasChanged || singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.lines(oracle.doc, offset).lineHeight) >= Epsilon;
        return result;
      } else if (force || this.outdated) {
        this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));
        this.outdated = false;
      }
      return this;
    }
    toString() {
      return "gap(".concat(this.length, ")");
    }
    constructor(length) {
      super(length, 0);
    }
  };
  __name(HeightMapGap, "HeightMapGap");
  var HeightMapBranch = class HeightMapBranch extends HeightMap {
    get break() {
      return this.flags & 1;
    }
    blockAt(height, doc2, top2, offset) {
      var mid = top2 + this.left.height;
      return height < mid ? this.left.blockAt(height, doc2, top2, offset) : this.right.blockAt(height, doc2, mid, offset + this.left.length + this.break);
    }
    lineAt(value, type, doc2, top2, offset) {
      var rightTop = top2 + this.left.height,
        rightOffset = offset + this.left.length + this.break;
      var left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;
      var base2 = left ? this.left.lineAt(value, type, doc2, top2, offset) : this.right.lineAt(value, type, doc2, rightTop, rightOffset);
      if (this.break || (left ? base2.to < rightOffset : base2.from > rightOffset)) return base2;
      var subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
      if (left) return base2.join(this.right.lineAt(rightOffset, subQuery, doc2, rightTop, rightOffset));
      else return this.left.lineAt(rightOffset, subQuery, doc2, top2, offset).join(base2);
    }
    forEachLine(from, to, doc2, top2, offset, f) {
      var rightTop = top2 + this.left.height,
        rightOffset = offset + this.left.length + this.break;
      if (this.break) {
        if (from < rightOffset) this.left.forEachLine(from, to, doc2, top2, offset, f);
        if (to >= rightOffset) this.right.forEachLine(from, to, doc2, rightTop, rightOffset, f);
      } else {
        var mid = this.lineAt(rightOffset, QueryType.ByPos, doc2, top2, offset);
        if (from < mid.from) this.left.forEachLine(from, mid.from - 1, doc2, top2, offset, f);
        if (mid.to >= from && mid.from <= to) f(mid);
        if (to > mid.to) this.right.forEachLine(mid.to + 1, to, doc2, rightTop, rightOffset, f);
      }
    }
    replace(from, to, nodes) {
      var rightStart = this.left.length + this.break;
      if (to < rightStart) return this.balanced(this.left.replace(from, to, nodes), this.right);
      if (from > this.left.length) return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
      var result = [];
      if (from > 0) this.decomposeLeft(from, result);
      var left = result.length;
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var node = _step.value;
          result.push(node);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      if (from > 0) mergeGaps(result, left - 1);
      if (to < this.length) {
        var right = result.length;
        this.decomposeRight(to, result);
        mergeGaps(result, right);
      }
      return HeightMap.of(result);
    }
    decomposeLeft(to, result) {
      var left = this.left.length;
      if (to <= left) return this.left.decomposeLeft(to, result);
      result.push(this.left);
      if (this.break) {
        left++;
        if (to >= left) result.push(null);
      }
      if (to > left) this.right.decomposeLeft(to - left, result);
    }
    decomposeRight(from, result) {
      var left = this.left.length,
        right = left + this.break;
      if (from >= right) return this.right.decomposeRight(from - right, result);
      if (from < left) this.left.decomposeRight(from, result);
      if (this.break && from < right) result.push(null);
      result.push(this.right);
    }
    balanced(left, right) {
      if (left.size > 2 * right.size || right.size > 2 * left.size) return HeightMap.of(this.break ? [left, null, right] : [left, right]);
      this.left = left;
      this.right = right;
      this.height = left.height + right.height;
      this.outdated = left.outdated || right.outdated;
      this.size = left.size + right.size;
      this.length = left.length + this.break + right.length;
      return this;
    }
    updateHeight(oracle) {
      var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
        force = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false,
        measured = arguments.length > 3 ? arguments[3] : void 0;
      var _this = this,
        left = _this.left,
        right = _this.right,
        rightStart = offset + left.length + this.break,
        rebalance = null;
      if (measured && measured.from <= offset + left.length && measured.more) rebalance = left = left.updateHeight(oracle, offset, force, measured);
      else left.updateHeight(oracle, offset, force);
      if (measured && measured.from <= rightStart + right.length && measured.more) rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
      else right.updateHeight(oracle, rightStart, force);
      if (rebalance) return this.balanced(left, right);
      this.height = this.left.height + this.right.height;
      this.outdated = false;
      return this;
    }
    toString() {
      return this.left + (this.break ? " " : "-") + this.right;
    }
    constructor(left, brk, right) {
      super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));
      this.left = left;
      this.right = right;
      this.size = left.size + right.size;
    }
  };
  __name(HeightMapBranch, "HeightMapBranch");
  function mergeGaps(nodes, around) {
    var before, after;
    if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap) nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
  }
  __name(mergeGaps, "mergeGaps");
  var relevantWidgetHeight = 5;
  var NodeBuilder = class NodeBuilder1 {
    get isCovered() {
      return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
    }
    span(_from, to) {
      if (this.lineStart > -1) {
        var end = Math.min(to, this.lineEnd),
          last = this.nodes[this.nodes.length - 1];
        if (last instanceof HeightMapText) last.length += end - this.pos;
        else if (end > this.pos || !this.isCovered) this.nodes.push(new HeightMapText(end - this.pos, -1));
        this.writtenTo = end;
        if (to > end) {
          this.nodes.push(null);
          this.writtenTo++;
          this.lineStart = -1;
        }
      }
      this.pos = to;
    }
    point(from, to, deco) {
      if (from < to || deco.heightRelevant) {
        var height = deco.widget ? deco.widget.estimatedHeight : 0;
        if (height < 0) height = this.oracle.lineHeight;
        var len = to - from;
        if (deco.block) {
          this.addBlock(new HeightMapBlock(len, height, deco.type));
        } else if (len || height >= relevantWidgetHeight) {
          this.addLineDeco(height, len);
        }
      } else if (to > from) {
        this.span(from, to);
      }
      if (this.lineEnd > -1 && this.lineEnd < this.pos) this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
    }
    enterLine() {
      if (this.lineStart > -1) return;
      var _this_oracle_doc_lineAt = this.oracle.doc.lineAt(this.pos),
        from = _this_oracle_doc_lineAt.from,
        to = _this_oracle_doc_lineAt.to;
      this.lineStart = from;
      this.lineEnd = to;
      if (this.writtenTo < from) {
        if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null) this.nodes.push(this.blankContent(this.writtenTo, from - 1));
        this.nodes.push(null);
      }
      if (this.pos > from) this.nodes.push(new HeightMapText(this.pos - from, -1));
      this.writtenTo = this.pos;
    }
    blankContent(from, to) {
      var gap = new HeightMapGap(to - from);
      if (this.oracle.doc.lineAt(from).to == to) gap.flags |= 4;
      return gap;
    }
    ensureLine() {
      this.enterLine();
      var last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
      if (last instanceof HeightMapText) return last;
      var line = new HeightMapText(0, -1);
      this.nodes.push(line);
      return line;
    }
    addBlock(block) {
      this.enterLine();
      if (block.type == BlockType.WidgetAfter && !this.isCovered) this.ensureLine();
      this.nodes.push(block);
      this.writtenTo = this.pos = this.pos + block.length;
      if (block.type != BlockType.WidgetBefore) this.covering = block;
    }
    addLineDeco(height, length) {
      var line = this.ensureLine();
      line.length += length;
      line.collapsed += length;
      line.widgetHeight = Math.max(line.widgetHeight, height);
      this.writtenTo = this.pos = this.pos + length;
    }
    finish(from) {
      var last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
      if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered) this.nodes.push(new HeightMapText(0, -1));
      else if (this.writtenTo < this.pos || last == null) this.nodes.push(this.blankContent(this.writtenTo, this.pos));
      var pos = from;
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var node = _step.value;
          if (node instanceof HeightMapText) node.updateHeight(this.oracle, pos);
          pos += node ? node.length : 1;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return this.nodes;
    }
    static build(oracle, decorations2, from, to) {
      var builder = new NodeBuilder(from, oracle);
      RangeSet.spans(decorations2, from, to, builder, 0);
      return builder.finish(from);
    }
    constructor(pos, oracle) {
      this.pos = pos;
      this.oracle = oracle;
      this.nodes = [];
      this.lineStart = -1;
      this.lineEnd = -1;
      this.covering = null;
      this.writtenTo = pos;
    }
  };
  __name(NodeBuilder, "NodeBuilder");
  function heightRelevantDecoChanges(a, b, diff) {
    var comp = new DecorationComparator();
    RangeSet.compare(a, b, diff, comp, 0);
    return comp.changes;
  }
  __name(heightRelevantDecoChanges, "heightRelevantDecoChanges");
  var DecorationComparator = class DecorationComparator {
    compareRange() {}
    comparePoint(from, to, a, b) {
      if (from < to || (a && a.heightRelevant) || (b && b.heightRelevant)) addRange(from, to, this.changes, 5);
    }
    constructor() {
      this.changes = [];
    }
  };
  __name(DecorationComparator, "DecorationComparator");
  function visiblePixelRange(dom, paddingTop) {
    var rect = dom.getBoundingClientRect();
    var doc2 = dom.ownerDocument,
      win = doc2.defaultView || window;
    var left = Math.max(0, rect.left),
      right = Math.min(win.innerWidth, rect.right);
    var top2 = Math.max(0, rect.top),
      bottom = Math.min(win.innerHeight, rect.bottom);
    for (var parent = dom.parentNode; parent && parent != doc2.body; ) {
      if (parent.nodeType == 1) {
        var elt = parent;
        var style = window.getComputedStyle(elt);
        if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style.overflow != "visible") {
          var parentRect = elt.getBoundingClientRect();
          left = Math.max(left, parentRect.left);
          right = Math.min(right, parentRect.right);
          top2 = Math.max(top2, parentRect.top);
          bottom = parent == dom.parentNode ? parentRect.bottom : Math.min(bottom, parentRect.bottom);
        }
        parent = style.position == "absolute" || style.position == "fixed" ? elt.offsetParent : elt.parentNode;
      } else if (parent.nodeType == 11) {
        parent = parent.host;
      } else {
        break;
      }
    }
    return {
      left: left - rect.left,
      right: Math.max(left, right) - rect.left,
      top: top2 - (rect.top + paddingTop),
      bottom: Math.max(top2, bottom) - (rect.top + paddingTop),
    };
  }
  __name(visiblePixelRange, "visiblePixelRange");
  function fullPixelRange(dom, paddingTop) {
    var rect = dom.getBoundingClientRect();
    return {
      left: 0,
      right: rect.right - rect.left,
      top: paddingTop,
      bottom: rect.bottom - (rect.top + paddingTop),
    };
  }
  __name(fullPixelRange, "fullPixelRange");
  var LineGap = class LineGap {
    static same(a, b) {
      if (a.length != b.length) return false;
      for (var i = 0; i < a.length; i++) {
        var gA = a[i],
          gB = b[i];
        if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size) return false;
      }
      return true;
    }
    draw(wrapping) {
      return Decoration.replace({
        widget: new LineGapWidget(this.size, wrapping),
      }).range(this.from, this.to);
    }
    constructor(from, to, size) {
      this.from = from;
      this.to = to;
      this.size = size;
    }
  };
  __name(LineGap, "LineGap");
  var LineGapWidget = class LineGapWidget extends WidgetType {
    eq(other) {
      return other.size == this.size && other.vertical == this.vertical;
    }
    toDOM() {
      var elt = document.createElement("div");
      if (this.vertical) {
        elt.style.height = this.size + "px";
      } else {
        elt.style.width = this.size + "px";
        elt.style.height = "2px";
        elt.style.display = "inline-block";
      }
      return elt;
    }
    get estimatedHeight() {
      return this.vertical ? this.size : -1;
    }
    constructor(size, vertical) {
      super();
      this.size = size;
      this.vertical = vertical;
    }
  };
  __name(LineGapWidget, "LineGapWidget");
  var ViewState = class ViewState {
    updateForViewport() {
      var _this = this,
        _loop = function (i) {
          var pos = i ? main.head : main.anchor;
          if (
            !viewports.some((param) => {
              var from = param.from,
                to = param.to;
              return pos >= from && pos <= to;
            })
          ) {
            var _this_lineBlockAt = _this.lineBlockAt(pos),
              from = _this_lineBlockAt.from,
              to = _this_lineBlockAt.to;
            viewports.push(new Viewport(from, to));
          }
        };
      var viewports = [this.viewport],
        main = this.state.selection.main;
      for (var i = 0; i <= 1; i++) _loop(i);
      this.viewports = viewports.sort((a, b) => a.from - b.from);
      this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle.doc, this.heightMap, this.viewports);
    }
    updateViewportLines() {
      this.viewportLines = [];
      this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.state.doc, 0, 0, (block) => {
        this.viewportLines.push(this.scaler.scale == 1 ? block : scaleBlock(block, this.scaler));
      });
    }
    update(update2) {
      var scrollTarget = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      this.state = update2.state;
      var prevDeco = this.stateDeco;
      this.stateDeco = this.state.facet(decorations).filter((d) => typeof d != "function");
      var contentChanges = update2.changedRanges;
      var heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update2 ? update2.changes : ChangeSet.empty(this.state.doc.length)));
      var prevHeight = this.heightMap.height;
      this.heightMap = this.heightMap.applyChanges(this.stateDeco, update2.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
      if (this.heightMap.height != prevHeight) update2.flags |= 2;
      var viewport = heightChanges.length ? this.mapViewport(this.viewport, update2.changes) : this.viewport;
      if ((scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to)) || !this.viewportIsAppropriate(viewport)) viewport = this.getViewport(0, scrollTarget);
      var updateLines = !update2.changes.empty || update2.flags & 2 || viewport.from != this.viewport.from || viewport.to != this.viewport.to;
      this.viewport = viewport;
      this.updateForViewport();
      if (updateLines) this.updateViewportLines();
      if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1) this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update2.changes)));
      update2.flags |= this.computeVisibleRanges();
      if (scrollTarget) this.scrollTarget = scrollTarget;
      if (!this.mustEnforceCursorAssoc && update2.selectionSet && update2.view.lineWrapping && update2.state.selection.main.empty && update2.state.selection.main.assoc && !update2.state.facet(nativeSelectionHidden)) this.mustEnforceCursorAssoc = true;
    }
    measure(view) {
      var dom = view.contentDOM,
        style = window.getComputedStyle(dom);
      var oracle = this.heightOracle;
      var whiteSpace = style.whiteSpace;
      this.defaultTextDirection = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
      var refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
      var measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != dom.clientHeight;
      this.contentDOMHeight = dom.clientHeight;
      this.mustMeasureContent = false;
      var result = 0,
        bias = 0;
      var paddingTop = parseInt(style.paddingTop) || 0,
        paddingBottom = parseInt(style.paddingBottom) || 0;
      if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
        this.paddingTop = paddingTop;
        this.paddingBottom = paddingBottom;
        result |= 8 | 2;
      }
      if (this.editorWidth != view.scrollDOM.clientWidth) {
        if (oracle.lineWrapping) measureContent = true;
        this.editorWidth = view.scrollDOM.clientWidth;
        result |= 8;
      }
      var pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
      var dTop = pixelViewport.top - this.pixelViewport.top,
        dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
      this.pixelViewport = pixelViewport;
      var inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
      if (inView != this.inView) {
        this.inView = inView;
        if (inView) measureContent = true;
      }
      if (!this.inView && !this.scrollTarget) return 0;
      var contentWidth = dom.clientWidth;
      if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
        this.contentDOMWidth = contentWidth;
        this.editorHeight = view.scrollDOM.clientHeight;
        result |= 8;
      }
      if (measureContent) {
        var lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
        if (oracle.mustRefreshForHeights(lineHeights)) refresh = true;
        if (refresh || (oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth)) {
          var _view_docView_measureTextSize = view.docView.measureTextSize(),
            lineHeight = _view_docView_measureTextSize.lineHeight,
            charWidth = _view_docView_measureTextSize.charWidth;
          refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, contentWidth / charWidth, lineHeights);
          if (refresh) {
            view.docView.minWidth = 0;
            result |= 8;
          }
        }
        if (dTop > 0 && dBottom > 0) bias = Math.max(dTop, dBottom);
        else if (dTop < 0 && dBottom < 0) bias = Math.min(dTop, dBottom);
        oracle.heightChanged = false;
        var _iteratorNormalCompletion = true,
          _didIteratorError = false,
          _iteratorError = undefined;
        try {
          for (var _iterator = this.viewports[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var vp = _step.value;
            var heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);
            this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        if (oracle.heightChanged) result |= 2;
      }
      var viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || (this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to));
      if (viewportChange) this.viewport = this.getViewport(bias, this.scrollTarget);
      this.updateForViewport();
      if (result & 2 || viewportChange) this.updateViewportLines();
      if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1) this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));
      result |= this.computeVisibleRanges();
      if (this.mustEnforceCursorAssoc) {
        this.mustEnforceCursorAssoc = false;
        view.docView.enforceCursorAssoc();
      }
      return result;
    }
    get visibleTop() {
      return this.scaler.fromDOM(this.pixelViewport.top);
    }
    get visibleBottom() {
      return this.scaler.fromDOM(this.pixelViewport.bottom);
    }
    getViewport(bias, scrollTarget) {
      var marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
      var map = this.heightMap,
        doc2 = this.state.doc,
        _this = this,
        visibleTop = _this.visibleTop,
        visibleBottom = _this.visibleBottom;
      var viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1e3, QueryType.ByHeight, doc2, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType.ByHeight, doc2, 0, 0).to);
      if (scrollTarget) {
        var head = scrollTarget.range.head;
        if (head < viewport.from || head > viewport.to) {
          var viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
          var block = map.lineAt(head, QueryType.ByPos, doc2, 0, 0),
            topPos;
          if (scrollTarget.y == "center") topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
          else if (scrollTarget.y == "start" || (scrollTarget.y == "nearest" && head < viewport.from)) topPos = block.top;
          else topPos = block.bottom - viewHeight;
          viewport = new Viewport(map.lineAt(topPos - 1e3 / 2, QueryType.ByHeight, doc2, 0, 0).from, map.lineAt(topPos + viewHeight + 1e3 / 2, QueryType.ByHeight, doc2, 0, 0).to);
        }
      }
      return viewport;
    }
    mapViewport(viewport, changes) {
      var from = changes.mapPos(viewport.from, -1),
        to = changes.mapPos(viewport.to, 1);
      return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0).to);
    }
    viewportIsAppropriate(param) {
      var from = param.from,
        to = param.to,
        bias = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      if (!this.inView) return true;
      var _this_heightMap_lineAt = this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0),
        top2 = _this_heightMap_lineAt.top;
      var bottom = this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0).bottom;
      var _this = this,
        visibleTop = _this.visibleTop,
        visibleBottom = _this.visibleBottom;
      return (from == 0 || top2 <= visibleTop - Math.max(10, Math.min(-bias, 250))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10, Math.min(bias, 250))) && top2 > visibleTop - 2 * 1e3 && bottom < visibleBottom + 2 * 1e3;
    }
    mapLineGaps(gaps, changes) {
      if (!gaps.length || changes.empty) return gaps;
      var mapped = [];
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = gaps[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var gap = _step.value;
          if (!changes.touchesRange(gap.from, gap.to)) mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return mapped;
    }
    ensureLineGaps(current, mayMeasure) {
      var wrapping = this.heightOracle.lineWrapping;
      var margin = wrapping ? 1e4 : 2e3,
        halfMargin = margin >> 1,
        doubleMargin = margin << 1;
      if (this.defaultTextDirection != Direction.LTR && !wrapping) return [];
      var gaps = [];
      var addGap = /* @__PURE__ */ __name((from, to, line, structure) => {
        if (to - from < halfMargin) return;
        var sel = this.state.selection.main,
          avoid = [sel.from];
        if (!sel.empty) avoid.push(sel.to);
        var _iteratorNormalCompletion = true,
          _didIteratorError = false,
          _iteratorError = undefined;
        try {
          for (var _iterator = avoid[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var pos = _step.value;
            if (pos > from && pos < to) {
              addGap(from, pos - 10, line, structure);
              addGap(pos + 10, to, line, structure);
              return;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        var gap = find(current, (gap2) => gap2.from >= line.from && gap2.to <= line.to && Math.abs(gap2.from - from) < halfMargin && Math.abs(gap2.to - to) < halfMargin && !avoid.some((pos) => gap2.from < pos && gap2.to > pos));
        if (!gap) {
          if (to < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some((r) => r.from <= to && r.to >= to)) {
            var lineStart = mayMeasure.moveToLineBoundary(EditorSelection.cursor(to), false, true).head;
            if (lineStart > from) to = lineStart;
          }
          gap = new LineGap(from, to, this.gapSize(line, from, to, structure));
        }
        gaps.push(gap);
      }, "addGap");
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.viewportLines[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var line = _step.value;
          if (line.length < doubleMargin) continue;
          var structure = lineStructure(line.from, line.to, this.stateDeco);
          if (structure.total < doubleMargin) continue;
          var target = this.scrollTarget ? this.scrollTarget.range.head : null;
          var viewFrom = void 0,
            viewTo = void 0;
          if (wrapping) {
            var marginHeight = (margin / this.heightOracle.lineLength) * this.heightOracle.lineHeight;
            var top2 = void 0,
              bot = void 0;
            if (target != null) {
              var targetFrac = findFraction(structure, target);
              var spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;
              top2 = targetFrac - spaceFrac;
              bot = targetFrac + spaceFrac;
            } else {
              top2 = (this.visibleTop - line.top - marginHeight) / line.height;
              bot = (this.visibleBottom - line.top + marginHeight) / line.height;
            }
            viewFrom = findPosition(structure, top2);
            viewTo = findPosition(structure, bot);
          } else {
            var totalWidth = structure.total * this.heightOracle.charWidth;
            var marginWidth = margin * this.heightOracle.charWidth;
            var left = void 0,
              right = void 0;
            if (target != null) {
              var targetFrac1 = findFraction(structure, target);
              var spaceFrac1 = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + marginWidth) / totalWidth;
              left = targetFrac1 - spaceFrac1;
              right = targetFrac1 + spaceFrac1;
            } else {
              left = (this.pixelViewport.left - marginWidth) / totalWidth;
              right = (this.pixelViewport.right + marginWidth) / totalWidth;
            }
            viewFrom = findPosition(structure, left);
            viewTo = findPosition(structure, right);
          }
          if (viewFrom > line.from) addGap(line.from, viewFrom, line, structure);
          if (viewTo < line.to) addGap(viewTo, line.to, line, structure);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return gaps;
    }
    gapSize(line, from, to, structure) {
      var fraction = findFraction(structure, to) - findFraction(structure, from);
      if (this.heightOracle.lineWrapping) {
        return line.height * fraction;
      } else {
        return structure.total * this.heightOracle.charWidth * fraction;
      }
    }
    updateLineGaps(gaps) {
      if (!LineGap.same(gaps, this.lineGaps)) {
        this.lineGaps = gaps;
        this.lineGapDeco = Decoration.set(gaps.map((gap) => gap.draw(this.heightOracle.lineWrapping)));
      }
    }
    computeVisibleRanges() {
      var deco = this.stateDeco;
      if (this.lineGaps.length) deco = deco.concat(this.lineGapDeco);
      var ranges = [];
      RangeSet.spans(
        deco,
        this.viewport.from,
        this.viewport.to,
        {
          span(from, to) {
            ranges.push({
              from,
              to,
            });
          },
          point() {},
        },
        20
      );
      var changed = ranges.length != this.visibleRanges.length || this.visibleRanges.some((r, i) => r.from != ranges[i].from || r.to != ranges[i].to);
      this.visibleRanges = ranges;
      return changed ? 4 : 0;
    }
    lineBlockAt(pos) {
      return (pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b) => b.from <= pos && b.to >= pos)) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.state.doc, 0, 0), this.scaler);
    }
    lineBlockAtHeight(height) {
      return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.state.doc, 0, 0), this.scaler);
    }
    elementAtHeight(height) {
      return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.state.doc, 0, 0), this.scaler);
    }
    get docHeight() {
      return this.scaler.toDOM(this.heightMap.height);
    }
    get contentHeight() {
      return this.docHeight + this.paddingTop + this.paddingBottom;
    }
    constructor(state) {
      this.state = state;
      this.pixelViewport = {
        left: 0,
        right: window.innerWidth,
        top: 0,
        bottom: 0,
      };
      this.inView = true;
      this.paddingTop = 0;
      this.paddingBottom = 0;
      this.contentDOMWidth = 0;
      this.contentDOMHeight = 0;
      this.editorHeight = 0;
      this.editorWidth = 0;
      this.scaler = IdScaler;
      this.scrollTarget = null;
      this.printing = false;
      this.mustMeasureContent = true;
      this.defaultTextDirection = Direction.LTR;
      this.visibleRanges = [];
      this.mustEnforceCursorAssoc = false;
      var guessWrapping = state.facet(contentAttributes).some((v) => typeof v != "function" && v.class == "cm-lineWrapping");
      this.heightOracle = new HeightOracle(guessWrapping);
      this.stateDeco = state.facet(decorations).filter((d) => typeof d != "function");
      this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
      this.viewport = this.getViewport(0, null);
      this.updateViewportLines();
      this.updateForViewport();
      this.lineGaps = this.ensureLineGaps([]);
      this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(false)));
      this.computeVisibleRanges();
    }
  };
  __name(ViewState, "ViewState");
  var Viewport = class Viewport {
    constructor(from, to) {
      this.from = from;
      this.to = to;
    }
  };
  __name(Viewport, "Viewport");
  function lineStructure(from, to, stateDeco) {
    var ranges = [],
      pos = from,
      total = 0;
    RangeSet.spans(
      stateDeco,
      from,
      to,
      {
        span() {},
        point(from2, to2) {
          if (from2 > pos) {
            ranges.push({
              from: pos,
              to: from2,
            });
            total += from2 - pos;
          }
          pos = to2;
        },
      },
      20
    );
    if (pos < to) {
      ranges.push({
        from: pos,
        to,
      });
      total += to - pos;
    }
    return {
      total,
      ranges,
    };
  }
  __name(lineStructure, "lineStructure");
  function findPosition(param, ratio) {
    var total = param.total,
      ranges = param.ranges;
    if (ratio <= 0) return ranges[0].from;
    if (ratio >= 1) return ranges[ranges.length - 1].to;
    var dist = Math.floor(total * ratio);
    for (var i = 0; ; i++) {
      var _ranges_i = ranges[i],
        from = _ranges_i.from,
        to = _ranges_i.to,
        size = to - from;
      if (dist <= size) return from + dist;
      dist -= size;
    }
  }
  __name(findPosition, "findPosition");
  function findFraction(structure, pos) {
    var counted = 0;
    var _iteratorNormalCompletion = true,
      _didIteratorError = false,
      _iteratorError = undefined;
    try {
      for (var _iterator = structure.ranges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _step_value = _step.value,
          from = _step_value.from,
          to = _step_value.to;
        if (pos <= to) {
          counted += pos - from;
          break;
        }
        counted += to - from;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    return counted / structure.total;
  }
  __name(findFraction, "findFraction");
  function find(array, f) {
    var _iteratorNormalCompletion = true,
      _didIteratorError = false,
      _iteratorError = undefined;
    try {
      for (var _iterator = array[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var val = _step.value;
        if (f(val)) return val;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    return void 0;
  }
  __name(find, "find");
  var IdScaler = {
    toDOM(n) {
      return n;
    },
    fromDOM(n) {
      return n;
    },
    scale: 1,
  };
  var BigScaler = class BigScaler {
    toDOM(n) {
      for (var i = 0, base2 = 0, domBase = 0; ; i++) {
        var vp = i < this.viewports.length ? this.viewports[i] : null;
        if (!vp || n < vp.top) return domBase + (n - base2) * this.scale;
        if (n <= vp.bottom) return vp.domTop + (n - vp.top);
        base2 = vp.bottom;
        domBase = vp.domBottom;
      }
    }
    fromDOM(n) {
      for (var i = 0, base2 = 0, domBase = 0; ; i++) {
        var vp = i < this.viewports.length ? this.viewports[i] : null;
        if (!vp || n < vp.domTop) return base2 + (n - domBase) / this.scale;
        if (n <= vp.domBottom) return vp.top + (n - vp.domTop);
        base2 = vp.bottom;
        domBase = vp.domBottom;
      }
    }
    constructor(doc2, heightMap, viewports) {
      var vpHeight = 0,
        base2 = 0,
        domBase = 0;
      this.viewports = viewports.map((param) => {
        var from = param.from,
          to = param.to;
        var top2 = heightMap.lineAt(from, QueryType.ByPos, doc2, 0, 0).top;
        var bottom = heightMap.lineAt(to, QueryType.ByPos, doc2, 0, 0).bottom;
        vpHeight += bottom - top2;
        return {
          from,
          to,
          top: top2,
          bottom,
          domTop: 0,
          domBottom: 0,
        };
      });
      this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.viewports[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var obj = _step.value;
          obj.domTop = domBase + (obj.top - base2) * this.scale;
          domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
          base2 = obj.bottom;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  };
  __name(BigScaler, "BigScaler");
  function scaleBlock(block, scaler) {
    if (scaler.scale == 1) return block;
    var bTop = scaler.toDOM(block.top),
      bBottom = scaler.toDOM(block.bottom);
    return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block.type) ? block.type.map((b) => scaleBlock(b, scaler)) : block.type);
  }
  __name(scaleBlock, "scaleBlock");
  var theme = /* @__PURE__ */ Facet.define({
    combine: (strs) => strs.join(" "),
  });
  var darkTheme = /* @__PURE__ */ Facet.define({
    combine: (values) => values.indexOf(true) > -1,
  });
  var baseThemeID = /* @__PURE__ */ StyleModule.newName();
  var baseLightID = /* @__PURE__ */ StyleModule.newName();
  var baseDarkID = /* @__PURE__ */ StyleModule.newName();
  var lightDarkIDs = {
    "&light": "." + baseLightID,
    "&dark": "." + baseDarkID,
  };
  function buildTheme(main, spec, scopes) {
    return new StyleModule(spec, {
      finish(sel) {
        return /&/.test(sel)
          ? sel.replace(/&\w*/, (m) => {
              if (m == "&") return main;
              if (!scopes || !scopes[m]) throw new RangeError("Unsupported selector: ".concat(m));
              return scopes[m];
            })
          : main + " " + sel;
      },
    });
  }
  __name(buildTheme, "buildTheme");
  var baseTheme$1 = /* @__PURE__ */ buildTheme(
    "." + baseThemeID,
    {
      "&.cm-editor": {
        position: "relative !important",
        boxSizing: "border-box",
        "&.cm-focused": {
          outline: "1px dotted #212121",
        },
        display: "flex !important",
        flexDirection: "column",
      },
      ".cm-scroller": {
        display: "flex !important",
        alignItems: "flex-start !important",
        fontFamily: "monospace",
        lineHeight: 1.4,
        height: "100%",
        overflowX: "auto",
        position: "relative",
        zIndex: 0,
      },
      ".cm-content": {
        margin: 0,
        flexGrow: 2,
        flexShrink: 0,
        display: "block",
        whiteSpace: "pre",
        wordWrap: "normal",
        boxSizing: "border-box",
        padding: "4px 0",
        outline: "none",
        "&[contenteditable=true]": {
          WebkitUserModify: "read-write-plaintext-only",
        },
      },
      ".cm-lineWrapping": {
        whiteSpace_fallback: "pre-wrap",
        whiteSpace: "break-spaces",
        wordBreak: "break-word",
        overflowWrap: "anywhere",
        flexShrink: 1,
      },
      "&light .cm-content": {
        caretColor: "black",
      },
      "&dark .cm-content": {
        caretColor: "white",
      },
      ".cm-line": {
        display: "block",
        padding: "0 2px 0 6px",
      },
      ".cm-layer": {
        contain: "size style",
        "& > *": {
          position: "absolute",
        },
      },
      "&light .cm-selectionBackground": {
        background: "#d9d9d9",
      },
      "&dark .cm-selectionBackground": {
        background: "#222",
      },
      "&light.cm-focused .cm-selectionBackground": {
        background: "#d7d4f0",
      },
      "&dark.cm-focused .cm-selectionBackground": {
        background: "#233",
      },
      ".cm-cursorLayer": {
        pointerEvents: "none",
      },
      "&.cm-focused .cm-cursorLayer": {
        animation: "steps(1) cm-blink 1.2s infinite",
      },
      "@keyframes cm-blink": {
        "0%": {},
        "50%": {
          opacity: 0,
        },
        "100%": {},
      },
      "@keyframes cm-blink2": {
        "0%": {},
        "50%": {
          opacity: 0,
        },
        "100%": {},
      },
      ".cm-cursor, .cm-dropCursor": {
        borderLeft: "1.2px solid black",
        marginLeft: "-0.6px",
        pointerEvents: "none",
      },
      ".cm-cursor": {
        display: "none",
      },
      "&dark .cm-cursor": {
        borderLeftColor: "#444",
      },
      "&.cm-focused .cm-cursor": {
        display: "block",
      },
      "&light .cm-activeLine": {
        backgroundColor: "#cceeff44",
      },
      "&dark .cm-activeLine": {
        backgroundColor: "#99eeff33",
      },
      "&light .cm-specialChar": {
        color: "red",
      },
      "&dark .cm-specialChar": {
        color: "#f78",
      },
      ".cm-gutters": {
        flexShrink: 0,
        display: "flex",
        height: "100%",
        boxSizing: "border-box",
        left: 0,
        zIndex: 200,
      },
      "&light .cm-gutters": {
        backgroundColor: "#f5f5f5",
        color: "#6c6c6c",
        borderRight: "1px solid #ddd",
      },
      "&dark .cm-gutters": {
        backgroundColor: "#333338",
        color: "#ccc",
      },
      ".cm-gutter": {
        display: "flex !important",
        flexDirection: "column",
        flexShrink: 0,
        boxSizing: "border-box",
        minHeight: "100%",
        overflow: "hidden",
      },
      ".cm-gutterElement": {
        boxSizing: "border-box",
      },
      ".cm-lineNumbers .cm-gutterElement": {
        padding: "0 3px 0 5px",
        minWidth: "20px",
        textAlign: "right",
        whiteSpace: "nowrap",
      },
      "&light .cm-activeLineGutter": {
        backgroundColor: "#e2f2ff",
      },
      "&dark .cm-activeLineGutter": {
        backgroundColor: "#222227",
      },
      ".cm-panels": {
        boxSizing: "border-box",
        position: "sticky",
        left: 0,
        right: 0,
      },
      "&light .cm-panels": {
        backgroundColor: "#f5f5f5",
        color: "black",
      },
      "&light .cm-panels-top": {
        borderBottom: "1px solid #ddd",
      },
      "&light .cm-panels-bottom": {
        borderTop: "1px solid #ddd",
      },
      "&dark .cm-panels": {
        backgroundColor: "#333338",
        color: "white",
      },
      ".cm-tab": {
        display: "inline-block",
        overflow: "hidden",
        verticalAlign: "bottom",
      },
      ".cm-widgetBuffer": {
        verticalAlign: "text-top",
        height: "1em",
        width: 0,
        display: "inline",
      },
      ".cm-placeholder": {
        color: "#888",
        display: "inline-block",
        verticalAlign: "top",
      },
      ".cm-highlightSpace:before": {
        content: "attr(data-display)",
        position: "absolute",
        pointerEvents: "none",
        color: "#888",
      },
      ".cm-highlightTab": {
        backgroundImage: 'url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>\')',
        backgroundSize: "auto 100%",
        backgroundPosition: "right 90%",
        backgroundRepeat: "no-repeat",
      },
      ".cm-trailingSpace": {
        backgroundColor: "#ff332255",
      },
      ".cm-button": {
        verticalAlign: "middle",
        color: "inherit",
        fontSize: "70%",
        padding: ".2em 1em",
        borderRadius: "1px",
      },
      "&light .cm-button": {
        backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
        border: "1px solid #888",
        "&:active": {
          backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)",
        },
      },
      "&dark .cm-button": {
        backgroundImage: "linear-gradient(#393939, #111)",
        border: "1px solid #888",
        "&:active": {
          backgroundImage: "linear-gradient(#111, #333)",
        },
      },
      ".cm-textfield": {
        verticalAlign: "middle",
        color: "inherit",
        fontSize: "70%",
        border: "1px solid silver",
        padding: ".2em .5em",
      },
      "&light .cm-textfield": {
        backgroundColor: "white",
      },
      "&dark .cm-textfield": {
        border: "1px solid #555",
        backgroundColor: "inherit",
      },
    },
    lightDarkIDs
  );
  var DOMChange = class DOMChange {
    constructor(view, start, end, typeOver) {
      this.typeOver = typeOver;
      this.bounds = null;
      this.text = "";
      var _view_docView = view.docView,
        iHead = _view_docView.impreciseHead,
        iAnchor = _view_docView.impreciseAnchor;
      if (view.state.readOnly && start > -1) {
        this.newSel = null;
      } else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {
        var selPoints = iHead || iAnchor ? [] : selectionPoints(view);
        var reader = new DOMReader(selPoints, view.state);
        reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
        this.text = reader.text;
        this.newSel = selectionFromPoints(selPoints, this.bounds.from);
      } else {
        var domSel = view.observer.selectionRange;
        var head = (iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset) || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
        var anchor = (iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset) || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
        this.newSel = EditorSelection.single(anchor, head);
      }
    }
  };
  __name(DOMChange, "DOMChange");
  function applyDOMChange(view, domChange) {
    var change;
    var newSel = domChange.newSel,
      sel = view.state.selection.main;
    if (domChange.bounds) {
      var _domChange_bounds = domChange.bounds,
        from = _domChange_bounds.from,
        to = _domChange_bounds.to;
      var preferredPos = sel.from,
        preferredSide = null;
      if ((view.inputState.lastKeyCode === 8 && view.inputState.lastKeyTime > Date.now() - 100) || (browser.android && domChange.text.length < to - from)) {
        preferredPos = sel.to;
        preferredSide = "end";
      }
      var diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);
      if (diff) {
        if (browser.chrome && view.inputState.lastKeyCode == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder) diff.toB--;
        change = {
          from: from + diff.from,
          to: from + diff.toA,
          insert: Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder)),
        };
      }
    } else if (newSel && (!view.hasFocus || !view.state.facet(editable) || newSel.main.eq(sel))) {
      newSel = null;
    }
    if (!change && !newSel) return false;
    if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
      change = {
        from: sel.from,
        to: sel.to,
        insert: view.state.doc.slice(sel.from, sel.to),
      };
    } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {
      change = {
        from: sel.from,
        to: sel.to,
        insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to)),
      };
    } else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\. ?$/.test(change.insert.toString())) {
      if (newSel && change.insert.length == 2) newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
      change = {
        from: sel.from,
        to: sel.to,
        insert: Text.of([" "]),
      };
    } else if (browser.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == "\n " && view.lineWrapping) {
      if (newSel) newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
      change = {
        from: sel.from,
        to: sel.to,
        insert: Text.of([" "]),
      };
    }
    if (change) {
      var startState = view.state;
      if (browser.ios && view.inputState.flushIOSKey(view)) return true;
      if (
        browser.android &&
        ((change.from == sel.from && change.to == sel.to && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13)) ||
          (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 && dispatchKey(view.contentDOM, "Backspace", 8)) ||
          (change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46)))
      )
        return true;
      var text2 = change.insert.toString();
      if (view.state.facet(inputHandler).some((h) => h(view, change.from, change.to, text2))) return true;
      if (view.inputState.composing >= 0) view.inputState.composing++;
      var tr;
      if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || (newSel.main.empty && newSel.main.from == change.from + change.insert.length)) && view.inputState.composing < 0) {
        var before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
        var after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
        tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, void 0, view.state.lineBreak) + after));
      } else {
        var changes = startState.changes(change);
        var mainSel = newSel && !startState.selection.main.eq(newSel.main) && newSel.main.to <= changes.newLength ? newSel.main : void 0;
        if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {
          var replaced = view.state.sliceDoc(change.from, change.to);
          var compositionRange = compositionSurroundingNode(view) || view.state.doc.lineAt(sel.head);
          var offset = sel.to - change.to,
            size = sel.to - sel.from;
          tr = startState.changeByRange((range) => {
            if (range.from == sel.from && range.to == sel.to)
              return {
                changes,
                range: mainSel || range.map(changes),
              };
            var to = range.to - offset,
              from = to - replaced.length;
            if (range.to - range.from != size || view.state.sliceDoc(from, to) != replaced || (compositionRange && range.to >= compositionRange.from && range.from <= compositionRange.to))
              return {
                range,
              };
            var rangeChanges = startState.changes({
                from,
                to,
                insert: change.insert,
              }),
              selOff = range.to - sel.to;
            return {
              changes: rangeChanges,
              range: !mainSel ? range.map(rangeChanges) : EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff)),
            };
          });
        } else {
          tr = {
            changes,
            selection: mainSel && startState.selection.replaceRange(mainSel),
          };
        }
      }
      var userEvent = "input.type";
      if (view.composing) {
        userEvent += ".compose";
        if (view.inputState.compositionFirstChange) {
          userEvent += ".start";
          view.inputState.compositionFirstChange = false;
        }
      }
      view.dispatch(tr, {
        scrollIntoView: true,
        userEvent,
      });
      return true;
    } else if (newSel && !newSel.main.eq(sel)) {
      var scrollIntoView2 = false,
        userEvent1 = "select";
      if (view.inputState.lastSelectionTime > Date.now() - 50) {
        if (view.inputState.lastSelectionOrigin == "select") scrollIntoView2 = true;
        userEvent1 = view.inputState.lastSelectionOrigin;
      }
      view.dispatch({
        selection: newSel,
        scrollIntoView: scrollIntoView2,
        userEvent: userEvent1,
      });
      return true;
    } else {
      return false;
    }
  }
  __name(applyDOMChange, "applyDOMChange");
  function findDiff(a, b, preferredPos, preferredSide) {
    var minLen = Math.min(a.length, b.length);
    var from = 0;
    while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from)) from++;
    if (from == minLen && a.length == b.length) return null;
    var toA = a.length,
      toB = b.length;
    while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
      toA--;
      toB--;
    }
    if (preferredSide == "end") {
      var adjust = Math.max(0, from - Math.min(toA, toB));
      preferredPos -= toA + adjust - from;
    }
    if (toA < from && a.length < b.length) {
      var move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
      from -= move;
      toB = from + (toB - toA);
      toA = from;
    } else if (toB < from) {
      var move1 = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
      from -= move1;
      toA = from + (toA - toB);
      toB = from;
    }
    return {
      from,
      toA,
      toB,
    };
  }
  __name(findDiff, "findDiff");
  function selectionPoints(view) {
    var result = [];
    if (view.root.activeElement != view.contentDOM) return result;
    var _view_observer_selectionRange = view.observer.selectionRange,
      anchorNode = _view_observer_selectionRange.anchorNode,
      anchorOffset = _view_observer_selectionRange.anchorOffset,
      focusNode = _view_observer_selectionRange.focusNode,
      focusOffset = _view_observer_selectionRange.focusOffset;
    if (anchorNode) {
      result.push(new DOMPoint(anchorNode, anchorOffset));
      if (focusNode != anchorNode || focusOffset != anchorOffset) result.push(new DOMPoint(focusNode, focusOffset));
    }
    return result;
  }
  __name(selectionPoints, "selectionPoints");
  function selectionFromPoints(points, base2) {
    if (points.length == 0) return null;
    var anchor = points[0].pos,
      head = points.length == 2 ? points[1].pos : anchor;
    return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base2, head + base2) : null;
  }
  __name(selectionFromPoints, "selectionFromPoints");
  var observeOptions = {
    childList: true,
    characterData: true,
    subtree: true,
    attributes: true,
    characterDataOldValue: true,
  };
  var useCharData = browser.ie && browser.ie_version <= 11;
  var DOMObserver = class DOMObserver {
    onScrollChanged(e) {
      this.view.inputState.runScrollHandlers(this.view, e);
      if (this.intersecting) this.view.measure();
    }
    onScroll(e) {
      if (this.intersecting) this.flush(false);
      this.onScrollChanged(e);
    }
    onResize() {
      if (this.resizeTimeout < 0)
        this.resizeTimeout = setTimeout(() => {
          this.resizeTimeout = -1;
          this.view.requestMeasure();
        }, 50);
    }
    onPrint() {
      this.view.viewState.printing = true;
      this.view.measure();
      setTimeout(() => {
        this.view.viewState.printing = false;
        this.view.requestMeasure();
      }, 500);
    }
    updateGaps(gaps) {
      if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i) => g != gaps[i]))) {
        this.gapIntersection.disconnect();
        var _iteratorNormalCompletion = true,
          _didIteratorError = false,
          _iteratorError = undefined;
        try {
          for (var _iterator = gaps[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var gap = _step.value;
            this.gapIntersection.observe(gap);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        this.gaps = gaps;
      }
    }
    onSelectionChange(event) {
      var wasChanged = this.selectionChanged;
      if (!this.readSelectionRange() || this.delayedAndroidKey) return;
      var view = this.view,
        sel = this.selectionRange;
      if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel)) return;
      var context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
      if (context && context.ignoreEvent(event)) {
        if (!wasChanged) this.selectionChanged = false;
        return;
      }
      if (((browser.ie && browser.ie_version <= 11) || (browser.android && browser.chrome)) && !view.state.selection.main.empty && sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) this.flushSoon();
      else this.flush(false);
    }
    readSelectionRange() {
      var view = this.view;
      var range = (browser.safari && view.root.nodeType == 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariSelectionRangeHack(this.view)) || getSelection(view.root);
      if (!range || this.selectionRange.eq(range)) return false;
      var local = hasSelection(this.dom, range);
      if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range)) {
        this.view.inputState.lastFocusTime = 0;
        view.docView.updateSelection();
        return false;
      }
      this.selectionRange.setRange(range);
      if (local) this.selectionChanged = true;
      return true;
    }
    setSelectionRange(anchor, head) {
      this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
      this.selectionChanged = false;
    }
    clearSelectionRange() {
      this.selectionRange.set(null, 0, null, 0);
    }
    listenForScroll() {
      this.parentCheck = -1;
      var i = 0,
        changed = null;
      for (var dom = this.dom; dom; ) {
        if (dom.nodeType == 1) {
          if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom) i++;
          else if (!changed) changed = this.scrollTargets.slice(0, i);
          if (changed) changed.push(dom);
          dom = dom.assignedSlot || dom.parentNode;
        } else if (dom.nodeType == 11) {
          dom = dom.host;
        } else {
          break;
        }
      }
      if (i < this.scrollTargets.length && !changed) changed = this.scrollTargets.slice(0, i);
      if (changed) {
        var _iteratorNormalCompletion = true,
          _didIteratorError = false,
          _iteratorError = undefined;
        try {
          for (var _iterator = this.scrollTargets[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var dom1 = _step.value;
            dom1.removeEventListener("scroll", this.onScroll);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        var _iteratorNormalCompletion1 = true,
          _didIteratorError1 = false,
          _iteratorError1 = undefined;
        try {
          for (var _iterator1 = (this.scrollTargets = changed)[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
            var dom2 = _step1.value;
            dom2.addEventListener("scroll", this.onScroll);
          }
        } catch (err) {
          _didIteratorError1 = true;
          _iteratorError1 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
              _iterator1.return();
            }
          } finally {
            if (_didIteratorError1) {
              throw _iteratorError1;
            }
          }
        }
      }
    }
    ignore(f) {
      if (!this.active) return f();
      try {
        this.stop();
        return f();
      } finally {
        this.start();
        this.clear();
      }
    }
    start() {
      if (this.active) return;
      this.observer.observe(this.dom, observeOptions);
      if (useCharData) this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
      this.active = true;
    }
    stop() {
      if (!this.active) return;
      this.active = false;
      this.observer.disconnect();
      if (useCharData) this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    }
    clear() {
      this.processRecords();
      this.queue.length = 0;
      this.selectionChanged = false;
    }
    delayAndroidKey(key, keyCode) {
      var _a2;
      if (!this.delayedAndroidKey) {
        var flush2 = /* @__PURE__ */ __name(() => {
          var key2 = this.delayedAndroidKey;
          if (key2) {
            this.clearDelayedAndroidKey();
            if (!this.flush() && key2.force) dispatchKey(this.dom, key2.key, key2.keyCode);
          }
        }, "flush");
        this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush2);
      }
      if (!this.delayedAndroidKey || key == "Enter")
        this.delayedAndroidKey = {
          key,
          keyCode,
          force: this.lastChange < Date.now() - 50 || !!((_a2 = this.delayedAndroidKey) === null || _a2 === void 0 ? void 0 : _a2.force),
        };
    }
    clearDelayedAndroidKey() {
      this.win.cancelAnimationFrame(this.flushingAndroidKey);
      this.delayedAndroidKey = null;
      this.flushingAndroidKey = -1;
    }
    flushSoon() {
      if (this.delayedFlush < 0)
        this.delayedFlush = this.view.win.requestAnimationFrame(() => {
          this.delayedFlush = -1;
          this.flush();
        });
    }
    forceFlush() {
      if (this.delayedFlush >= 0) {
        this.view.win.cancelAnimationFrame(this.delayedFlush);
        this.delayedFlush = -1;
      }
      this.flush();
    }
    processRecords() {
      var records = this.queue;
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.observer.takeRecords()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var mut = _step.value;
          records.push(mut);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      if (records.length) this.queue = [];
      var from = -1,
        to = -1,
        typeOver = false;
      var _iteratorNormalCompletion1 = true,
        _didIteratorError1 = false,
        _iteratorError1 = undefined;
      try {
        for (var _iterator1 = records[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
          var record = _step1.value;
          var range = this.readMutation(record);
          if (!range) continue;
          if (range.typeOver) typeOver = true;
          if (from == -1) {
            var ref;
            (ref = range), (from = ref.from), (to = ref.to), ref;
          } else {
            from = Math.min(range.from, from);
            to = Math.max(range.to, to);
          }
        }
      } catch (err) {
        _didIteratorError1 = true;
        _iteratorError1 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
            _iterator1.return();
          }
        } finally {
          if (_didIteratorError1) {
            throw _iteratorError1;
          }
        }
      }
      return {
        from,
        to,
        typeOver,
      };
    }
    readChange() {
      var _this_processRecords = this.processRecords(),
        from = _this_processRecords.from,
        to = _this_processRecords.to,
        typeOver = _this_processRecords.typeOver;
      var newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
      if (from < 0 && !newSel) return null;
      if (from > -1) this.lastChange = Date.now();
      this.view.inputState.lastFocusTime = 0;
      this.selectionChanged = false;
      return new DOMChange(this.view, from, to, typeOver);
    }
    flush() {
      var readSelection = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (this.delayedFlush >= 0 || this.delayedAndroidKey) return false;
      if (readSelection) this.readSelectionRange();
      var domChange = this.readChange();
      if (!domChange) return false;
      var startState = this.view.state;
      var handled = applyDOMChange(this.view, domChange);
      if (this.view.state == startState) this.view.update([]);
      return handled;
    }
    readMutation(rec) {
      var cView = this.view.docView.nearest(rec.target);
      if (!cView || cView.ignoreMutation(rec)) return null;
      cView.markDirty(rec.type == "attributes");
      if (rec.type == "attributes") cView.dirty |= 4;
      if (rec.type == "childList") {
        var childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
        var childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
        return {
          from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
          to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
          typeOver: false,
        };
      } else if (rec.type == "characterData") {
        return {
          from: cView.posAtStart,
          to: cView.posAtEnd,
          typeOver: rec.target.nodeValue == rec.oldValue,
        };
      } else {
        return null;
      }
    }
    setWindow(win) {
      if (win != this.win) {
        this.removeWindowListeners(this.win);
        this.win = win;
        this.addWindowListeners(this.win);
      }
    }
    addWindowListeners(win) {
      win.addEventListener("resize", this.onResize);
      win.addEventListener("beforeprint", this.onPrint);
      win.addEventListener("scroll", this.onScroll);
      win.document.addEventListener("selectionchange", this.onSelectionChange);
    }
    removeWindowListeners(win) {
      win.removeEventListener("scroll", this.onScroll);
      win.removeEventListener("resize", this.onResize);
      win.removeEventListener("beforeprint", this.onPrint);
      win.document.removeEventListener("selectionchange", this.onSelectionChange);
    }
    destroy() {
      var _a2, _b, _c, _d;
      this.stop();
      (_a2 = this.intersection) === null || _a2 === void 0 ? void 0 : _a2.disconnect();
      (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
      (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();
      (_d = this.resizeContent) === null || _d === void 0 ? void 0 : _d.disconnect();
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.scrollTargets[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var dom = _step.value;
          dom.removeEventListener("scroll", this.onScroll);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      this.removeWindowListeners(this.win);
      clearTimeout(this.parentCheck);
      clearTimeout(this.resizeTimeout);
      this.win.cancelAnimationFrame(this.delayedFlush);
      this.win.cancelAnimationFrame(this.flushingAndroidKey);
    }
    constructor(view) {
      this.view = view;
      this.active = false;
      this.selectionRange = new DOMSelectionState();
      this.selectionChanged = false;
      this.delayedFlush = -1;
      this.resizeTimeout = -1;
      this.queue = [];
      this.delayedAndroidKey = null;
      this.flushingAndroidKey = -1;
      this.lastChange = 0;
      this.scrollTargets = [];
      this.intersection = null;
      this.resizeScroll = null;
      this.resizeContent = null;
      this.intersecting = false;
      this.gapIntersection = null;
      this.gaps = [];
      this.parentCheck = -1;
      this.dom = view.contentDOM;
      this.observer = new MutationObserver((mutations) => {
        var _iteratorNormalCompletion = true,
          _didIteratorError = false,
          _iteratorError = undefined;
        try {
          for (var _iterator = mutations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var mut = _step.value;
            this.queue.push(mut);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        if (((browser.ie && browser.ie_version <= 11) || (browser.ios && view.composing)) && mutations.some((m) => (m.type == "childList" && m.removedNodes.length) || (m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))) this.flushSoon();
        else this.flush();
      });
      if (useCharData)
        this.onCharData = (event) => {
          this.queue.push({
            target: event.target,
            type: "characterData",
            oldValue: event.prevValue,
          });
          this.flushSoon();
        };
      this.onSelectionChange = this.onSelectionChange.bind(this);
      this.onResize = this.onResize.bind(this);
      this.onPrint = this.onPrint.bind(this);
      this.onScroll = this.onScroll.bind(this);
      if (typeof ResizeObserver == "function") {
        this.resizeScroll = new ResizeObserver(() => {
          var _a2;
          if (((_a2 = this.view.docView) === null || _a2 === void 0 ? void 0 : _a2.lastUpdate) < Date.now() - 75) this.onResize();
        });
        this.resizeScroll.observe(view.scrollDOM);
        this.resizeContent = new ResizeObserver(() => this.view.requestMeasure());
        this.resizeContent.observe(view.contentDOM);
      }
      this.addWindowListeners((this.win = view.win));
      this.start();
      if (typeof IntersectionObserver == "function") {
        this.intersection = new IntersectionObserver((entries) => {
          if (this.parentCheck < 0) this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
          if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
            this.intersecting = !this.intersecting;
            if (this.intersecting != this.view.inView) this.onScrollChanged(document.createEvent("Event"));
          }
        }, {});
        this.intersection.observe(this.dom);
        this.gapIntersection = new IntersectionObserver((entries) => {
          if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0) this.onScrollChanged(document.createEvent("Event"));
        }, {});
      }
      this.listenForScroll();
      this.readSelectionRange();
    }
  };
  __name(DOMObserver, "DOMObserver");
  function findChild(cView, dom, dir) {
    while (dom) {
      var curView = ContentView.get(dom);
      if (curView && curView.parent == cView) return curView;
      var parent = dom.parentNode;
      dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
    }
    return null;
  }
  __name(findChild, "findChild");
  function safariSelectionRangeHack(view) {
    var found = null;
    function read(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
      found = event.getTargetRanges()[0];
    }
    __name(read, "read");
    view.contentDOM.addEventListener("beforeinput", read, true);
    view.dom.ownerDocument.execCommand("indent");
    view.contentDOM.removeEventListener("beforeinput", read, true);
    if (!found) return null;
    var anchorNode = found.startContainer,
      anchorOffset = found.startOffset;
    var focusNode = found.endContainer,
      focusOffset = found.endOffset;
    var curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
    var ref;
    if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset)) (ref = [focusNode, focusOffset, anchorNode, anchorOffset]), (anchorNode = ref[0]), (anchorOffset = ref[1]), (focusNode = ref[2]), (focusOffset = ref[3]), ref;
    return {
      anchorNode,
      anchorOffset,
      focusNode,
      focusOffset,
    };
  }
  __name(safariSelectionRangeHack, "safariSelectionRangeHack");
  var EditorView = class EditorView1 {
    get state() {
      return this.viewState.state;
    }
    get viewport() {
      return this.viewState.viewport;
    }
    get visibleRanges() {
      return this.viewState.visibleRanges;
    }
    get inView() {
      return this.viewState.inView;
    }
    get composing() {
      return this.inputState.composing > 0;
    }
    get compositionStarted() {
      return this.inputState.composing >= 0;
    }
    get root() {
      return this._root;
    }
    get win() {
      return this.dom.ownerDocument.defaultView || window;
    }
    dispatch() {
      for (var _len = arguments.length, input = new Array(_len), _key = 0; _key < _len; _key++) {
        input[_key] = arguments[_key];
      }
      this._dispatch(input.length == 1 && input[0] instanceof Transaction ? input[0] : this.state.update(...input));
    }
    update(transactions) {
      if (this.updateState != 0) throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
      var redrawn = false,
        attrsChanged = false,
        update2;
      var state = this.state;
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = transactions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var tr = _step.value;
          if (tr.startState != state) throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
          state = tr.state;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      if (this.destroyed) {
        this.viewState.state = state;
        return;
      }
      var pendingKey = this.observer.delayedAndroidKey,
        domChange = null;
      if (pendingKey) {
        this.observer.clearDelayedAndroidKey();
        domChange = this.observer.readChange();
        if ((domChange && !this.state.doc.eq(state.doc)) || !this.state.selection.eq(state.selection)) domChange = null;
      } else {
        this.observer.clear();
      }
      if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases)) return this.setState(state);
      update2 = ViewUpdate.create(this, state, transactions);
      var scrollTarget = this.viewState.scrollTarget;
      try {
        this.updateState = 2;
        var _iteratorNormalCompletion1 = true,
          _didIteratorError1 = false,
          _iteratorError1 = undefined;
        try {
          for (var _iterator1 = transactions[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
            var tr1 = _step1.value;
            if (scrollTarget) scrollTarget = scrollTarget.map(tr1.changes);
            if (tr1.scrollIntoView) {
              var main = tr1.state.selection.main;
              scrollTarget = new ScrollTarget(main.empty ? main : EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));
            }
            var _iteratorNormalCompletion2 = true,
              _didIteratorError2 = false,
              _iteratorError2 = undefined;
            try {
              for (var _iterator2 = tr1.effects[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var e = _step2.value;
                if (e.is(scrollIntoView)) scrollTarget = e.value;
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError1 = true;
          _iteratorError1 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
              _iterator1.return();
            }
          } finally {
            if (_didIteratorError1) {
              throw _iteratorError1;
            }
          }
        }
        this.viewState.update(update2, scrollTarget);
        this.bidiCache = CachedOrder.update(this.bidiCache, update2.changes);
        if (!update2.empty) {
          this.updatePlugins(update2);
          this.inputState.update(update2);
        }
        redrawn = this.docView.update(update2);
        if (this.state.facet(styleModule) != this.styleModules) this.mountStyles();
        attrsChanged = this.updateAttrs();
        this.showAnnouncements(transactions);
        this.docView.updateSelection(
          redrawn,
          transactions.some((tr) => tr.isUserEvent("select.pointer"))
        );
      } finally {
        this.updateState = 0;
      }
      if (update2.startState.facet(theme) != update2.state.facet(theme)) this.viewState.mustMeasureContent = true;
      if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) this.requestMeasure();
      var _iteratorNormalCompletion3 = true,
        _didIteratorError3 = false,
        _iteratorError3 = undefined;
      if (!update2.empty)
        try {
          for (var _iterator3 = this.state.facet(updateListener)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var listener = _step3.value;
            listener(update2);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      if (domChange) {
        if (!applyDOMChange(this, domChange) && pendingKey.force) dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
      }
    }
    setState(newState) {
      if (this.updateState != 0) throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
      if (this.destroyed) {
        this.viewState.state = newState;
        return;
      }
      this.updateState = 2;
      var hadFocus = this.hasFocus;
      try {
        var _iteratorNormalCompletion = true,
          _didIteratorError = false,
          _iteratorError = undefined;
        try {
          for (var _iterator = this.plugins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var plugin = _step.value;
            plugin.destroy(this);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        this.viewState = new ViewState(newState);
        this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec));
        this.pluginMap.clear();
        var _iteratorNormalCompletion1 = true,
          _didIteratorError1 = false,
          _iteratorError1 = undefined;
        try {
          for (var _iterator1 = this.plugins[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
            var plugin1 = _step1.value;
            plugin1.update(this);
          }
        } catch (err) {
          _didIteratorError1 = true;
          _iteratorError1 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
              _iterator1.return();
            }
          } finally {
            if (_didIteratorError1) {
              throw _iteratorError1;
            }
          }
        }
        this.docView = new DocView(this);
        this.inputState.ensureHandlers(this, this.plugins);
        this.mountStyles();
        this.updateAttrs();
        this.bidiCache = [];
      } finally {
        this.updateState = 0;
      }
      if (hadFocus) this.focus();
      this.requestMeasure();
    }
    updatePlugins(update2) {
      var prevSpecs = update2.startState.facet(viewPlugin),
        specs = update2.state.facet(viewPlugin);
      if (prevSpecs != specs) {
        var newPlugins = [];
        var _iteratorNormalCompletion = true,
          _didIteratorError = false,
          _iteratorError = undefined;
        try {
          for (var _iterator = specs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var spec = _step.value;
            var found = prevSpecs.indexOf(spec);
            if (found < 0) {
              newPlugins.push(new PluginInstance(spec));
            } else {
              var plugin = this.plugins[found];
              plugin.mustUpdate = update2;
              newPlugins.push(plugin);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        var _iteratorNormalCompletion1 = true,
          _didIteratorError1 = false,
          _iteratorError1 = undefined;
        try {
          for (var _iterator1 = this.plugins[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
            var plugin1 = _step1.value;
            if (plugin1.mustUpdate != update2) plugin1.destroy(this);
          }
        } catch (err) {
          _didIteratorError1 = true;
          _iteratorError1 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
              _iterator1.return();
            }
          } finally {
            if (_didIteratorError1) {
              throw _iteratorError1;
            }
          }
        }
        this.plugins = newPlugins;
        this.pluginMap.clear();
        this.inputState.ensureHandlers(this, this.plugins);
      } else {
        var _iteratorNormalCompletion2 = true,
          _didIteratorError2 = false,
          _iteratorError2 = undefined;
        try {
          for (var _iterator2 = this.plugins[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var p = _step2.value;
            p.mustUpdate = update2;
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
      for (var i = 0; i < this.plugins.length; i++) this.plugins[i].update(this);
    }
    measure() {
      var flush2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (this.destroyed) return;
      if (this.measureScheduled > -1) cancelAnimationFrame(this.measureScheduled);
      this.measureScheduled = 0;
      if (flush2) this.observer.forceFlush();
      var updated = null;
      var _this_scrollDOM = this.scrollDOM,
        scrollHeight = _this_scrollDOM.scrollHeight,
        scrollTop = _this_scrollDOM.scrollTop,
        clientHeight = _this_scrollDOM.clientHeight;
      var refHeight = scrollTop > scrollHeight - clientHeight - 4 ? scrollHeight : scrollTop;
      try {
        var _this = this,
          _loop = function (i) {
            _this.updateState = 1;
            var oldViewport = _this.viewport;
            var refBlock = _this.viewState.lineBlockAtHeight(refHeight);
            var changed = _this.viewState.measure(_this);
            if (!changed && !_this.measureRequests.length && _this.viewState.scrollTarget == null) return "break";
            if (i > 5) {
              console.warn(_this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
              return "break";
            }
            var measuring = [];
            var ref;
            if (!(changed & 4)) (ref = [measuring, _this.measureRequests]), (_this.measureRequests = ref[0]), (measuring = ref[1]), ref;
            var measured = measuring.map((m) => {
              try {
                return m.read(_this);
              } catch (e) {
                logException(_this.state, e);
                return BadMeasure;
              }
            });
            var update2 = ViewUpdate.create(_this, _this.state, []),
              redrawn = false,
              scrolled = false;
            update2.flags |= changed;
            if (!updated) updated = update2;
            else updated.flags |= changed;
            _this.updateState = 2;
            if (!update2.empty) {
              _this.updatePlugins(update2);
              _this.inputState.update(update2);
              _this.updateAttrs();
              redrawn = _this.docView.update(update2);
            }
            for (var i2 = 0; i2 < measuring.length; i2++)
              if (measured[i2] != BadMeasure) {
                try {
                  var m = measuring[i2];
                  if (m.write) m.write(measured[i2], _this);
                } catch (e) {
                  logException(_this.state, e);
                }
              }
            if (_this.viewState.editorHeight) {
              if (_this.viewState.scrollTarget) {
                _this.docView.scrollIntoView(_this.viewState.scrollTarget);
                _this.viewState.scrollTarget = null;
                scrolled = true;
              } else {
                var diff = _this.viewState.lineBlockAt(refBlock.from).top - refBlock.top;
                if (diff > 1 || diff < -1) {
                  _this.scrollDOM.scrollTop += diff;
                  scrolled = true;
                }
              }
            }
            if (redrawn) _this.docView.updateSelection(true);
            if (_this.viewport.from == oldViewport.from && _this.viewport.to == oldViewport.to && !scrolled && _this.measureRequests.length == 0) return "break";
          };
        for (var i = 0; ; i++) {
          var _ret = _loop(i);
          if (_ret === "break") break;
        }
      } finally {
        this.updateState = 0;
        this.measureScheduled = -1;
      }
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      if (updated && !updated.empty)
        try {
          for (var _iterator = this.state.facet(updateListener)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var listener = _step.value;
            listener(updated);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
    }
    get themeClasses() {
      return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
    }
    updateAttrs() {
      var editorAttrs = attrsFromFacet(this, editorAttributes, {
        class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses,
      });
      var contentAttrs = {
        spellcheck: "false",
        autocorrect: "off",
        autocapitalize: "off",
        translate: "no",
        contenteditable: !this.state.facet(editable) ? "false" : "true",
        class: "cm-content",
        style: "".concat(browser.tabSize, ": ").concat(this.state.tabSize),
        role: "textbox",
        "aria-multiline": "true",
      };
      if (this.state.readOnly) contentAttrs["aria-readonly"] = "true";
      attrsFromFacet(this, contentAttributes, contentAttrs);
      var changed = this.observer.ignore(() => {
        var changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
        var changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
        return changedContent || changedEditor;
      });
      this.editorAttrs = editorAttrs;
      this.contentAttrs = contentAttrs;
      return changed;
    }
    showAnnouncements(trs) {
      var first = true;
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined,
        _iteratorNormalCompletion1 = true,
        _didIteratorError1 = false,
        _iteratorError1 = undefined;
      try {
        for (var _iterator = trs[Symbol.iterator](), _step; !(_iteratorNormalCompletion1 = (_step = _iterator.next()).done); _iteratorNormalCompletion1 = true) {
          var tr = _step.value;
          try {
            for (var _iterator1 = tr.effects[Symbol.iterator](), _step1; !(_iteratorNormalCompletion = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion = true) {
              var effect = _step1.value;
              if (effect.is(EditorView.announce)) {
                if (first) this.announceDOM.textContent = "";
                first = false;
                var div = this.announceDOM.appendChild(document.createElement("div"));
                div.textContent = effect.value;
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator1.return != null) {
                _iterator1.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError1 = true;
        _iteratorError1 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion1 && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError1) {
            throw _iteratorError1;
          }
        }
      }
    }
    mountStyles() {
      this.styleModules = this.state.facet(styleModule);
      StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse());
    }
    readMeasured() {
      if (this.updateState == 2) throw new Error("Reading the editor layout isn't allowed during an update");
      if (this.updateState == 0 && this.measureScheduled > -1) this.measure(false);
    }
    requestMeasure(request) {
      if (this.measureScheduled < 0) this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
      if (request) {
        if (request.key != null)
          for (var i = 0; i < this.measureRequests.length; i++) {
            if (this.measureRequests[i].key === request.key) {
              this.measureRequests[i] = request;
              return;
            }
          }
        this.measureRequests.push(request);
      }
    }
    plugin(plugin) {
      var known = this.pluginMap.get(plugin);
      if (known === void 0 || (known && known.spec != plugin)) this.pluginMap.set(plugin, (known = this.plugins.find((p) => p.spec == plugin) || null));
      return known && known.update(this).value;
    }
    get documentTop() {
      return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
    }
    get documentPadding() {
      return {
        top: this.viewState.paddingTop,
        bottom: this.viewState.paddingBottom,
      };
    }
    elementAtHeight(height) {
      this.readMeasured();
      return this.viewState.elementAtHeight(height);
    }
    lineBlockAtHeight(height) {
      this.readMeasured();
      return this.viewState.lineBlockAtHeight(height);
    }
    get viewportLineBlocks() {
      return this.viewState.viewportLines;
    }
    lineBlockAt(pos) {
      return this.viewState.lineBlockAt(pos);
    }
    get contentHeight() {
      return this.viewState.contentHeight;
    }
    moveByChar(start, forward, by) {
      return skipAtoms(this, start, moveByChar(this, start, forward, by));
    }
    moveByGroup(start, forward) {
      return skipAtoms(
        this,
        start,
        moveByChar(this, start, forward, (initial) => byGroup(this, start.head, initial))
      );
    }
    moveToLineBoundary(start, forward) {
      var includeWrap = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      return moveToLineBoundary(this, start, forward, includeWrap);
    }
    moveVertically(start, forward, distance) {
      return skipAtoms(this, start, moveVertically(this, start, forward, distance));
    }
    domAtPos(pos) {
      return this.docView.domAtPos(pos);
    }
    posAtDOM(node) {
      var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      return this.docView.posFromDOM(node, offset);
    }
    posAtCoords(coords) {
      var precise = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      this.readMeasured();
      return posAtCoords(this, coords, precise);
    }
    coordsAtPos(pos) {
      var side = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      this.readMeasured();
      var rect = this.docView.coordsAt(pos, side);
      if (!rect || rect.left == rect.right) return rect;
      var line = this.state.doc.lineAt(pos),
        order = this.bidiSpans(line);
      var span = order[BidiSpan.find(order, pos - line.from, -1, side)];
      return flattenRect(rect, (span.dir == Direction.LTR) == side > 0);
    }
    get defaultCharacterWidth() {
      return this.viewState.heightOracle.charWidth;
    }
    get defaultLineHeight() {
      return this.viewState.heightOracle.lineHeight;
    }
    get textDirection() {
      return this.viewState.defaultTextDirection;
    }
    textDirectionAt(pos) {
      var perLine = this.state.facet(perLineTextDirection);
      if (!perLine || pos < this.viewport.from || pos > this.viewport.to) return this.textDirection;
      this.readMeasured();
      return this.docView.textDirectionAt(pos);
    }
    get lineWrapping() {
      return this.viewState.heightOracle.lineWrapping;
    }
    bidiSpans(line) {
      if (line.length > MaxBidiLine) return trivialOrder(line.length);
      var dir = this.textDirectionAt(line.from);
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.bidiCache[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var entry = _step.value;
          if (entry.from == line.from && entry.dir == dir) return entry.order;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      var order = computeOrder(line.text, dir);
      this.bidiCache.push(new CachedOrder(line.from, line.to, dir, order));
      return order;
    }
    get hasFocus() {
      var _a2;
      return (this.dom.ownerDocument.hasFocus() || (browser.safari && ((_a2 = this.inputState) === null || _a2 === void 0 ? void 0 : _a2.lastContextMenu) > Date.now() - 3e4)) && this.root.activeElement == this.contentDOM;
    }
    focus() {
      this.observer.ignore(() => {
        focusPreventScroll(this.contentDOM);
        this.docView.updateSelection();
      });
    }
    setRoot(root) {
      if (this._root != root) {
        this._root = root;
        this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);
        this.mountStyles();
      }
    }
    destroy() {
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.plugins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var plugin = _step.value;
          plugin.destroy(this);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      this.plugins = [];
      this.inputState.destroy();
      this.dom.remove();
      this.observer.destroy();
      if (this.measureScheduled > -1) cancelAnimationFrame(this.measureScheduled);
      this.destroyed = true;
    }
    static scrollIntoView(pos) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return scrollIntoView.of(new ScrollTarget(typeof pos == "number" ? EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
    }
    static domEventHandlers(handlers2) {
      return ViewPlugin.define(() => ({}), {
        eventHandlers: handlers2,
      });
    }
    static theme(spec, options) {
      var prefix = StyleModule.newName();
      var result = [theme.of(prefix), styleModule.of(buildTheme(".".concat(prefix), spec))];
      if (options && options.dark) result.push(darkTheme.of(true));
      return result;
    }
    static baseTheme(spec) {
      return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
    }
    static findFromDOM(dom) {
      var _a2;
      var content2 = dom.querySelector(".cm-content");
      var cView = (content2 && ContentView.get(content2)) || ContentView.get(dom);
      return ((_a2 = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a2 === void 0 ? void 0 : _a2.view) || null;
    }
    constructor(ref) {
      var config = ref === void 0 ? {} : ref;
      this.plugins = [];
      this.pluginMap = /* @__PURE__ */ new Map();
      this.editorAttrs = {};
      this.contentAttrs = {};
      this.bidiCache = [];
      this.destroyed = false;
      this.updateState = 2;
      this.measureScheduled = -1;
      this.measureRequests = [];
      this.contentDOM = document.createElement("div");
      this.scrollDOM = document.createElement("div");
      this.scrollDOM.tabIndex = -1;
      this.scrollDOM.className = "cm-scroller";
      this.scrollDOM.appendChild(this.contentDOM);
      this.announceDOM = document.createElement("div");
      this.announceDOM.style.cssText = "position: fixed; top: -10000px";
      this.announceDOM.setAttribute("aria-live", "polite");
      this.dom = document.createElement("div");
      this.dom.appendChild(this.announceDOM);
      this.dom.appendChild(this.scrollDOM);
      this._dispatch = config.dispatch || ((tr) => this.update([tr]));
      this.dispatch = this.dispatch.bind(this);
      this._root = config.root || getRoot(config.parent) || document;
      this.viewState = new ViewState(config.state || EditorState.create(config));
      this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec));
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.plugins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var plugin = _step.value;
          plugin.update(this);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      this.observer = new DOMObserver(this);
      this.inputState = new InputState(this);
      this.inputState.ensureHandlers(this, this.plugins);
      this.docView = new DocView(this);
      this.mountStyles();
      this.updateAttrs();
      this.updateState = 0;
      this.requestMeasure();
      if (config.parent) config.parent.appendChild(this.dom);
    }
  };
  __name(EditorView, "EditorView");
  EditorView.styleModule = styleModule;
  EditorView.inputHandler = inputHandler;
  EditorView.perLineTextDirection = perLineTextDirection;
  EditorView.exceptionSink = exceptionSink;
  EditorView.updateListener = updateListener;
  EditorView.editable = editable;
  EditorView.mouseSelectionStyle = mouseSelectionStyle;
  EditorView.dragMovesSelection = dragMovesSelection$1;
  EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
  EditorView.decorations = decorations;
  EditorView.atomicRanges = atomicRanges;
  EditorView.scrollMargins = scrollMargins;
  EditorView.darkTheme = darkTheme;
  EditorView.contentAttributes = contentAttributes;
  EditorView.editorAttributes = editorAttributes;
  EditorView.lineWrapping = /* @__PURE__ */ EditorView.contentAttributes.of({
    class: "cm-lineWrapping",
  });
  EditorView.announce = /* @__PURE__ */ StateEffect.define();
  var MaxBidiLine = 4096;
  var BadMeasure = {};
  var CachedOrder = class CachedOrder1 {
    static update(cache, changes) {
      if (changes.empty) return cache;
      var result = [],
        lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;
      for (var i = Math.max(0, cache.length - 10); i < cache.length; i++) {
        var entry = cache[i];
        if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to)) result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.order));
      }
      return result;
    }
    constructor(from, to, dir, order) {
      this.from = from;
      this.to = to;
      this.dir = dir;
      this.order = order;
    }
  };
  __name(CachedOrder, "CachedOrder");
  function attrsFromFacet(view, facet, base2) {
    for (var sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--) {
      var source = sources[i],
        value = typeof source == "function" ? source(view) : source;
      if (value) combineAttrs(value, base2);
    }
    return base2;
  }
  __name(attrsFromFacet, "attrsFromFacet");
  var currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
  function normalizeKeyName(name2, platform) {
    var parts = name2.split(/-(?!$)/);
    var result = parts[parts.length - 1];
    if (result == "Space") result = " ";
    var alt, ctrl, shift2, meta2;
    for (var i = 0; i < parts.length - 1; ++i) {
      var mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) meta2 = true;
      else if (/^a(lt)?$/i.test(mod)) alt = true;
      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;
      else if (/^s(hift)?$/i.test(mod)) shift2 = true;
      else if (/^mod$/i.test(mod)) {
        if (platform == "mac") meta2 = true;
        else ctrl = true;
      } else throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt) result = "Alt-" + result;
    if (ctrl) result = "Ctrl-" + result;
    if (meta2) result = "Meta-" + result;
    if (shift2) result = "Shift-" + result;
    return result;
  }
  __name(normalizeKeyName, "normalizeKeyName");
  function modifiers(name2, event, shift2) {
    if (event.altKey) name2 = "Alt-" + name2;
    if (event.ctrlKey) name2 = "Ctrl-" + name2;
    if (event.metaKey) name2 = "Meta-" + name2;
    if (shift2 !== false && event.shiftKey) name2 = "Shift-" + name2;
    return name2;
  }
  __name(modifiers, "modifiers");
  var handleKeyEvents = /* @__PURE__ */ Prec.default(
    /* @__PURE__ */ EditorView.domEventHandlers({
      keydown(event, view) {
        return runHandlers(getKeymap(view.state), event, view, "editor");
      },
    })
  );
  var keymap = /* @__PURE__ */ Facet.define({
    enables: handleKeyEvents,
  });
  var Keymaps = /* @__PURE__ */ new WeakMap();
  function getKeymap(state) {
    var bindings = state.facet(keymap);
    var map = Keymaps.get(bindings);
    if (!map) Keymaps.set(bindings, (map = buildKeymap(bindings.reduce((a, b) => a.concat(b), []))));
    return map;
  }
  __name(getKeymap, "getKeymap");
  var storedPrefix = null;
  var PrefixTimeout = 4e3;
  function buildKeymap(bindings) {
    var platform = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : currentPlatform;
    var bound = /* @__PURE__ */ Object.create(null);
    var isPrefix = /* @__PURE__ */ Object.create(null);
    var checkPrefix = /* @__PURE__ */ __name((name2, is) => {
      var current = isPrefix[name2];
      if (current == null) isPrefix[name2] = is;
      else if (current != is) throw new Error("Key binding " + name2 + " is used both as a regular binding and as a multi-stroke prefix");
    }, "checkPrefix");
    var add2 = /* @__PURE__ */ __name((scope, key, command, preventDefault) => {
      var _loop = function (i) {
        var prefix = parts.slice(0, i).join(" ");
        checkPrefix(prefix, true);
        if (!scopeObj[prefix])
          scopeObj[prefix] = {
            preventDefault: true,
            run: [
              (view) => {
                var ourObj = (storedPrefix = {
                  view,
                  prefix,
                  scope,
                });
                setTimeout(() => {
                  if (storedPrefix == ourObj) storedPrefix = null;
                }, PrefixTimeout);
                return true;
              },
            ],
          };
      };
      var _a2, _b;
      var scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
      var parts = key.split(/ (?!$)/).map((k) => normalizeKeyName(k, platform));
      for (var i = 1; i < parts.length; i++) _loop(i);
      var full = parts.join(" ");
      checkPrefix(full, false);
      var binding =
        scopeObj[full] ||
        (scopeObj[full] = {
          preventDefault: false,
          run: ((_b = (_a2 = scopeObj._any) === null || _a2 === void 0 ? void 0 : _a2.run) === null || _b === void 0 ? void 0 : _b.slice()) || [],
        });
      if (command) binding.run.push(command);
      if (preventDefault) binding.preventDefault = true;
    }, "add");
    var _iteratorNormalCompletion = true,
      _didIteratorError = false,
      _iteratorError = undefined;
    try {
      for (var _iterator = bindings[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var b = _step.value;
        var scopes = b.scope ? b.scope.split(" ") : ["editor"];
        var _iteratorNormalCompletion1 = true,
          _didIteratorError1 = false,
          _iteratorError1 = undefined;
        if (b.any)
          try {
            for (var _iterator1 = scopes[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
              var scope = _step1.value;
              var scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
              if (!scopeObj._any)
                scopeObj._any = {
                  preventDefault: false,
                  run: [],
                };
              for (var key in scopeObj) scopeObj[key].run.push(b.any);
            }
          } catch (err) {
            _didIteratorError1 = true;
            _iteratorError1 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                _iterator1.return();
              }
            } finally {
              if (_didIteratorError1) {
                throw _iteratorError1;
              }
            }
          }
        var name2 = b[platform] || b.key;
        if (!name2) continue;
        var _iteratorNormalCompletion2 = true,
          _didIteratorError2 = false,
          _iteratorError2 = undefined;
        try {
          for (var _iterator2 = scopes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var scope1 = _step2.value;
            add2(scope1, name2, b.run, b.preventDefault);
            if (b.shift) add2(scope1, "Shift-" + name2, b.shift, b.preventDefault);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    return bound;
  }
  __name(buildKeymap, "buildKeymap");
  function runHandlers(map, event, view, scope) {
    var name2 = keyName(event);
    var charCode = codePointAt(name2, 0),
      isChar = codePointSize(charCode) == name2.length && name2 != " ";
    var prefix = "",
      fallthrough = false;
    if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
      prefix = storedPrefix.prefix + " ";
      if ((fallthrough = modifierCodes.indexOf(event.keyCode) < 0)) storedPrefix = null;
    }
    var ran = /* @__PURE__ */ new Set();
    var runFor = /* @__PURE__ */ __name((binding) => {
      if (binding) {
        var _iteratorNormalCompletion = true,
          _didIteratorError = false,
          _iteratorError = undefined;
        try {
          for (var _iterator = binding.run[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var cmd2 = _step.value;
            if (!ran.has(cmd2)) {
              ran.add(cmd2);
              if (cmd2(view, event)) return true;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        if (binding.preventDefault) fallthrough = true;
      }
      return false;
    }, "runFor");
    var scopeObj = map[scope],
      baseName,
      shiftName;
    if (scopeObj) {
      if (runFor(scopeObj[prefix + modifiers(name2, event, !isChar)])) return true;
      if (isChar && (event.altKey || event.metaKey || event.ctrlKey) && (baseName = base[event.keyCode]) && baseName != name2) {
        if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) return true;
        else if (event.shiftKey && (shiftName = shift[event.keyCode]) != name2 && shiftName != baseName && runFor(scopeObj[prefix + modifiers(shiftName, event, false)])) return true;
      } else if (isChar && event.shiftKey) {
        if (runFor(scopeObj[prefix + modifiers(name2, event, true)])) return true;
      }
      if (runFor(scopeObj._any)) return true;
    }
    return fallthrough;
  }
  __name(runHandlers, "runHandlers");
  var RectangleMarker = class RectangleMarker1 {
    draw() {
      var elt = document.createElement("div");
      elt.className = this.className;
      this.adjust(elt);
      return elt;
    }
    update(elt, prev) {
      if (prev.className != this.className) return false;
      this.adjust(elt);
      return true;
    }
    adjust(elt) {
      elt.style.left = this.left + "px";
      elt.style.top = this.top + "px";
      if (this.width != null) elt.style.width = this.width + "px";
      elt.style.height = this.height + "px";
    }
    eq(p) {
      return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;
    }
    static forRange(view, className, range) {
      if (range.empty) {
        var pos = view.coordsAtPos(range.head, range.assoc || 1);
        if (!pos) return [];
        var base2 = getBase(view);
        return [new RectangleMarker(className, pos.left - base2.left, pos.top - base2.top, null, pos.bottom - pos.top)];
      } else {
        return rectanglesForRange(view, className, range);
      }
    }
    constructor(className, left, top2, width, height) {
      this.className = className;
      this.left = left;
      this.top = top2;
      this.width = width;
      this.height = height;
    }
  };
  __name(RectangleMarker, "RectangleMarker");
  function getBase(view) {
    var rect = view.scrollDOM.getBoundingClientRect();
    var left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth;
    return {
      left: left - view.scrollDOM.scrollLeft,
      top: rect.top - view.scrollDOM.scrollTop,
    };
  }
  __name(getBase, "getBase");
  function wrappedLine(view, pos, inside2) {
    var range = EditorSelection.cursor(pos);
    return {
      from: Math.max(inside2.from, view.moveToLineBoundary(range, false, true).from),
      to: Math.min(inside2.to, view.moveToLineBoundary(range, true, true).from),
      type: BlockType.Text,
    };
  }
  __name(wrappedLine, "wrappedLine");
  function blockAt(view, pos) {
    var line = view.lineBlockAt(pos);
    var _iteratorNormalCompletion = true,
      _didIteratorError = false,
      _iteratorError = undefined;
    if (Array.isArray(line.type))
      try {
        for (var _iterator = line.type[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var l = _step.value;
          if (l.to > pos || (l.to == pos && (l.to == line.to || l.type == BlockType.Text))) return l;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    return line;
  }
  __name(blockAt, "blockAt");
  function rectanglesForRange(view, className, range) {
    if (range.to <= view.viewport.from || range.from >= view.viewport.to) return [];
    var from = Math.max(range.from, view.viewport.from),
      to = Math.min(range.to, view.viewport.to);
    var ltr = view.textDirection == Direction.LTR;
    var content2 = view.contentDOM,
      contentRect = content2.getBoundingClientRect(),
      base2 = getBase(view);
    var lineStyle = window.getComputedStyle(content2.firstChild);
    var leftSide = contentRect.left + parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent));
    var rightSide = contentRect.right - parseInt(lineStyle.paddingRight);
    var startBlock = blockAt(view, from),
      endBlock = blockAt(view, to);
    var visualStart = startBlock.type == BlockType.Text ? startBlock : null;
    var visualEnd = endBlock.type == BlockType.Text ? endBlock : null;
    if (view.lineWrapping) {
      if (visualStart) visualStart = wrappedLine(view, from, visualStart);
      if (visualEnd) visualEnd = wrappedLine(view, to, visualEnd);
    }
    if (visualStart && visualEnd && visualStart.from == visualEnd.from) {
      return pieces(drawForLine(range.from, range.to, visualStart));
    } else {
      var top2 = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);
      var bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);
      var between = [];
      if ((visualStart || startBlock).to < (visualEnd || endBlock).from - 1) between.push(piece(leftSide, top2.bottom, rightSide, bottom.top));
      else if (top2.bottom < bottom.top && view.elementAtHeight((top2.bottom + bottom.top) / 2).type == BlockType.Text) top2.bottom = bottom.top = (top2.bottom + bottom.top) / 2;
      return pieces(top2).concat(between).concat(pieces(bottom));
    }
    function piece(left, top2, right, bottom) {
      return new RectangleMarker(className, left - base2.left, top2 - base2.top - 0.01, right - left, bottom - top2 + 0.01);
    }
    __name(piece, "piece");
    function pieces(param) {
      var top2 = param.top,
        bottom = param.bottom,
        horizontal = param.horizontal;
      var pieces2 = [];
      for (var i = 0; i < horizontal.length; i += 2) pieces2.push(piece(horizontal[i], top2, horizontal[i + 1], bottom));
      return pieces2;
    }
    __name(pieces, "pieces");
    function drawForLine(from2, to2, line) {
      var top2 = 1e9,
        bottom = -1e9,
        horizontal = [];
      function addSpan(from3, fromOpen, to3, toOpen, dir) {
        var fromCoords = view.coordsAtPos(from3, from3 == line.to ? -2 : 2);
        var toCoords = view.coordsAtPos(to3, to3 == line.from ? 2 : -2);
        top2 = Math.min(fromCoords.top, toCoords.top, top2);
        bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
        if (dir == Direction.LTR) horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
        else horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
      }
      __name(addSpan, "addSpan");
      var start = from2 !== null && from2 !== void 0 ? from2 : line.from,
        end = to2 !== null && to2 !== void 0 ? to2 : line.to;
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = view.visibleRanges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var r = _step.value;
          if (r.to > start && r.from < end) {
            for (var pos = Math.max(r.from, start), endPos = Math.min(r.to, end); ; ) {
              var docLine = view.state.doc.lineAt(pos);
              var _iteratorNormalCompletion1 = true,
                _didIteratorError1 = false,
                _iteratorError1 = undefined;
              try {
                for (var _iterator1 = view.bidiSpans(docLine)[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
                  var span = _step1.value;
                  var spanFrom = span.from + docLine.from,
                    spanTo = span.to + docLine.from;
                  if (spanFrom >= endPos) break;
                  if (spanTo > pos) addSpan(Math.max(spanFrom, pos), from2 == null && spanFrom <= start, Math.min(spanTo, endPos), to2 == null && spanTo >= end, span.dir);
                }
              } catch (err) {
                _didIteratorError1 = true;
                _iteratorError1 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                    _iterator1.return();
                  }
                } finally {
                  if (_didIteratorError1) {
                    throw _iteratorError1;
                  }
                }
              }
              pos = docLine.to + 1;
              if (pos >= endPos) break;
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      if (horizontal.length == 0) addSpan(start, from2 == null, end, to2 == null, view.textDirection);
      return {
        top: top2,
        bottom,
        horizontal,
      };
    }
    __name(drawForLine, "drawForLine");
    function drawForWidget(block, top2) {
      var y = contentRect.top + (top2 ? block.top : block.bottom);
      return {
        top: y,
        bottom: y,
        horizontal: [],
      };
    }
    __name(drawForWidget, "drawForWidget");
  }
  __name(rectanglesForRange, "rectanglesForRange");
  function sameMarker(a, b) {
    return a.constructor == b.constructor && a.eq(b);
  }
  __name(sameMarker, "sameMarker");
  var LayerView = class LayerView {
    update(update2) {
      if (update2.startState.facet(layerOrder) != update2.state.facet(layerOrder)) this.setOrder(update2.state);
      if (this.layer.update(update2, this.dom) || update2.geometryChanged) update2.view.requestMeasure(this.measureReq);
    }
    setOrder(state) {
      var pos = 0,
        order = state.facet(layerOrder);
      while (pos < order.length && order[pos] != this.layer) pos++;
      this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);
    }
    measure() {
      return this.layer.markers(this.view);
    }
    draw(markers) {
      if (markers.length != this.drawn.length || markers.some((p, i) => !sameMarker(p, this.drawn[i]))) {
        var old = this.dom.firstChild,
          oldI = 0;
        var _iteratorNormalCompletion = true,
          _didIteratorError = false,
          _iteratorError = undefined;
        try {
          for (var _iterator = markers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var marker = _step.value;
            if (marker.update && old && marker.constructor && this.drawn[oldI].constructor && marker.update(old, this.drawn[oldI])) {
              old = old.nextSibling;
              oldI++;
            } else {
              this.dom.insertBefore(marker.draw(), old);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        while (old) {
          var next = old.nextSibling;
          old.remove();
          old = next;
        }
        this.drawn = markers;
      }
    }
    destroy() {
      if (this.layer.destroy) this.layer.destroy(this.dom, this.view);
      this.dom.remove();
    }
    constructor(view, layer2) {
      this.view = view;
      this.layer = layer2;
      this.drawn = [];
      this.measureReq = {
        read: this.measure.bind(this),
        write: this.draw.bind(this),
      };
      this.dom = view.scrollDOM.appendChild(document.createElement("div"));
      this.dom.classList.add("cm-layer");
      if (layer2.above) this.dom.classList.add("cm-layer-above");
      if (layer2.class) this.dom.classList.add(layer2.class);
      this.dom.setAttribute("aria-hidden", "true");
      this.setOrder(view.state);
      view.requestMeasure(this.measureReq);
      if (layer2.mount) layer2.mount(this.dom, view);
    }
  };
  __name(LayerView, "LayerView");
  var layerOrder = /* @__PURE__ */ Facet.define();
  function layer(config) {
    return [ViewPlugin.define((v) => new LayerView(v, config)), layerOrder.of(config)];
  }
  __name(layer, "layer");
  var CanHidePrimary = !browser.ios;
  var selectionConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(
        configs,
        {
          cursorBlinkRate: 1200,
          drawRangeCursor: true,
        },
        {
          cursorBlinkRate: (a, b) => Math.min(a, b),
          drawRangeCursor: (a, b) => a || b,
        }
      );
    },
  });
  function drawSelection() {
    var config = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return [selectionConfig.of(config), cursorLayer, selectionLayer, hideNativeSelection, nativeSelectionHidden.of(true)];
  }
  __name(drawSelection, "drawSelection");
  function configChanged(update2) {
    return update2.startState.facet(selectionConfig) != update2.startState.facet(selectionConfig);
  }
  __name(configChanged, "configChanged");
  var cursorLayer = /* @__PURE__ */ layer({
    above: true,
    markers(view) {
      var state = view.state,
        conf = state.facet(selectionConfig);
      var cursors = [];
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = state.selection.ranges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var r = _step.value;
          var prim = r == state.selection.main;
          if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {
            var className = prim ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary";
            var cursor = r.empty ? r : EditorSelection.cursor(r.head, r.head > r.anchor ? -1 : 1);
            var _iteratorNormalCompletion1 = true,
              _didIteratorError1 = false,
              _iteratorError1 = undefined;
            try {
              for (var _iterator1 = RectangleMarker.forRange(view, className, cursor)[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
                var piece = _step1.value;
                cursors.push(piece);
              }
            } catch (err) {
              _didIteratorError1 = true;
              _iteratorError1 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                  _iterator1.return();
                }
              } finally {
                if (_didIteratorError1) {
                  throw _iteratorError1;
                }
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return cursors;
    },
    update(update2, dom) {
      if (update2.transactions.some((tr) => tr.scrollIntoView)) dom.style.animationName = dom.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
      var confChange = configChanged(update2);
      if (confChange) setBlinkRate(update2.state, dom);
      return update2.docChanged || update2.selectionSet || confChange;
    },
    mount(dom, view) {
      setBlinkRate(view.state, dom);
    },
    class: "cm-cursorLayer",
  });
  function setBlinkRate(state, dom) {
    dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + "ms";
  }
  __name(setBlinkRate, "setBlinkRate");
  var selectionLayer = /* @__PURE__ */ layer({
    above: false,
    markers(view) {
      return view.state.selection.ranges.map((r) => (r.empty ? [] : RectangleMarker.forRange(view, "cm-selectionBackground", r))).reduce((a, b) => a.concat(b));
    },
    update(update2, dom) {
      return update2.docChanged || update2.selectionSet || update2.viewportChanged || configChanged(update2);
    },
    class: "cm-selectionLayer",
  });
  var themeSpec = {
    ".cm-line": {
      "& ::selection": {
        backgroundColor: "transparent !important",
      },
      "&::selection": {
        backgroundColor: "transparent !important",
      },
    },
  };
  if (CanHidePrimary) themeSpec[".cm-line"].caretColor = "transparent !important";
  var hideNativeSelection = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ EditorView.theme(themeSpec));
  var setDropCursorPos = /* @__PURE__ */ StateEffect.define({
    map(pos, mapping) {
      return pos == null ? null : mapping.mapPos(pos);
    },
  });
  var dropCursorPos = /* @__PURE__ */ StateField.define({
    create() {
      return null;
    },
    update(pos, tr) {
      if (pos != null) pos = tr.changes.mapPos(pos);
      return tr.effects.reduce((pos2, e) => (e.is(setDropCursorPos) ? e.value : pos2), pos);
    },
  });
  var drawDropCursor = /* @__PURE__ */ ViewPlugin.fromClass(
    class {
      update(update2) {
        var _a2;
        var cursorPos = update2.state.field(dropCursorPos);
        if (cursorPos == null) {
          if (this.cursor != null) {
            (_a2 = this.cursor) === null || _a2 === void 0 ? void 0 : _a2.remove();
            this.cursor = null;
          }
        } else {
          if (!this.cursor) {
            this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"));
            this.cursor.className = "cm-dropCursor";
          }
          if (update2.startState.field(dropCursorPos) != cursorPos || update2.docChanged || update2.geometryChanged) this.view.requestMeasure(this.measureReq);
        }
      }
      readPos() {
        var pos = this.view.state.field(dropCursorPos);
        var rect = pos != null && this.view.coordsAtPos(pos);
        if (!rect) return null;
        var outer = this.view.scrollDOM.getBoundingClientRect();
        return {
          left: rect.left - outer.left + this.view.scrollDOM.scrollLeft,
          top: rect.top - outer.top + this.view.scrollDOM.scrollTop,
          height: rect.bottom - rect.top,
        };
      }
      drawCursor(pos) {
        if (this.cursor) {
          if (pos) {
            this.cursor.style.left = pos.left + "px";
            this.cursor.style.top = pos.top + "px";
            this.cursor.style.height = pos.height + "px";
          } else {
            this.cursor.style.left = "-100000px";
          }
        }
      }
      destroy() {
        if (this.cursor) this.cursor.remove();
      }
      setDropPos(pos) {
        if (this.view.state.field(dropCursorPos) != pos)
          this.view.dispatch({
            effects: setDropCursorPos.of(pos),
          });
      }
      constructor(view) {
        this.view = view;
        this.cursor = null;
        this.measureReq = {
          read: this.readPos.bind(this),
          write: this.drawCursor.bind(this),
        };
      }
    },
    {
      eventHandlers: {
        dragover(event) {
          this.setDropPos(
            this.view.posAtCoords({
              x: event.clientX,
              y: event.clientY,
            })
          );
        },
        dragleave(event) {
          if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget)) this.setDropPos(null);
        },
        dragend() {
          this.setDropPos(null);
        },
        drop() {
          this.setDropPos(null);
        },
      },
    }
  );
  function dropCursor() {
    return [dropCursorPos, drawDropCursor];
  }
  __name(dropCursor, "dropCursor");
  var UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
  var Outside = "-10000px";
  var TooltipViewManager = class TooltipViewManager {
    update(update2) {
      var _a2;
      var input = update2.state.facet(this.facet);
      var tooltips = input.filter((x) => x);
      if (input === this.input) {
        var _iteratorNormalCompletion = true,
          _didIteratorError = false,
          _iteratorError = undefined;
        try {
          for (var _iterator = this.tooltipViews[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var t2 = _step.value;
            if (t2.update) t2.update(update2);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        return false;
      }
      var tooltipViews = [];
      for (var i = 0; i < tooltips.length; i++) {
        var tip = tooltips[i],
          known = -1;
        if (!tip) continue;
        for (var i2 = 0; i2 < this.tooltips.length; i2++) {
          var other = this.tooltips[i2];
          if (other && other.create == tip.create) known = i2;
        }
        if (known < 0) {
          tooltipViews[i] = this.createTooltipView(tip);
        } else {
          var tooltipView = (tooltipViews[i] = this.tooltipViews[known]);
          if (tooltipView.update) tooltipView.update(update2);
        }
      }
      var _iteratorNormalCompletion1 = true,
        _didIteratorError1 = false,
        _iteratorError1 = undefined;
      try {
        for (var _iterator1 = this.tooltipViews[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
          var t21 = _step1.value;
          if (tooltipViews.indexOf(t21) < 0) {
            t21.dom.remove();
            (_a2 = t21.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(t21);
          }
        }
      } catch (err) {
        _didIteratorError1 = true;
        _iteratorError1 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
            _iterator1.return();
          }
        } finally {
          if (_didIteratorError1) {
            throw _iteratorError1;
          }
        }
      }
      this.input = input;
      this.tooltips = tooltips;
      this.tooltipViews = tooltipViews;
      return true;
    }
    constructor(view, facet, createTooltipView) {
      this.facet = facet;
      this.createTooltipView = createTooltipView;
      this.input = view.state.facet(facet);
      this.tooltips = this.input.filter((t2) => t2);
      this.tooltipViews = this.tooltips.map(createTooltipView);
    }
  };
  __name(TooltipViewManager, "TooltipViewManager");
  function windowSpace(view) {
    var win = view.win;
    return {
      top: 0,
      left: 0,
      bottom: win.innerHeight,
      right: win.innerWidth,
    };
  }
  __name(windowSpace, "windowSpace");
  var tooltipConfig = /* @__PURE__ */ Facet.define({
    combine: (values) => {
      var _a2, _b, _c;
      return {
        position: browser.ios ? "absolute" : ((_a2 = values.find((conf) => conf.position)) === null || _a2 === void 0 ? void 0 : _a2.position) || "fixed",
        parent: ((_b = values.find((conf) => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
        tooltipSpace: ((_c = values.find((conf) => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace,
      };
    },
  });
  var tooltipPlugin = /* @__PURE__ */ ViewPlugin.fromClass(
    class {
      createContainer() {
        if (this.parent) {
          this.container = document.createElement("div");
          this.container.style.position = "relative";
          this.container.className = this.view.themeClasses;
          this.parent.appendChild(this.container);
        } else {
          this.container = this.view.dom;
        }
      }
      observeIntersection() {
        if (this.intersectionObserver) {
          this.intersectionObserver.disconnect();
          var _iteratorNormalCompletion = true,
            _didIteratorError = false,
            _iteratorError = undefined;
          try {
            for (var _iterator = this.manager.tooltipViews[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var tooltip = _step.value;
              this.intersectionObserver.observe(tooltip.dom);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }
      }
      measureSoon() {
        if (this.measureTimeout < 0)
          this.measureTimeout = setTimeout(() => {
            this.measureTimeout = -1;
            this.maybeMeasure();
          }, 50);
      }
      update(update2) {
        if (update2.transactions.length) this.lastTransaction = Date.now();
        var updated = this.manager.update(update2);
        if (updated) this.observeIntersection();
        var shouldMeasure = updated || update2.geometryChanged;
        var newConfig = update2.state.facet(tooltipConfig);
        if (newConfig.position != this.position) {
          this.position = newConfig.position;
          var _iteratorNormalCompletion = true,
            _didIteratorError = false,
            _iteratorError = undefined;
          try {
            for (var _iterator = this.manager.tooltipViews[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var t2 = _step.value;
              t2.dom.style.position = this.position;
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
          shouldMeasure = true;
        }
        if (newConfig.parent != this.parent) {
          if (this.parent) this.container.remove();
          this.parent = newConfig.parent;
          this.createContainer();
          var _iteratorNormalCompletion1 = true,
            _didIteratorError1 = false,
            _iteratorError1 = undefined;
          try {
            for (var _iterator1 = this.manager.tooltipViews[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
              var t21 = _step1.value;
              this.container.appendChild(t21.dom);
            }
          } catch (err) {
            _didIteratorError1 = true;
            _iteratorError1 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                _iterator1.return();
              }
            } finally {
              if (_didIteratorError1) {
                throw _iteratorError1;
              }
            }
          }
          shouldMeasure = true;
        } else if (this.parent && this.view.themeClasses != this.classes) {
          this.classes = this.container.className = this.view.themeClasses;
        }
        if (shouldMeasure) this.maybeMeasure();
      }
      createTooltip(tooltip) {
        var tooltipView = tooltip.create(this.view);
        tooltipView.dom.classList.add("cm-tooltip");
        if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
          var arrow = document.createElement("div");
          arrow.className = "cm-tooltip-arrow";
          tooltipView.dom.appendChild(arrow);
        }
        tooltipView.dom.style.position = this.position;
        tooltipView.dom.style.top = Outside;
        this.container.appendChild(tooltipView.dom);
        if (tooltipView.mount) tooltipView.mount(this.view);
        return tooltipView;
      }
      destroy() {
        var _a2, _b;
        this.view.win.removeEventListener("resize", this.measureSoon);
        var _iteratorNormalCompletion = true,
          _didIteratorError = false,
          _iteratorError = undefined;
        try {
          for (var _iterator = this.manager.tooltipViews[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var tooltipView = _step.value;
            tooltipView.dom.remove();
            (_a2 = tooltipView.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(tooltipView);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        (_b = this.intersectionObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
        clearTimeout(this.measureTimeout);
      }
      readMeasure() {
        var editor = this.view.dom.getBoundingClientRect();
        return {
          editor,
          parent: this.parent ? this.container.getBoundingClientRect() : editor,
          pos: this.manager.tooltips.map((t2, i) => {
            var tv = this.manager.tooltipViews[i];
            return tv.getCoords ? tv.getCoords(t2.pos) : this.view.coordsAtPos(t2.pos);
          }),
          size: this.manager.tooltipViews.map((param) => {
            var dom = param.dom;
            return dom.getBoundingClientRect();
          }),
          space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),
        };
      }
      writeMeasure(measured) {
        var editor = measured.editor,
          space2 = measured.space;
        var others = [];
        for (var i = 0; i < this.manager.tooltips.length; i++) {
          var tooltip = this.manager.tooltips[i],
            tView = this.manager.tooltipViews[i],
            dom = tView.dom;
          var pos = measured.pos[i],
            size = measured.size[i];
          if (!pos || pos.bottom <= Math.max(editor.top, space2.top) || pos.top >= Math.min(editor.bottom, space2.bottom) || pos.right < Math.max(editor.left, space2.left) - 0.1 || pos.left > Math.min(editor.right, space2.right) + 0.1) {
            dom.style.top = Outside;
            continue;
          }
          var arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
          var arrowHeight = arrow ? 7 : 0;
          var width = size.right - size.left,
            height = size.bottom - size.top;
          var offset = tView.offset || noOffset,
            ltr = this.view.textDirection == Direction.LTR;
          var left = size.width > space2.right - space2.left ? (ltr ? space2.left : space2.right - size.width) : ltr ? Math.min(pos.left - (arrow ? 14 : 0) + offset.x, space2.right - width) : Math.max(space2.left, pos.left - width + (arrow ? 14 : 0) - offset.x);
          var above = !!tooltip.above;
          if (!tooltip.strictSide && (above ? pos.top - (size.bottom - size.top) - offset.y < space2.top : pos.bottom + (size.bottom - size.top) + offset.y > space2.bottom) && above == space2.bottom - pos.bottom > pos.top - space2.top) above = !above;
          var spaceVert = (above ? pos.top - space2.top : space2.bottom - pos.bottom) - arrowHeight;
          if (spaceVert < height && tView.resize !== false) {
            if (spaceVert < this.view.defaultLineHeight) {
              dom.style.top = Outside;
              continue;
            }
            dom.style.height = (height = spaceVert) + "px";
          } else if (dom.style.height) {
            dom.style.height = "";
          }
          var top2 = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;
          var right = left + width;
          if (tView.overlap !== true) {
            var _iteratorNormalCompletion = true,
              _didIteratorError = false,
              _iteratorError = undefined;
            try {
              for (var _iterator = others[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var r = _step.value;
                if (r.left < right && r.right > left && r.top < top2 + height && r.bottom > top2) top2 = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          }
          if (this.position == "absolute") {
            dom.style.top = top2 - measured.parent.top + "px";
            dom.style.left = left - measured.parent.left + "px";
          } else {
            dom.style.top = top2 + "px";
            dom.style.left = left + "px";
          }
          if (arrow) arrow.style.left = "".concat(pos.left + (ltr ? offset.x : -offset.x) - (left + 14 - 7), "px");
          if (tView.overlap !== true)
            others.push({
              left,
              top: top2,
              right,
              bottom: top2 + height,
            });
          dom.classList.toggle("cm-tooltip-above", above);
          dom.classList.toggle("cm-tooltip-below", !above);
          if (tView.positioned) tView.positioned(measured.space);
        }
      }
      maybeMeasure() {
        if (this.manager.tooltips.length) {
          if (this.view.inView) this.view.requestMeasure(this.measureReq);
          if (this.inView != this.view.inView) {
            this.inView = this.view.inView;
            var _iteratorNormalCompletion = true,
              _didIteratorError = false,
              _iteratorError = undefined;
            if (!this.inView)
              try {
                for (var _iterator = this.manager.tooltipViews[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var tv = _step.value;
                  tv.dom.style.top = Outside;
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }
          }
        }
      }
      constructor(view) {
        this.view = view;
        this.inView = true;
        this.lastTransaction = 0;
        this.measureTimeout = -1;
        var config = view.state.facet(tooltipConfig);
        this.position = config.position;
        this.parent = config.parent;
        this.classes = view.themeClasses;
        this.createContainer();
        this.measureReq = {
          read: this.readMeasure.bind(this),
          write: this.writeMeasure.bind(this),
          key: this,
        };
        this.manager = new TooltipViewManager(view, showTooltip, (t2) => this.createTooltip(t2));
        this.intersectionObserver =
          typeof IntersectionObserver == "function"
            ? new IntersectionObserver(
                (entries) => {
                  if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1) this.measureSoon();
                },
                {
                  threshold: [1],
                }
              )
            : null;
        this.observeIntersection();
        view.win.addEventListener("resize", (this.measureSoon = this.measureSoon.bind(this)));
        this.maybeMeasure();
      }
    },
    {
      eventHandlers: {
        scroll() {
          this.maybeMeasure();
        },
      },
    }
  );
  var baseTheme = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-tooltip": {
      zIndex: 100,
      boxSizing: "border-box",
    },
    "&light .cm-tooltip": {
      border: "1px solid #bbb",
      backgroundColor: "#f5f5f5",
    },
    "&light .cm-tooltip-section:not(:first-child)": {
      borderTop: "1px solid #bbb",
    },
    "&dark .cm-tooltip": {
      backgroundColor: "#333338",
      color: "white",
    },
    ".cm-tooltip-arrow": {
      height: "".concat(7, "px"),
      width: "".concat(7 * 2, "px"),
      position: "absolute",
      zIndex: -1,
      overflow: "hidden",
      "&:before, &:after": {
        content: "''",
        position: "absolute",
        width: 0,
        height: 0,
        borderLeft: "".concat(7, "px solid transparent"),
        borderRight: "".concat(7, "px solid transparent"),
      },
      ".cm-tooltip-above &": {
        bottom: "-".concat(7, "px"),
        "&:before": {
          borderTop: "".concat(7, "px solid #bbb"),
        },
        "&:after": {
          borderTop: "".concat(7, "px solid #f5f5f5"),
          bottom: "1px",
        },
      },
      ".cm-tooltip-below &": {
        top: "-".concat(7, "px"),
        "&:before": {
          borderBottom: "".concat(7, "px solid #bbb"),
        },
        "&:after": {
          borderBottom: "".concat(7, "px solid #f5f5f5"),
          top: "1px",
        },
      },
    },
    "&dark .cm-tooltip .cm-tooltip-arrow": {
      "&:before": {
        borderTopColor: "#333338",
        borderBottomColor: "#333338",
      },
      "&:after": {
        borderTopColor: "transparent",
        borderBottomColor: "transparent",
      },
    },
  });
  var noOffset = {
    x: 0,
    y: 0,
  };
  var showTooltip = /* @__PURE__ */ Facet.define({
    enables: [tooltipPlugin, baseTheme],
  });
  var showHoverTooltip = /* @__PURE__ */ Facet.define();
  var HoverTooltipHost = class HoverTooltipHost1 {
    static create(view) {
      return new HoverTooltipHost(view);
    }
    createHostedView(tooltip) {
      var hostedView = tooltip.create(this.view);
      hostedView.dom.classList.add("cm-tooltip-section");
      this.dom.appendChild(hostedView.dom);
      if (this.mounted && hostedView.mount) hostedView.mount(this.view);
      return hostedView;
    }
    mount(view) {
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.manager.tooltipViews[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var hostedView = _step.value;
          if (hostedView.mount) hostedView.mount(view);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      this.mounted = true;
    }
    positioned(space2) {
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.manager.tooltipViews[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var hostedView = _step.value;
          if (hostedView.positioned) hostedView.positioned(space2);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    update(update2) {
      this.manager.update(update2);
    }
    constructor(view) {
      this.view = view;
      this.mounted = false;
      this.dom = document.createElement("div");
      this.dom.classList.add("cm-tooltip-hover");
      this.manager = new TooltipViewManager(view, showHoverTooltip, (t2) => this.createHostedView(t2));
    }
  };
  __name(HoverTooltipHost, "HoverTooltipHost");
  var showHoverTooltipHost = /* @__PURE__ */ showTooltip.compute([showHoverTooltip], (state) => {
    var tooltips = state.facet(showHoverTooltip).filter((t2) => t2);
    if (tooltips.length === 0) return null;
    return {
      pos: Math.min(...tooltips.map((t2) => t2.pos)),
      end: Math.max(...tooltips.filter((t2) => t2.end != null).map((t2) => t2.end)),
      create: HoverTooltipHost.create,
      above: tooltips[0].above,
      arrow: tooltips.some((t2) => t2.arrow),
    };
  });
  var HoverPlugin = class HoverPlugin {
    update() {
      if (this.pending) {
        this.pending = null;
        clearTimeout(this.restartTimeout);
        this.restartTimeout = setTimeout(() => this.startHover(), 20);
      }
    }
    get active() {
      return this.view.state.field(this.field);
    }
    checkHover() {
      this.hoverTimeout = -1;
      if (this.active) return;
      var hovered = Date.now() - this.lastMove.time;
      if (hovered < this.hoverTime) this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);
      else this.startHover();
    }
    startHover() {
      clearTimeout(this.restartTimeout);
      var lastMove = this.lastMove;
      var pos = this.view.contentDOM.contains(lastMove.target) ? this.view.posAtCoords(lastMove) : null;
      if (pos == null) return;
      var posCoords = this.view.coordsAtPos(pos);
      if (posCoords == null || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - this.view.defaultCharacterWidth || lastMove.x > posCoords.right + this.view.defaultCharacterWidth) return;
      var bidi = this.view.bidiSpans(this.view.state.doc.lineAt(pos)).find((s) => s.from <= pos && s.to >= pos);
      var rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;
      var open = this.source(this.view, pos, lastMove.x < posCoords.left ? -rtl : rtl);
      if (open === null || open === void 0 ? void 0 : open.then) {
        var pending = (this.pending = {
          pos,
        });
        open.then(
          (result) => {
            if (this.pending == pending) {
              this.pending = null;
              if (result)
                this.view.dispatch({
                  effects: this.setHover.of(result),
                });
            }
          },
          (e) => logException(this.view.state, e, "hover tooltip")
        );
      } else if (open) {
        this.view.dispatch({
          effects: this.setHover.of(open),
        });
      }
    }
    mousemove(event) {
      var _a2;
      this.lastMove = {
        x: event.clientX,
        y: event.clientY,
        target: event.target,
        time: Date.now(),
      };
      if (this.hoverTimeout < 0) this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
      var tooltip = this.active;
      if ((tooltip && !isInTooltip(this.lastMove.target)) || this.pending) {
        var pos = (tooltip || this.pending).pos,
          end = (_a2 = tooltip === null || tooltip === void 0 ? void 0 : tooltip.end) !== null && _a2 !== void 0 ? _a2 : pos;
        if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY, 6)) {
          this.view.dispatch({
            effects: this.setHover.of(null),
          });
          this.pending = null;
        }
      }
    }
    mouseleave(e) {
      clearTimeout(this.hoverTimeout);
      this.hoverTimeout = -1;
      if (this.active && !isInTooltip(e.relatedTarget))
        this.view.dispatch({
          effects: this.setHover.of(null),
        });
    }
    destroy() {
      clearTimeout(this.hoverTimeout);
      this.view.dom.removeEventListener("mouseleave", this.mouseleave);
      this.view.dom.removeEventListener("mousemove", this.mousemove);
    }
    constructor(view, source, field, setHover, hoverTime) {
      this.view = view;
      this.source = source;
      this.field = field;
      this.setHover = setHover;
      this.hoverTime = hoverTime;
      this.hoverTimeout = -1;
      this.restartTimeout = -1;
      this.pending = null;
      this.lastMove = {
        x: 0,
        y: 0,
        target: view.dom,
        time: 0,
      };
      this.checkHover = this.checkHover.bind(this);
      view.dom.addEventListener("mouseleave", (this.mouseleave = this.mouseleave.bind(this)));
      view.dom.addEventListener("mousemove", (this.mousemove = this.mousemove.bind(this)));
    }
  };
  __name(HoverPlugin, "HoverPlugin");
  function isInTooltip(elt) {
    for (var cur = elt; cur; cur = cur.parentNode) if (cur.nodeType == 1 && cur.classList.contains("cm-tooltip")) return true;
    return false;
  }
  __name(isInTooltip, "isInTooltip");
  function isOverRange(view, from, to, x, y, margin) {
    var range = document.createRange();
    var fromDOM = view.domAtPos(from),
      toDOM = view.domAtPos(to);
    range.setEnd(toDOM.node, toDOM.offset);
    range.setStart(fromDOM.node, fromDOM.offset);
    var rects = range.getClientRects();
    range.detach();
    for (var i = 0; i < rects.length; i++) {
      var rect = rects[i];
      var dist = Math.max(rect.top - y, y - rect.bottom, rect.left - x, x - rect.right);
      if (dist <= margin) return true;
    }
    return false;
  }
  __name(isOverRange, "isOverRange");
  function hoverTooltip(source) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var setHover = StateEffect.define();
    var hoverState = StateField.define({
      create() {
        return null;
      },
      update(value, tr) {
        if (value && ((options.hideOnChange && (tr.docChanged || tr.selection)) || (options.hideOn && options.hideOn(tr, value)))) return null;
        if (value && tr.docChanged) {
          var newPos = tr.changes.mapPos(value.pos, -1, MapMode.TrackDel);
          if (newPos == null) return null;
          var copy = Object.assign(/* @__PURE__ */ Object.create(null), value);
          copy.pos = newPos;
          if (value.end != null) copy.end = tr.changes.mapPos(value.end);
          value = copy;
        }
        var _iteratorNormalCompletion = true,
          _didIteratorError = false,
          _iteratorError = undefined;
        try {
          for (var _iterator = tr.effects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var effect = _step.value;
            if (effect.is(setHover)) value = effect.value;
            if (effect.is(closeHoverTooltipEffect)) value = null;
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        return value;
      },
      provide: (f) => showHoverTooltip.from(f),
    });
    return [hoverState, ViewPlugin.define((view) => new HoverPlugin(view, source, hoverState, setHover, options.hoverTime || 300)), showHoverTooltipHost];
  }
  __name(hoverTooltip, "hoverTooltip");
  var closeHoverTooltipEffect = /* @__PURE__ */ StateEffect.define();
  var panelConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      var topContainer, bottomContainer;
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = configs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var c = _step.value;
          topContainer = topContainer || c.topContainer;
          bottomContainer = bottomContainer || c.bottomContainer;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return {
        topContainer,
        bottomContainer,
      };
    },
  });
  var panelPlugin = /* @__PURE__ */ ViewPlugin.fromClass(
    class {
      update(update2) {
        var conf = update2.state.facet(panelConfig);
        if (this.top.container != conf.topContainer) {
          this.top.sync([]);
          this.top = new PanelGroup(update2.view, true, conf.topContainer);
        }
        if (this.bottom.container != conf.bottomContainer) {
          this.bottom.sync([]);
          this.bottom = new PanelGroup(update2.view, false, conf.bottomContainer);
        }
        this.top.syncClasses();
        this.bottom.syncClasses();
        var input = update2.state.facet(showPanel);
        if (input != this.input) {
          var specs = input.filter((x) => x);
          var panels = [],
            top2 = [],
            bottom = [],
            mount = [];
          var _iteratorNormalCompletion = true,
            _didIteratorError = false,
            _iteratorError = undefined;
          try {
            for (var _iterator = specs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var spec = _step.value;
              var known = this.specs.indexOf(spec),
                panel = void 0;
              if (known < 0) {
                panel = spec(update2.view);
                mount.push(panel);
              } else {
                panel = this.panels[known];
                if (panel.update) panel.update(update2);
              }
              panels.push(panel);
              (panel.top ? top2 : bottom).push(panel);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
          this.specs = specs;
          this.panels = panels;
          this.top.sync(top2);
          this.bottom.sync(bottom);
          var _iteratorNormalCompletion1 = true,
            _didIteratorError1 = false,
            _iteratorError1 = undefined;
          try {
            for (var _iterator1 = mount[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
              var p = _step1.value;
              p.dom.classList.add("cm-panel");
              if (p.mount) p.mount();
            }
          } catch (err) {
            _didIteratorError1 = true;
            _iteratorError1 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                _iterator1.return();
              }
            } finally {
              if (_didIteratorError1) {
                throw _iteratorError1;
              }
            }
          }
        } else {
          var _iteratorNormalCompletion2 = true,
            _didIteratorError2 = false,
            _iteratorError2 = undefined;
          try {
            for (var _iterator2 = this.panels[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var p1 = _step2.value;
              if (p1.update) p1.update(update2);
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }
      }
      destroy() {
        this.top.sync([]);
        this.bottom.sync([]);
      }
      constructor(view) {
        this.input = view.state.facet(showPanel);
        this.specs = this.input.filter((s) => s);
        this.panels = this.specs.map((spec) => spec(view));
        var conf = view.state.facet(panelConfig);
        this.top = new PanelGroup(view, true, conf.topContainer);
        this.bottom = new PanelGroup(view, false, conf.bottomContainer);
        this.top.sync(this.panels.filter((p) => p.top));
        this.bottom.sync(this.panels.filter((p) => !p.top));
        var _iteratorNormalCompletion = true,
          _didIteratorError = false,
          _iteratorError = undefined;
        try {
          for (var _iterator = this.panels[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var p = _step.value;
            p.dom.classList.add("cm-panel");
            if (p.mount) p.mount();
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
    },
    {
      provide: (plugin) =>
        EditorView.scrollMargins.of((view) => {
          var value = view.plugin(plugin);
          return (
            value && {
              top: value.top.scrollMargin(),
              bottom: value.bottom.scrollMargin(),
            }
          );
        }),
    }
  );
  var PanelGroup = class PanelGroup {
    sync(panels) {
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.panels[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var p = _step.value;
          if (p.destroy && panels.indexOf(p) < 0) p.destroy();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      this.panels = panels;
      this.syncDOM();
    }
    syncDOM() {
      if (this.panels.length == 0) {
        if (this.dom) {
          this.dom.remove();
          this.dom = void 0;
        }
        return;
      }
      if (!this.dom) {
        this.dom = document.createElement("div");
        this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
        this.dom.style[this.top ? "top" : "bottom"] = "0";
        var parent = this.container || this.view.dom;
        parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
      }
      var curDOM = this.dom.firstChild;
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.panels[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var panel = _step.value;
          if (panel.dom.parentNode == this.dom) {
            while (curDOM != panel.dom) curDOM = rm(curDOM);
            curDOM = curDOM.nextSibling;
          } else {
            this.dom.insertBefore(panel.dom, curDOM);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      while (curDOM) curDOM = rm(curDOM);
    }
    scrollMargin() {
      return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
    }
    syncClasses() {
      if (!this.container || this.classes == this.view.themeClasses) return;
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.classes.split(" ")[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var cls = _step.value;
          if (cls) this.container.classList.remove(cls);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      var _iteratorNormalCompletion1 = true,
        _didIteratorError1 = false,
        _iteratorError1 = undefined;
      try {
        for (var _iterator1 = (this.classes = this.view.themeClasses).split(" ")[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
          var cls1 = _step1.value;
          if (cls1) this.container.classList.add(cls1);
        }
      } catch (err) {
        _didIteratorError1 = true;
        _iteratorError1 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
            _iterator1.return();
          }
        } finally {
          if (_didIteratorError1) {
            throw _iteratorError1;
          }
        }
      }
    }
    constructor(view, top2, container) {
      this.view = view;
      this.top = top2;
      this.container = container;
      this.dom = void 0;
      this.classes = "";
      this.panels = [];
      this.syncClasses();
    }
  };
  __name(PanelGroup, "PanelGroup");
  function rm(node) {
    var next = node.nextSibling;
    node.remove();
    return next;
  }
  __name(rm, "rm");
  var showPanel = /* @__PURE__ */ Facet.define({
    enables: panelPlugin,
  });
  var GutterMarker = class GutterMarker extends RangeValue {
    compare(other) {
      return this == other || (this.constructor == other.constructor && this.eq(other));
    }
    eq(other) {
      return false;
    }
    destroy(dom) {}
  };
  __name(GutterMarker, "GutterMarker");
  GutterMarker.prototype.elementClass = "";
  GutterMarker.prototype.toDOM = void 0;
  GutterMarker.prototype.mapMode = MapMode.TrackBefore;
  GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
  GutterMarker.prototype.point = true;
  var gutterLineClass = /* @__PURE__ */ Facet.define();
  var activeGutters = /* @__PURE__ */ Facet.define();
  var unfixGutters = /* @__PURE__ */ Facet.define({
    combine: (values) => values.some((x) => x),
  });
  function gutters(config) {
    var result = [gutterView];
    if (config && config.fixed === false) result.push(unfixGutters.of(true));
    return result;
  }
  __name(gutters, "gutters");
  var gutterView = /* @__PURE__ */ ViewPlugin.fromClass(
    class {
      update(update2) {
        if (this.updateGutters(update2)) {
          var vpA = this.prevViewport,
            vpB = update2.view.viewport;
          var vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
          this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
        }
        if (update2.geometryChanged) this.dom.style.minHeight = this.view.contentHeight + "px";
        if (this.view.state.facet(unfixGutters) != !this.fixed) {
          this.fixed = !this.fixed;
          this.dom.style.position = this.fixed ? "sticky" : "";
        }
        this.prevViewport = update2.view.viewport;
      }
      syncGutters(detach2) {
        var after = this.dom.nextSibling;
        if (detach2) this.dom.remove();
        var lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
        var classSet = [];
        var contexts = this.gutters.map((gutter2) => new UpdateContext(gutter2, this.view.viewport, -this.view.documentPadding.top));
        var _iteratorNormalCompletion = true,
          _didIteratorError = false,
          _iteratorError = undefined;
        try {
          for (var _iterator = this.view.viewportLineBlocks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var line = _step.value;
            var text2 = void 0;
            if (Array.isArray(line.type)) {
              var _iteratorNormalCompletion1 = true,
                _didIteratorError1 = false,
                _iteratorError1 = undefined;
              try {
                for (var _iterator1 = line.type[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
                  var b = _step1.value;
                  if (b.type == BlockType.Text) {
                    text2 = b;
                    break;
                  }
                }
              } catch (err) {
                _didIteratorError1 = true;
                _iteratorError1 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                    _iterator1.return();
                  }
                } finally {
                  if (_didIteratorError1) {
                    throw _iteratorError1;
                  }
                }
              }
            } else {
              text2 = line.type == BlockType.Text ? line : void 0;
            }
            if (!text2) continue;
            if (classSet.length) classSet = [];
            advanceCursor(lineClasses, classSet, line.from);
            var _iteratorNormalCompletion2 = true,
              _didIteratorError2 = false,
              _iteratorError2 = undefined;
            try {
              for (var _iterator2 = contexts[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var cx = _step2.value;
                cx.line(this.view, text2, classSet);
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        var _iteratorNormalCompletion3 = true,
          _didIteratorError3 = false,
          _iteratorError3 = undefined;
        try {
          for (var _iterator3 = contexts[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var cx1 = _step3.value;
            cx1.finish();
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
        if (detach2) this.view.scrollDOM.insertBefore(this.dom, after);
      }
      updateGutters(update2) {
        var prev = update2.startState.facet(activeGutters),
          cur = update2.state.facet(activeGutters);
        var change = update2.docChanged || update2.heightChanged || update2.viewportChanged || !RangeSet.eq(update2.startState.facet(gutterLineClass), update2.state.facet(gutterLineClass), update2.view.viewport.from, update2.view.viewport.to);
        if (prev == cur) {
          var _iteratorNormalCompletion = true,
            _didIteratorError = false,
            _iteratorError = undefined;
          try {
            for (var _iterator = this.gutters[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var gutter2 = _step.value;
              if (gutter2.update(update2)) change = true;
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        } else {
          change = true;
          var gutters2 = [];
          var _iteratorNormalCompletion1 = true,
            _didIteratorError1 = false,
            _iteratorError1 = undefined;
          try {
            for (var _iterator1 = cur[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
              var conf = _step1.value;
              var known = prev.indexOf(conf);
              if (known < 0) {
                gutters2.push(new SingleGutterView(this.view, conf));
              } else {
                this.gutters[known].update(update2);
                gutters2.push(this.gutters[known]);
              }
            }
          } catch (err) {
            _didIteratorError1 = true;
            _iteratorError1 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                _iterator1.return();
              }
            } finally {
              if (_didIteratorError1) {
                throw _iteratorError1;
              }
            }
          }
          var _iteratorNormalCompletion2 = true,
            _didIteratorError2 = false,
            _iteratorError2 = undefined;
          try {
            for (var _iterator2 = this.gutters[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var g = _step2.value;
              g.dom.remove();
              if (gutters2.indexOf(g) < 0) g.destroy();
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
          var _iteratorNormalCompletion3 = true,
            _didIteratorError3 = false,
            _iteratorError3 = undefined;
          try {
            for (var _iterator3 = gutters2[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var g1 = _step3.value;
              this.dom.appendChild(g1.dom);
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
          this.gutters = gutters2;
        }
        return change;
      }
      destroy() {
        var _iteratorNormalCompletion = true,
          _didIteratorError = false,
          _iteratorError = undefined;
        try {
          for (var _iterator = this.gutters[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var view = _step.value;
            view.destroy();
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        this.dom.remove();
      }
      constructor(view) {
        this.view = view;
        this.prevViewport = view.viewport;
        this.dom = document.createElement("div");
        this.dom.className = "cm-gutters";
        this.dom.setAttribute("aria-hidden", "true");
        this.dom.style.minHeight = this.view.contentHeight + "px";
        this.gutters = view.state.facet(activeGutters).map((conf) => new SingleGutterView(view, conf));
        var _iteratorNormalCompletion = true,
          _didIteratorError = false,
          _iteratorError = undefined;
        try {
          for (var _iterator = this.gutters[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var gutter2 = _step.value;
            this.dom.appendChild(gutter2.dom);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        this.fixed = !view.state.facet(unfixGutters);
        if (this.fixed) {
          this.dom.style.position = "sticky";
        }
        this.syncGutters(false);
        view.scrollDOM.insertBefore(this.dom, view.contentDOM);
      }
    },
    {
      provide: (plugin) =>
        EditorView.scrollMargins.of((view) => {
          var value = view.plugin(plugin);
          if (!value || value.gutters.length == 0 || !value.fixed) return null;
          return view.textDirection == Direction.LTR
            ? {
                left: value.dom.offsetWidth,
              }
            : {
                right: value.dom.offsetWidth,
              };
        }),
    }
  );
  function asArray2(val) {
    return Array.isArray(val) ? val : [val];
  }
  __name(asArray2, "asArray");
  function advanceCursor(cursor, collect, pos) {
    while (cursor.value && cursor.from <= pos) {
      if (cursor.from == pos) collect.push(cursor.value);
      cursor.next();
    }
  }
  __name(advanceCursor, "advanceCursor");
  var UpdateContext = class UpdateContext {
    line(view, line, extraMarkers) {
      if (this.localMarkers.length) this.localMarkers = [];
      advanceCursor(this.cursor, this.localMarkers, line.from);
      var localMarkers = extraMarkers.length ? this.localMarkers.concat(extraMarkers) : this.localMarkers;
      var forLine = this.gutter.config.lineMarker(view, line, localMarkers);
      if (forLine) localMarkers.unshift(forLine);
      var gutter2 = this.gutter;
      if (localMarkers.length == 0 && !gutter2.config.renderEmptyElements) return;
      var above = line.top - this.height;
      if (this.i == gutter2.elements.length) {
        var newElt = new GutterElement(view, line.height, above, localMarkers);
        gutter2.elements.push(newElt);
        gutter2.dom.appendChild(newElt.dom);
      } else {
        gutter2.elements[this.i].update(view, line.height, above, localMarkers);
      }
      this.height = line.bottom;
      this.i++;
    }
    finish() {
      var gutter2 = this.gutter;
      while (gutter2.elements.length > this.i) {
        var last = gutter2.elements.pop();
        gutter2.dom.removeChild(last.dom);
        last.destroy();
      }
    }
    constructor(gutter2, viewport, height) {
      this.gutter = gutter2;
      this.height = height;
      this.localMarkers = [];
      this.i = 0;
      this.cursor = RangeSet.iter(gutter2.markers, viewport.from);
    }
  };
  __name(UpdateContext, "UpdateContext");
  var SingleGutterView = class SingleGutterView {
    update(update2) {
      var prevMarkers = this.markers;
      this.markers = asArray2(this.config.markers(update2.view));
      if (this.spacer && this.config.updateSpacer) {
        var updated = this.config.updateSpacer(this.spacer.markers[0], update2);
        if (updated != this.spacer.markers[0]) this.spacer.update(update2.view, 0, 0, [updated]);
      }
      var vp = update2.view.viewport;
      return !RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update2) : false);
    }
    destroy() {
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.elements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var elt = _step.value;
          elt.destroy();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    constructor(view, config) {
      var _this = this,
        _loop = function (prop) {
          _this.dom.addEventListener(prop, (event) => {
            var line = view.lineBlockAtHeight(event.clientY - view.documentTop);
            if (config.domEventHandlers[prop](view, line, event)) event.preventDefault();
          });
        };
      this.view = view;
      this.config = config;
      this.elements = [];
      this.spacer = null;
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
      for (var prop in config.domEventHandlers) _loop(prop);
      this.markers = asArray2(config.markers(view));
      if (config.initialSpacer) {
        this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)]);
        this.dom.appendChild(this.spacer.dom);
        this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
      }
    }
  };
  __name(SingleGutterView, "SingleGutterView");
  var GutterElement = class GutterElement {
    update(view, height, above, markers) {
      if (this.height != height) this.dom.style.height = (this.height = height) + "px";
      if (this.above != above) this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
      if (!sameMarkers(this.markers, markers)) this.setMarkers(view, markers);
    }
    setMarkers(view, markers) {
      var cls = "cm-gutterElement",
        domPos = this.dom.firstChild;
      for (var iNew = 0, iOld = 0; ; ) {
        var skipTo = iOld,
          marker = iNew < markers.length ? markers[iNew++] : null,
          matched = false;
        if (marker) {
          var c = marker.elementClass;
          if (c) cls += " " + c;
          for (var i = iOld; i < this.markers.length; i++)
            if (this.markers[i].compare(marker)) {
              skipTo = i;
              matched = true;
              break;
            }
        } else {
          skipTo = this.markers.length;
        }
        while (iOld < skipTo) {
          var next = this.markers[iOld++];
          if (next.toDOM) {
            next.destroy(domPos);
            var after = domPos.nextSibling;
            domPos.remove();
            domPos = after;
          }
        }
        if (!marker) break;
        if (marker.toDOM) {
          if (matched) domPos = domPos.nextSibling;
          else this.dom.insertBefore(marker.toDOM(view), domPos);
        }
        if (matched) iOld++;
      }
      this.dom.className = cls;
      this.markers = markers;
    }
    destroy() {
      this.setMarkers(null, []);
    }
    constructor(view, height, above, markers) {
      this.height = -1;
      this.above = 0;
      this.markers = [];
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutterElement";
      this.update(view, height, above, markers);
    }
  };
  __name(GutterElement, "GutterElement");
  function sameMarkers(a, b) {
    if (a.length != b.length) return false;
    for (var i = 0; i < a.length; i++) if (!a[i].compare(b[i])) return false;
    return true;
  }
  __name(sameMarkers, "sameMarkers");
  var lineNumberMarkers = /* @__PURE__ */ Facet.define();
  var lineNumberConfig = /* @__PURE__ */ Facet.define({
    combine(values) {
      return combineConfig(
        values,
        {
          formatNumber: String,
          domEventHandlers: {},
        },
        {
          domEventHandlers(a, b) {
            var _loop = function (event) {
              var exists = result[event],
                add2 = b[event];
              result[event] = exists ? (view, line, event2) => exists(view, line, event2) || add2(view, line, event2) : add2;
            };
            var result = Object.assign({}, a);
            for (var event in b) _loop(event);
            return result;
          },
        }
      );
    },
  });
  var NumberMarker = class NumberMarker extends GutterMarker {
    eq(other) {
      return this.number == other.number;
    }
    toDOM() {
      return document.createTextNode(this.number);
    }
    constructor(number2) {
      super();
      this.number = number2;
    }
  };
  __name(NumberMarker, "NumberMarker");
  function formatNumber(view, number2) {
    return view.state.facet(lineNumberConfig).formatNumber(number2, view.state);
  }
  __name(formatNumber, "formatNumber");
  var lineNumberGutter = /* @__PURE__ */ activeGutters.compute([lineNumberConfig], (state) => ({
    class: "cm-lineNumbers",
    renderEmptyElements: false,
    markers(view) {
      return view.state.facet(lineNumberMarkers);
    },
    lineMarker(view, line, others) {
      if (others.some((m) => m.toDOM)) return null;
      return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
    },
    lineMarkerChange: (update2) => update2.startState.facet(lineNumberConfig) != update2.state.facet(lineNumberConfig),
    initialSpacer(view) {
      return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
    },
    updateSpacer(spacer, update2) {
      var max = formatNumber(update2.view, maxLineNumber(update2.view.state.doc.lines));
      return max == spacer.number ? spacer : new NumberMarker(max);
    },
    domEventHandlers: state.facet(lineNumberConfig).domEventHandlers,
  }));
  function lineNumbers() {
    var config = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return [lineNumberConfig.of(config), gutters(), lineNumberGutter];
  }
  __name(lineNumbers, "lineNumbers");
  function maxLineNumber(lines) {
    var last = 9;
    while (last < lines) last = last * 10 + 9;
    return last;
  }
  __name(maxLineNumber, "maxLineNumber");
  var activeLineGutterMarker = /* @__PURE__ */ new (class extends GutterMarker {
    constructor() {
      super(...arguments);
      this.elementClass = "cm-activeLineGutter";
    }
  })();
  var activeLineGutterHighlighter = /* @__PURE__ */ gutterLineClass.compute(["selection"], (state) => {
    var marks = [],
      last = -1;
    var _iteratorNormalCompletion = true,
      _didIteratorError = false,
      _iteratorError = undefined;
    try {
      for (var _iterator = state.selection.ranges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var range = _step.value;
        var linePos = state.doc.lineAt(range.head).from;
        if (linePos > last) {
          last = linePos;
          marks.push(activeLineGutterMarker.range(linePos));
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    return RangeSet.of(marks);
  });
  function highlightActiveLineGutter() {
    return activeLineGutterHighlighter;
  }
  __name(highlightActiveLineGutter, "highlightActiveLineGutter");
  // node_modules/@lezer/common/dist/index.js
  var DefaultBufferLength = 1024;
  var nextPropID = 0;
  var Range2 = class Range2 {
    constructor(from, to) {
      this.from = from;
      this.to = to;
    }
  };
  __name(Range2, "Range");
  var NodeProp = class NodeProp {
    add(match) {
      if (this.perNode) throw new RangeError("Can't add per-node props to node types");
      if (typeof match != "function") match = NodeType.match(match);
      return (type) => {
        var result = match(type);
        return result === void 0 ? null : [this, result];
      };
    }
    constructor(ref) {
      var config = ref === void 0 ? {} : ref;
      this.id = nextPropID++;
      this.perNode = !!config.perNode;
      this.deserialize =
        config.deserialize ||
        (() => {
          throw new Error("This node type doesn't define a deserialize function");
        });
    }
  };
  __name(NodeProp, "NodeProp");
  NodeProp.closedBy = new NodeProp({
    deserialize: (str) => str.split(" "),
  });
  NodeProp.openedBy = new NodeProp({
    deserialize: (str) => str.split(" "),
  });
  NodeProp.group = new NodeProp({
    deserialize: (str) => str.split(" "),
  });
  NodeProp.contextHash = new NodeProp({
    perNode: true,
  });
  NodeProp.lookAhead = new NodeProp({
    perNode: true,
  });
  NodeProp.mounted = new NodeProp({
    perNode: true,
  });
  var noProps = /* @__PURE__ */ Object.create(null);
  var NodeType = class NodeType1 {
    static define(spec) {
      var props = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps;
      var flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
      var type = new NodeType(spec.name || "", props, spec.id, flags);
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      if (spec.props)
        try {
          for (var _iterator = spec.props[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var src = _step.value;
            if (!Array.isArray(src)) src = src(type);
            if (src) {
              if (src[0].perNode) throw new RangeError("Can't store a per-node prop on a node type");
              props[src[0].id] = src[1];
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      return type;
    }
    prop(prop) {
      return this.props[prop.id];
    }
    get isTop() {
      return (this.flags & 1) > 0;
    }
    get isSkipped() {
      return (this.flags & 2) > 0;
    }
    get isError() {
      return (this.flags & 4) > 0;
    }
    get isAnonymous() {
      return (this.flags & 8) > 0;
    }
    is(name2) {
      if (typeof name2 == "string") {
        if (this.name == name2) return true;
        var group = this.prop(NodeProp.group);
        return group ? group.indexOf(name2) > -1 : false;
      }
      return this.id == name2;
    }
    static match(map) {
      var direct = /* @__PURE__ */ Object.create(null);
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      for (var prop in map)
        try {
          for (var _iterator = prop.split(" ")[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var name2 = _step.value;
            direct[name2] = map[prop];
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      return (node) => {
        for (var groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
          var found = direct[i < 0 ? node.name : groups[i]];
          if (found) return found;
        }
      };
    }
    constructor(name2, props, id, ref) {
      var flags = ref === void 0 ? 0 : ref;
      this.name = name2;
      this.props = props;
      this.id = id;
      this.flags = flags;
    }
  };
  __name(NodeType, "NodeType");
  NodeType.none = new NodeType("", /* @__PURE__ */ Object.create(null), 0, 8);
  var NodeSet = class NodeSet1 {
    extend() {
      for (var _len = arguments.length, props = new Array(_len), _key = 0; _key < _len; _key++) {
        props[_key] = arguments[_key];
      }
      var newTypes = [];
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.types[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var type = _step.value;
          var newProps = null;
          var _iteratorNormalCompletion1 = true,
            _didIteratorError1 = false,
            _iteratorError1 = undefined;
          try {
            for (var _iterator1 = props[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
              var source = _step1.value;
              var add2 = source(type);
              if (add2) {
                if (!newProps) newProps = Object.assign({}, type.props);
                newProps[add2[0].id] = add2[1];
              }
            }
          } catch (err) {
            _didIteratorError1 = true;
            _iteratorError1 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                _iterator1.return();
              }
            } finally {
              if (_didIteratorError1) {
                throw _iteratorError1;
              }
            }
          }
          newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return new NodeSet(newTypes);
    }
    constructor(types2) {
      this.types = types2;
      for (var i = 0; i < types2.length; i++) if (types2[i].id != i) throw new RangeError("Node type ids should correspond to array positions when creating a node set");
    }
  };
  __name(NodeSet, "NodeSet");
  var CachedNode = /* @__PURE__ */ new WeakMap();
  var CachedInnerNode = /* @__PURE__ */ new WeakMap();
  var IterMode;
  (function (IterMode2) {
    IterMode2[(IterMode2["ExcludeBuffers"] = 1)] = "ExcludeBuffers";
    IterMode2[(IterMode2["IncludeAnonymous"] = 2)] = "IncludeAnonymous";
    IterMode2[(IterMode2["IgnoreMounts"] = 4)] = "IgnoreMounts";
    IterMode2[(IterMode2["IgnoreOverlays"] = 8)] = "IgnoreOverlays";
  })(IterMode || (IterMode = {}));
  var Tree = class Tree1 {
    toString() {
      var mounted = this.prop(NodeProp.mounted);
      if (mounted && !mounted.overlay) return mounted.tree.toString();
      var children2 = "";
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var ch = _step.value;
          var str = ch.toString();
          if (str) {
            if (children2) children2 += ",";
            children2 += str;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return !this.type.name ? children2 : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children2.length ? "(" + children2 + ")" : "");
    }
    cursor() {
      var mode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return new TreeCursor(this.topNode, mode);
    }
    cursorAt(pos) {
      var side = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
        mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var scope = CachedNode.get(this) || this.topNode;
      var cursor = new TreeCursor(scope);
      cursor.moveTo(pos, side);
      CachedNode.set(this, cursor._tree);
      return cursor;
    }
    get topNode() {
      return new TreeNode(this, 0, 0, null);
    }
    resolve(pos) {
      var side = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
      CachedNode.set(this, node);
      return node;
    }
    resolveInner(pos) {
      var side = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
      CachedInnerNode.set(this, node);
      return node;
    }
    iterate(spec) {
      var enter = spec.enter,
        leave = spec.leave,
        _spec_from = spec.from,
        from = _spec_from === void 0 ? 0 : _spec_from,
        _spec_to = spec.to,
        to = _spec_to === void 0 ? this.length : _spec_to;
      for (var c = this.cursor((spec.mode || 0) | IterMode.IncludeAnonymous); ; ) {
        var entered = false;
        if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c) !== false)) {
          if (c.firstChild()) continue;
          entered = true;
        }
        for (;;) {
          if (entered && leave && !c.type.isAnonymous) leave(c);
          if (c.nextSibling()) break;
          if (!c.parent()) return;
          entered = true;
        }
      }
    }
    prop(prop) {
      return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
    }
    get propValues() {
      var result = [];
      if (this.props) for (var id in this.props) result.push([+id, this.props[id]]);
      return result;
    }
    balance() {
      var config = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children2, positions, length) => new Tree(this.type, children2, positions, length, this.propValues), config.makeTree || ((children2, positions, length) => new Tree(NodeType.none, children2, positions, length)));
    }
    static build(data) {
      return buildTree(data);
    }
    constructor(type, children2, positions, length, props) {
      this.type = type;
      this.children = children2;
      this.positions = positions;
      this.length = length;
      this.props = null;
      if (props && props.length) {
        this.props = /* @__PURE__ */ Object.create(null);
        var _iteratorNormalCompletion = true,
          _didIteratorError = false,
          _iteratorError = undefined;
        try {
          for (var _iterator = props[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step_value = _slicedToArray(_step.value, 2),
              prop = _step_value[0],
              value = _step_value[1];
            this.props[typeof prop == "number" ? prop : prop.id] = value;
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
    }
  };
  __name(Tree, "Tree");
  Tree.empty = new Tree(NodeType.none, [], [], 0);
  var FlatBufferCursor = class FlatBufferCursor1 {
    get id() {
      return this.buffer[this.index - 4];
    }
    get start() {
      return this.buffer[this.index - 3];
    }
    get end() {
      return this.buffer[this.index - 2];
    }
    get size() {
      return this.buffer[this.index - 1];
    }
    get pos() {
      return this.index;
    }
    next() {
      this.index -= 4;
    }
    fork() {
      return new FlatBufferCursor(this.buffer, this.index);
    }
    constructor(buffer, index) {
      this.buffer = buffer;
      this.index = index;
    }
  };
  __name(FlatBufferCursor, "FlatBufferCursor");
  var TreeBuffer = class TreeBuffer1 {
    get type() {
      return NodeType.none;
    }
    toString() {
      var result = [];
      for (var index = 0; index < this.buffer.length; ) {
        result.push(this.childString(index));
        index = this.buffer[index + 3];
      }
      return result.join(",");
    }
    childString(index) {
      var id = this.buffer[index],
        endIndex = this.buffer[index + 3];
      var type = this.set.types[id],
        result = type.name;
      if (/\W/.test(result) && !type.isError) result = JSON.stringify(result);
      index += 4;
      if (endIndex == index) return result;
      var children2 = [];
      while (index < endIndex) {
        children2.push(this.childString(index));
        index = this.buffer[index + 3];
      }
      return result + "(" + children2.join(",") + ")";
    }
    findChild(startIndex, endIndex, dir, pos, side) {
      var buffer = this.buffer,
        pick = -1;
      for (var i = startIndex; i != endIndex; i = buffer[i + 3]) {
        if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
          pick = i;
          if (dir > 0) break;
        }
      }
      return pick;
    }
    slice(startI, endI, from) {
      var b = this.buffer;
      var copy = new Uint16Array(endI - startI),
        len = 0;
      for (var i = startI, j = 0; i < endI; ) {
        copy[j++] = b[i++];
        copy[j++] = b[i++] - from;
        var to = (copy[j++] = b[i++] - from);
        copy[j++] = b[i++] - startI;
        len = Math.max(len, to);
      }
      return new TreeBuffer(copy, len, this.set);
    }
    constructor(buffer, length, set) {
      this.buffer = buffer;
      this.length = length;
      this.set = set;
    }
  };
  __name(TreeBuffer, "TreeBuffer");
  function checkSide(side, pos, from, to) {
    switch (side) {
      case -2:
        return from < pos;
      case -1:
        return to >= pos && from < pos;
      case 0:
        return from < pos && to > pos;
      case 1:
        return from <= pos && to > pos;
      case 2:
        return to > pos;
      case 4:
        return true;
    }
  }
  __name(checkSide, "checkSide");
  function enterUnfinishedNodesBefore(node, pos) {
    var scan = node.childBefore(pos);
    while (scan) {
      var last = scan.lastChild;
      if (!last || last.to != scan.to) break;
      if (last.type.isError && last.from == last.to) {
        node = scan;
        scan = last.prevSibling;
      } else {
        scan = last;
      }
    }
    return node;
  }
  __name(enterUnfinishedNodesBefore, "enterUnfinishedNodesBefore");
  function resolveNode(node, pos, side, overlays) {
    var _a2;
    while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
      var parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
      if (!parent) return node;
      node = parent;
    }
    var mode = overlays ? 0 : IterMode.IgnoreOverlays;
    if (overlays)
      for (var scan = node, parent1 = scan.parent; parent1; scan = parent1, parent1 = scan.parent) {
        if (scan instanceof TreeNode && scan.index < 0 && ((_a2 = parent1.enter(pos, side, mode)) === null || _a2 === void 0 ? void 0 : _a2.from) != scan.from) node = parent1;
      }
    for (;;) {
      var inner = node.enter(pos, side, mode);
      if (!inner) return node;
      node = inner;
    }
  }
  __name(resolveNode, "resolveNode");
  var TreeNode = class TreeNode1 {
    get type() {
      return this._tree.type;
    }
    get name() {
      return this._tree.type.name;
    }
    get to() {
      return this.from + this._tree.length;
    }
    nextChild(i, dir, pos, side) {
      var mode = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
      for (var parent = this; ; ) {
        for (var _parent__tree = parent._tree, children2 = _parent__tree.children, positions = _parent__tree.positions, e = dir > 0 ? children2.length : -1; i != e; i += dir) {
          var next = children2[i],
            start = positions[i] + parent.from;
          if (!checkSide(side, pos, start, start + next.length)) continue;
          if (next instanceof TreeBuffer) {
            if (mode & IterMode.ExcludeBuffers) continue;
            var index = next.findChild(0, next.buffer.length, dir, pos - start, side);
            if (index > -1) return new BufferNode(new BufferContext(parent, next, i, start), null, index);
          } else if (mode & IterMode.IncludeAnonymous || !next.type.isAnonymous || hasChild(next)) {
            var mounted = void 0;
            if (!(mode & IterMode.IgnoreMounts) && next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay) return new TreeNode(mounted.tree, start, i, parent);
            var inner = new TreeNode(next, start, i, parent);
            return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
          }
        }
        if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous) return null;
        if (parent.index >= 0) i = parent.index + dir;
        else i = dir < 0 ? -1 : parent._parent._tree.children.length;
        parent = parent._parent;
        if (!parent) return null;
      }
    }
    get firstChild() {
      return this.nextChild(0, 1, 0, 4);
    }
    get lastChild() {
      return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
    }
    childAfter(pos) {
      return this.nextChild(0, 1, pos, 2);
    }
    childBefore(pos) {
      return this.nextChild(this._tree.children.length - 1, -1, pos, -2);
    }
    enter(pos, side) {
      var mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var mounted;
      if (!(mode & IterMode.IgnoreOverlays) && (mounted = this._tree.prop(NodeProp.mounted)) && mounted.overlay) {
        var rPos = pos - this.from;
        var _iteratorNormalCompletion = true,
          _didIteratorError = false,
          _iteratorError = undefined;
        try {
          for (var _iterator = mounted.overlay[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step_value = _step.value,
              from = _step_value.from,
              to = _step_value.to;
            if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos)) return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
      return this.nextChild(0, 1, pos, side, mode);
    }
    nextSignificantParent() {
      var val = this;
      while (val.type.isAnonymous && val._parent) val = val._parent;
      return val;
    }
    get parent() {
      return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
    }
    get prevSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
    }
    cursor() {
      var mode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return new TreeCursor(this, mode);
    }
    get tree() {
      return this._tree;
    }
    toTree() {
      return this._tree;
    }
    resolve(pos) {
      var side = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      return resolveNode(this, pos, side, false);
    }
    resolveInner(pos) {
      var side = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) {
      return enterUnfinishedNodesBefore(this, pos);
    }
    getChild(type) {
      var before = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,
        after = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      var r = getChildren(this, type, before, after);
      return r.length ? r[0] : null;
    }
    getChildren(type) {
      var before = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,
        after = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      return getChildren(this, type, before, after);
    }
    toString() {
      return this._tree.toString();
    }
    get node() {
      return this;
    }
    matchContext(context) {
      return matchNodeContext(this, context);
    }
    constructor(_tree, from, index, _parent) {
      this._tree = _tree;
      this.from = from;
      this.index = index;
      this._parent = _parent;
    }
  };
  __name(TreeNode, "TreeNode");
  function getChildren(node, type, before, after) {
    var cur = node.cursor(),
      result = [];
    if (!cur.firstChild()) return result;
    if (before != null) {
      while (!cur.type.is(before)) if (!cur.nextSibling()) return result;
    }
    for (;;) {
      if (after != null && cur.type.is(after)) return result;
      if (cur.type.is(type)) result.push(cur.node);
      if (!cur.nextSibling()) return after == null ? result : [];
    }
  }
  __name(getChildren, "getChildren");
  function matchNodeContext(node, context) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : context.length - 1;
    for (var p = node.parent; i >= 0; p = p.parent) {
      if (!p) return false;
      if (!p.type.isAnonymous) {
        if (context[i] && context[i] != p.name) return false;
        i--;
      }
    }
    return true;
  }
  __name(matchNodeContext, "matchNodeContext");
  var BufferContext = class BufferContext {
    constructor(parent, buffer, index, start) {
      this.parent = parent;
      this.buffer = buffer;
      this.index = index;
      this.start = start;
    }
  };
  __name(BufferContext, "BufferContext");
  var BufferNode = class BufferNode1 {
    get name() {
      return this.type.name;
    }
    get from() {
      return this.context.start + this.context.buffer.buffer[this.index + 1];
    }
    get to() {
      return this.context.start + this.context.buffer.buffer[this.index + 2];
    }
    child(dir, pos, side) {
      var buffer = this.context.buffer;
      var index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
      return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get firstChild() {
      return this.child(1, 0, 4);
    }
    get lastChild() {
      return this.child(-1, 0, 4);
    }
    childAfter(pos) {
      return this.child(1, pos, 2);
    }
    childBefore(pos) {
      return this.child(-1, pos, -2);
    }
    enter(pos, side) {
      var mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      if (mode & IterMode.ExcludeBuffers) return null;
      var buffer = this.context.buffer;
      var index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
      return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get parent() {
      return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
      return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4);
    }
    get nextSibling() {
      var buffer = this.context.buffer;
      var after = buffer.buffer[this.index + 3];
      if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length)) return new BufferNode(this.context, this._parent, after);
      return this.externalSibling(1);
    }
    get prevSibling() {
      var buffer = this.context.buffer;
      var parentStart = this._parent ? this._parent.index + 4 : 0;
      if (this.index == parentStart) return this.externalSibling(-1);
      return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4));
    }
    cursor() {
      var mode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return new TreeCursor(this, mode);
    }
    get tree() {
      return null;
    }
    toTree() {
      var children2 = [],
        positions = [];
      var buffer = this.context.buffer;
      var startI = this.index + 4,
        endI = buffer.buffer[this.index + 3];
      if (endI > startI) {
        var from = buffer.buffer[this.index + 1];
        children2.push(buffer.slice(startI, endI, from));
        positions.push(0);
      }
      return new Tree(this.type, children2, positions, this.to - this.from);
    }
    resolve(pos) {
      var side = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      return resolveNode(this, pos, side, false);
    }
    resolveInner(pos) {
      var side = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) {
      return enterUnfinishedNodesBefore(this, pos);
    }
    toString() {
      return this.context.buffer.childString(this.index);
    }
    getChild(type) {
      var before = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,
        after = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      var r = getChildren(this, type, before, after);
      return r.length ? r[0] : null;
    }
    getChildren(type) {
      var before = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,
        after = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      return getChildren(this, type, before, after);
    }
    get node() {
      return this;
    }
    matchContext(context) {
      return matchNodeContext(this, context);
    }
    constructor(context, _parent, index) {
      this.context = context;
      this._parent = _parent;
      this.index = index;
      this.type = context.buffer.set.types[context.buffer.buffer[index]];
    }
  };
  __name(BufferNode, "BufferNode");
  var TreeCursor = class TreeCursor {
    get name() {
      return this.type.name;
    }
    yieldNode(node) {
      if (!node) return false;
      this._tree = node;
      this.type = node.type;
      this.from = node.from;
      this.to = node.to;
      return true;
    }
    yieldBuf(index, type) {
      this.index = index;
      var _this_buffer = this.buffer,
        start = _this_buffer.start,
        buffer = _this_buffer.buffer;
      this.type = type || buffer.set.types[buffer.buffer[index]];
      this.from = start + buffer.buffer[index + 1];
      this.to = start + buffer.buffer[index + 2];
      return true;
    }
    yield(node) {
      if (!node) return false;
      if (node instanceof TreeNode) {
        this.buffer = null;
        return this.yieldNode(node);
      }
      this.buffer = node.context;
      return this.yieldBuf(node.index, node.type);
    }
    toString() {
      return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    enterChild(dir, pos, side) {
      if (!this.buffer) return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
      var buffer = this.buffer.buffer;
      var index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
      if (index < 0) return false;
      this.stack.push(this.index);
      return this.yieldBuf(index);
    }
    firstChild() {
      return this.enterChild(1, 0, 4);
    }
    lastChild() {
      return this.enterChild(-1, 0, 4);
    }
    childAfter(pos) {
      return this.enterChild(1, pos, 2);
    }
    childBefore(pos) {
      return this.enterChild(-1, pos, -2);
    }
    enter(pos, side) {
      var mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.mode;
      if (!this.buffer) return this.yield(this._tree.enter(pos, side, mode));
      return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
    }
    parent() {
      if (!this.buffer) return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
      if (this.stack.length) return this.yieldBuf(this.stack.pop());
      var parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
      this.buffer = null;
      return this.yieldNode(parent);
    }
    sibling(dir) {
      if (!this.buffer) return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
      var buffer = this.buffer.buffer,
        d = this.stack.length - 1;
      if (dir < 0) {
        var parentStart = d < 0 ? 0 : this.stack[d] + 4;
        if (this.index != parentStart) return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4));
      } else {
        var after = buffer.buffer[this.index + 3];
        if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3])) return this.yieldBuf(after);
      }
      return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
    }
    nextSibling() {
      return this.sibling(1);
    }
    prevSibling() {
      return this.sibling(-1);
    }
    atLastNode(dir) {
      var index,
        parent,
        buffer = this.buffer;
      if (buffer) {
        if (dir > 0) {
          if (this.index < buffer.buffer.buffer.length) return false;
        } else {
          for (var i = 0; i < this.index; i++) if (buffer.buffer.buffer[i + 3] < this.index) return false;
        }
        var ref;
        (ref = buffer), (index = ref.index), (parent = ref.parent), ref;
      } else {
        var ref1;
        (ref1 = this._tree), (index = ref1.index), (parent = ref1._parent), ref1;
      }
      var ref2;
      for (; parent; ref2 = parent, index = ref2.index, parent = ref2._parent, ref2) {
        if (index > -1)
          for (var i1 = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i1 != e; i1 += dir) {
            var child = parent._tree.children[i1];
            if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child)) return false;
          }
      }
      return true;
    }
    move(dir, enter) {
      if (enter && this.enterChild(dir, 0, 4)) return true;
      for (;;) {
        if (this.sibling(dir)) return true;
        if (this.atLastNode(dir) || !this.parent()) return false;
      }
    }
    next() {
      var enter = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      return this.move(1, enter);
    }
    prev() {
      var enter = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      return this.move(-1, enter);
    }
    moveTo(pos) {
      var side = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos)) if (!this.parent()) break;
      while (this.enterChild(1, pos, side)) {}
      return this;
    }
    get node() {
      if (!this.buffer) return this._tree;
      var cache = this.bufferNode,
        result = null,
        depth = 0;
      if (cache && cache.context == this.buffer) {
        scan: for (var index = this.index, d = this.stack.length; d >= 0; ) {
          for (var c = cache; c; c = c._parent)
            if (c.index == index) {
              if (index == this.index) return c;
              result = c;
              depth = d + 1;
              break scan;
            }
          index = this.stack[--d];
        }
      }
      for (var i = depth; i < this.stack.length; i++) result = new BufferNode(this.buffer, result, this.stack[i]);
      return (this.bufferNode = new BufferNode(this.buffer, result, this.index));
    }
    get tree() {
      return this.buffer ? null : this._tree._tree;
    }
    iterate(enter, leave) {
      for (var depth = 0; ; ) {
        var mustLeave = false;
        if (this.type.isAnonymous || enter(this) !== false) {
          if (this.firstChild()) {
            depth++;
            continue;
          }
          if (!this.type.isAnonymous) mustLeave = true;
        }
        for (;;) {
          if (mustLeave && leave) leave(this);
          mustLeave = this.type.isAnonymous;
          if (this.nextSibling()) break;
          if (!depth) return;
          this.parent();
          depth--;
          mustLeave = true;
        }
      }
    }
    matchContext(context) {
      if (!this.buffer) return matchNodeContext(this.node, context);
      var buffer = this.buffer.buffer,
        _buffer_set = buffer.set,
        types2 = _buffer_set.types;
      for (var i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {
        if (d < 0) return matchNodeContext(this.node, context, i);
        var type = types2[buffer.buffer[this.stack[d]]];
        if (!type.isAnonymous) {
          if (context[i] && context[i] != type.name) return false;
          i--;
        }
      }
      return true;
    }
    constructor(node, ref) {
      var mode = ref === void 0 ? 0 : ref;
      this.mode = mode;
      this.buffer = null;
      this.stack = [];
      this.index = 0;
      this.bufferNode = null;
      if (node instanceof TreeNode) {
        this.yieldNode(node);
      } else {
        this._tree = node.context.parent;
        this.buffer = node.context;
        for (var n = node._parent; n; n = n._parent) this.stack.unshift(n.index);
        this.bufferNode = node;
        this.yieldBuf(node.index);
      }
    }
  };
  __name(TreeCursor, "TreeCursor");
  function hasChild(tree) {
    return tree.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
  }
  __name(hasChild, "hasChild");
  function buildTree(data) {
    var _a2;
    var buffer = data.buffer,
      nodeSet = data.nodeSet,
      _data_maxBufferLength = data.maxBufferLength,
      maxBufferLength = _data_maxBufferLength === void 0 ? DefaultBufferLength : _data_maxBufferLength,
      _data_reused = data.reused,
      reused = _data_reused === void 0 ? [] : _data_reused,
      _data_minRepeatType = data.minRepeatType,
      minRepeatType = _data_minRepeatType === void 0 ? nodeSet.types.length : _data_minRepeatType;
    var cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    var types2 = nodeSet.types;
    var contextHash = 0,
      lookAhead = 0;
    function takeNode(parentStart, minPos, children3, positions2, inRepeat) {
      var id = cursor.id,
        start = cursor.start,
        end = cursor.end,
        size = cursor.size;
      var lookAheadAtStart = lookAhead;
      while (size < 0) {
        cursor.next();
        if (size == -1) {
          var node2 = reused[id];
          children3.push(node2);
          positions2.push(start - parentStart);
          return;
        } else if (size == -3) {
          contextHash = id;
          return;
        } else if (size == -4) {
          lookAhead = id;
          return;
        } else {
          throw new RangeError("Unrecognized record size: ".concat(size));
        }
      }
      var type = types2[id],
        node,
        buffer2;
      var startPos = start - parentStart;
      if (end - start <= maxBufferLength && (buffer2 = findBufferSize(cursor.pos - minPos, inRepeat))) {
        var data2 = new Uint16Array(buffer2.size - buffer2.skip);
        var endPos = cursor.pos - buffer2.size,
          index = data2.length;
        while (cursor.pos > endPos) index = copyToBuffer(buffer2.start, data2, index);
        node = new TreeBuffer(data2, end - buffer2.start, nodeSet);
        startPos = buffer2.start - parentStart;
      } else {
        var endPos1 = cursor.pos - size;
        cursor.next();
        var localChildren = [],
          localPositions = [];
        var localInRepeat = id >= minRepeatType ? id : -1;
        var lastGroup = 0,
          lastEnd = end;
        while (cursor.pos > endPos1) {
          if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
            if (cursor.end <= lastEnd - maxBufferLength) {
              makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
              lastGroup = localChildren.length;
              lastEnd = cursor.end;
            }
            cursor.next();
          } else {
            takeNode(start, endPos1, localChildren, localPositions, localInRepeat);
          }
        }
        if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length) makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);
        localChildren.reverse();
        localPositions.reverse();
        if (localInRepeat > -1 && lastGroup > 0) {
          var make = makeBalanced(type);
          node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
        } else {
          node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);
        }
      }
      children3.push(node);
      positions2.push(startPos);
    }
    __name(takeNode, "takeNode");
    function makeBalanced(type) {
      return (children3, positions2, length2) => {
        var lookAhead2 = 0,
          lastI = children3.length - 1,
          last,
          lookAheadProp;
        if (lastI >= 0 && (last = children3[lastI]) instanceof Tree) {
          if (!lastI && last.type == type && last.length == length2) return last;
          if ((lookAheadProp = last.prop(NodeProp.lookAhead))) lookAhead2 = positions2[lastI] + last.length + lookAheadProp;
        }
        return makeTree(type, children3, positions2, length2, lookAhead2);
      };
    }
    __name(makeBalanced, "makeBalanced");
    function makeRepeatLeaf(children3, positions2, base2, i, from, to, type, lookAhead2) {
      var localChildren = [],
        localPositions = [];
      while (children3.length > i) {
        localChildren.push(children3.pop());
        localPositions.push(positions2.pop() + base2 - from);
      }
      children3.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead2 - to));
      positions2.push(from - base2);
    }
    __name(makeRepeatLeaf, "makeRepeatLeaf");
    function makeTree(type, children3, positions2, length2) {
      var lookAhead2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0,
        props = arguments.length > 5 ? arguments[5] : void 0;
      if (contextHash) {
        var pair2 = [NodeProp.contextHash, contextHash];
        props = props ? [pair2].concat(props) : [pair2];
      }
      if (lookAhead2 > 25) {
        var pair21 = [NodeProp.lookAhead, lookAhead2];
        props = props ? [pair21].concat(props) : [pair21];
      }
      return new Tree(type, children3, positions2, length2, props);
    }
    __name(makeTree, "makeTree");
    function findBufferSize(maxSize, inRepeat) {
      var fork = cursor.fork();
      var size = 0,
        start = 0,
        skip = 0,
        minStart = fork.end - maxBufferLength;
      var result = {
        size: 0,
        start: 0,
        skip: 0,
      };
      scan: for (var minPos = fork.pos - maxSize; fork.pos > minPos; ) {
        var nodeSize2 = fork.size;
        if (fork.id == inRepeat && nodeSize2 >= 0) {
          result.size = size;
          result.start = start;
          result.skip = skip;
          skip += 4;
          size += 4;
          fork.next();
          continue;
        }
        var startPos = fork.pos - nodeSize2;
        if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart) break;
        var localSkipped = fork.id >= minRepeatType ? 4 : 0;
        var nodeStart = fork.start;
        fork.next();
        while (fork.pos > startPos) {
          if (fork.size < 0) {
            if (fork.size == -3) localSkipped += 4;
            else break scan;
          } else if (fork.id >= minRepeatType) {
            localSkipped += 4;
          }
          fork.next();
        }
        start = nodeStart;
        size += nodeSize2;
        skip += localSkipped;
      }
      if (inRepeat < 0 || size == maxSize) {
        result.size = size;
        result.start = start;
        result.skip = skip;
      }
      return result.size > 4 ? result : void 0;
    }
    __name(findBufferSize, "findBufferSize");
    function copyToBuffer(bufferStart, buffer2, index) {
      var id = cursor.id,
        start = cursor.start,
        end = cursor.end,
        size = cursor.size;
      cursor.next();
      if (size >= 0 && id < minRepeatType) {
        var startIndex = index;
        if (size > 4) {
          var endPos = cursor.pos - (size - 4);
          while (cursor.pos > endPos) index = copyToBuffer(bufferStart, buffer2, index);
        }
        buffer2[--index] = startIndex;
        buffer2[--index] = end - bufferStart;
        buffer2[--index] = start - bufferStart;
        buffer2[--index] = id;
      } else if (size == -3) {
        contextHash = id;
      } else if (size == -4) {
        lookAhead = id;
      }
      return index;
    }
    __name(copyToBuffer, "copyToBuffer");
    var children2 = [],
      positions = [];
    while (cursor.pos > 0) takeNode(data.start || 0, data.bufferStart || 0, children2, positions, -1);
    var length = (_a2 = data.length) !== null && _a2 !== void 0 ? _a2 : children2.length ? positions[0] + children2[0].length : 0;
    return new Tree(types2[data.topID], children2.reverse(), positions.reverse(), length);
  }
  __name(buildTree, "buildTree");
  var nodeSizeCache = /* @__PURE__ */ new WeakMap();
  function nodeSize(balanceType, node) {
    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType) return 1;
    var size = nodeSizeCache.get(node);
    if (size == null) {
      size = 1;
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = node.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var child = _step.value;
          if (child.type != balanceType || !(child instanceof Tree)) {
            size = 1;
            break;
          }
          size += nodeSize(balanceType, child);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      nodeSizeCache.set(node, size);
    }
    return size;
  }
  __name(nodeSize, "nodeSize");
  function balanceRange(balanceType, children2, positions, from, to, start, length, mkTop, mkTree) {
    var total = 0;
    for (var i = from; i < to; i++) total += nodeSize(balanceType, children2[i]);
    var maxChild = Math.ceil((total * 1.5) / 8);
    var localChildren = [],
      localPositions = [];
    function divide(children3, positions2, from2, to2, offset) {
      for (var i = from2; i < to2; ) {
        var groupFrom = i,
          groupStart = positions2[i],
          groupSize = nodeSize(balanceType, children3[i]);
        i++;
        for (; i < to2; i++) {
          var nextSize = nodeSize(balanceType, children3[i]);
          if (groupSize + nextSize >= maxChild) break;
          groupSize += nextSize;
        }
        if (i == groupFrom + 1) {
          if (groupSize > maxChild) {
            var only = children3[groupFrom];
            divide(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset);
            continue;
          }
          localChildren.push(children3[groupFrom]);
        } else {
          var length2 = positions2[i - 1] + children3[i - 1].length - groupStart;
          localChildren.push(balanceRange(balanceType, children3, positions2, groupFrom, i, groupStart, length2, null, mkTree));
        }
        localPositions.push(groupStart + offset - start);
      }
    }
    __name(divide, "divide");
    divide(children2, positions, from, to, 0);
    return (mkTop || mkTree)(localChildren, localPositions, length);
  }
  __name(balanceRange, "balanceRange");
  var TreeFragment = class TreeFragment1 {
    get openStart() {
      return (this.open & 1) > 0;
    }
    get openEnd() {
      return (this.open & 2) > 0;
    }
    static addTree(tree) {
      var fragments = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],
        partial = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = fragments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var f = _step.value;
          if (f.to > tree.length) result.push(f);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return result;
    }
    static applyChanges(fragments, changes) {
      var minGap = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 128;
      if (!changes.length) return fragments;
      var result = [];
      var fI = 1,
        nextF = fragments.length ? fragments[0] : null;
      for (var cI = 0, pos = 0, off = 0; ; cI++) {
        var nextC = cI < changes.length ? changes[cI] : null;
        var nextPos = nextC ? nextC.fromA : 1e9;
        if (nextPos - pos >= minGap)
          while (nextF && nextF.from < nextPos) {
            var cut = nextF;
            if (pos >= cut.from || nextPos <= cut.to || off) {
              var fFrom = Math.max(cut.from, pos) - off,
                fTo = Math.min(cut.to, nextPos) - off;
              cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
            }
            if (cut) result.push(cut);
            if (nextF.to > nextPos) break;
            nextF = fI < fragments.length ? fragments[fI++] : null;
          }
        if (!nextC) break;
        pos = nextC.toA;
        off = nextC.toA - nextC.toB;
      }
      return result;
    }
    constructor(from, to, tree, offset, ref, ref1) {
      var openStart = ref === void 0 ? false : ref,
        openEnd = ref1 === void 0 ? false : ref1;
      this.from = from;
      this.to = to;
      this.tree = tree;
      this.offset = offset;
      this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
    }
  };
  __name(TreeFragment, "TreeFragment");
  var Parser = class Parser {
    startParse(input, fragments, ranges) {
      if (typeof input == "string") input = new StringInput(input);
      ranges = !ranges ? [new Range2(0, input.length)] : ranges.length ? ranges.map((r) => new Range2(r.from, r.to)) : [new Range2(0, 0)];
      return this.createParse(input, fragments || [], ranges);
    }
    parse(input, fragments, ranges) {
      var parse = this.startParse(input, fragments, ranges);
      for (;;) {
        var done = parse.advance();
        if (done) return done;
      }
    }
  };
  __name(Parser, "Parser");
  var StringInput = class StringInput {
    get length() {
      return this.string.length;
    }
    chunk(from) {
      return this.string.slice(from);
    }
    get lineChunks() {
      return false;
    }
    read(from, to) {
      return this.string.slice(from, to);
    }
    constructor(string2) {
      this.string = string2;
    }
  };
  __name(StringInput, "StringInput");
  var stoppedInner = new NodeProp({
    perNode: true,
  });
  // node_modules/@lezer/highlight/dist/index.js
  var nextTagID = 0;
  var Tag = class Tag1 {
    static define(parent) {
      if (parent === null || parent === void 0 ? void 0 : parent.base) throw new Error("Can not derive from a modified tag");
      var tag = new Tag([], null, []);
      tag.set.push(tag);
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      if (parent)
        try {
          for (var _iterator = parent.set[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var t2 = _step.value;
            tag.set.push(t2);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      return tag;
    }
    static defineModifier() {
      var mod = new Modifier();
      return (tag) => {
        if (tag.modified.indexOf(mod) > -1) return tag;
        return Modifier.get(
          tag.base || tag,
          tag.modified.concat(mod).sort((a, b) => a.id - b.id)
        );
      };
    }
    constructor(set, base2, modified) {
      this.set = set;
      this.base = base2;
      this.modified = modified;
      this.id = nextTagID++;
    }
  };
  __name(Tag, "Tag");
  var nextModifierID = 0;
  var Modifier = class Modifier1 {
    static get(base2, mods) {
      if (!mods.length) return base2;
      var exists = mods[0].instances.find((t2) => t2.base == base2 && sameArray2(mods, t2.modified));
      if (exists) return exists;
      var set = [],
        tag = new Tag(set, base2, mods);
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = mods[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var m = _step.value;
          m.instances.push(tag);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      var configs = powerSet(mods);
      var _iteratorNormalCompletion1 = true,
        _didIteratorError1 = false,
        _iteratorError1 = undefined,
        _iteratorNormalCompletion2 = true,
        _didIteratorError2 = false,
        _iteratorError2 = undefined;
      try {
        for (var _iterator1 = base2.set[Symbol.iterator](), _step1; !(_iteratorNormalCompletion2 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion2 = true) {
          var parent = _step1.value;
          if (!parent.modified.length)
            try {
              for (var _iterator2 = configs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion1 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion1 = true) {
                var config = _step2.value;
                set.push(Modifier.get(parent, config));
              }
            } catch (err) {
              _didIteratorError1 = true;
              _iteratorError1 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion1 && _iterator2.return != null) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError1) {
                  throw _iteratorError1;
                }
              }
            }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator1.return != null) {
            _iterator1.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
      return tag;
    }
    constructor() {
      this.instances = [];
      this.id = nextModifierID++;
    }
  };
  __name(Modifier, "Modifier");
  function sameArray2(a, b) {
    return a.length == b.length && a.every((x, i) => x == b[i]);
  }
  __name(sameArray2, "sameArray");
  function powerSet(array) {
    var sets = [[]];
    for (var i = 0; i < array.length; i++) {
      for (var j = 0, e = sets.length; j < e; j++) {
        sets.push(sets[j].concat(array[i]));
      }
    }
    return sets.sort((a, b) => b.length - a.length);
  }
  __name(powerSet, "powerSet");
  function styleTags(spec) {
    var byName = /* @__PURE__ */ Object.create(null);
    for (var prop in spec) {
      var tags2 = spec[prop];
      if (!Array.isArray(tags2)) tags2 = [tags2];
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = prop.split(" ")[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var part = _step.value;
          if (part) {
            var pieces = [],
              mode = 2,
              rest = part;
            for (var pos = 0; ; ) {
              if (rest == "..." && pos > 0 && pos + 3 == part.length) {
                mode = 1;
                break;
              }
              var m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
              if (!m) throw new RangeError("Invalid path: " + part);
              pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
              pos += m[0].length;
              if (pos == part.length) break;
              var next = part[pos++];
              if (pos == part.length && next == "!") {
                mode = 0;
                break;
              }
              if (next != "/") throw new RangeError("Invalid path: " + part);
              rest = part.slice(pos);
            }
            var last = pieces.length - 1,
              inner = pieces[last];
            if (!inner) throw new RangeError("Invalid path: " + part);
            var rule = new Rule(tags2, mode, last > 0 ? pieces.slice(0, last) : null);
            byName[inner] = rule.sort(byName[inner]);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    return ruleNodeProp.add(byName);
  }
  __name(styleTags, "styleTags");
  var ruleNodeProp = new NodeProp();
  var Rule = class Rule {
    get opaque() {
      return this.mode == 0;
    }
    get inherit() {
      return this.mode == 1;
    }
    sort(other) {
      if (!other || other.depth < this.depth) {
        this.next = other;
        return this;
      }
      other.next = this.sort(other.next);
      return other;
    }
    get depth() {
      return this.context ? this.context.length : 0;
    }
    constructor(tags2, mode, context, next) {
      this.tags = tags2;
      this.mode = mode;
      this.context = context;
      this.next = next;
    }
  };
  __name(Rule, "Rule");
  Rule.empty = new Rule([], 2, null);
  function tagHighlighter(tags2, options) {
    var map = /* @__PURE__ */ Object.create(null);
    var _iteratorNormalCompletion = true,
      _didIteratorError = false,
      _iteratorError = undefined;
    try {
      for (var _iterator = tags2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var style = _step.value;
        var _iteratorNormalCompletion1 = true,
          _didIteratorError1 = false,
          _iteratorError1 = undefined;
        if (!Array.isArray(style.tag)) map[style.tag.id] = style.class;
        else
          try {
            for (var _iterator1 = style.tag[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
              var tag = _step1.value;
              map[tag.id] = style.class;
            }
          } catch (err) {
            _didIteratorError1 = true;
            _iteratorError1 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                _iterator1.return();
              }
            } finally {
              if (_didIteratorError1) {
                throw _iteratorError1;
              }
            }
          }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    var _ref = options || {},
      scope = _ref.scope,
      _ref_all = _ref.all,
      all = _ref_all === void 0 ? null : _ref_all;
    return {
      style: (tags3) => {
        var cls = all;
        var _iteratorNormalCompletion = true,
          _didIteratorError = false,
          _iteratorError = undefined;
        try {
          for (var _iterator = tags3[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var tag = _step.value;
            var _iteratorNormalCompletion1 = true,
              _didIteratorError1 = false,
              _iteratorError1 = undefined;
            try {
              for (var _iterator1 = tag.set[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
                var sub = _step1.value;
                var tagClass = map[sub.id];
                if (tagClass) {
                  cls = cls ? cls + " " + tagClass : tagClass;
                  break;
                }
              }
            } catch (err) {
              _didIteratorError1 = true;
              _iteratorError1 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                  _iterator1.return();
                }
              } finally {
                if (_didIteratorError1) {
                  throw _iteratorError1;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        return cls;
      },
      scope,
    };
  }
  __name(tagHighlighter, "tagHighlighter");
  function highlightTags(highlighters, tags2) {
    var result = null;
    var _iteratorNormalCompletion = true,
      _didIteratorError = false,
      _iteratorError = undefined;
    try {
      for (var _iterator = highlighters[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var highlighter = _step.value;
        var value = highlighter.style(tags2);
        if (value) result = result ? result + " " + value : value;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    return result;
  }
  __name(highlightTags, "highlightTags");
  function highlightTree(tree, highlighter, putStyle) {
    var from = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0,
      to = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : tree.length;
    var builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
    builder.highlightRange(tree.cursor(), from, to, "", builder.highlighters);
    builder.flush(to);
  }
  __name(highlightTree, "highlightTree");
  var HighlightBuilder = class HighlightBuilder {
    startSpan(at, cls) {
      if (cls != this.class) {
        this.flush(at);
        if (at > this.at) this.at = at;
        this.class = cls;
      }
    }
    flush(to) {
      if (to > this.at && this.class) this.span(this.at, to, this.class);
    }
    highlightRange(cursor, from, to, inheritedClass, highlighters) {
      var type = cursor.type,
        start = cursor.from,
        end = cursor.to;
      if (start >= to || end <= from) return;
      if (type.isTop) highlighters = this.highlighters.filter((h) => !h.scope || h.scope(type));
      var cls = inheritedClass;
      var rule = getStyleTags(cursor) || Rule.empty;
      var tagCls = highlightTags(highlighters, rule.tags);
      if (tagCls) {
        if (cls) cls += " ";
        cls += tagCls;
        if (rule.mode == 1) inheritedClass += (inheritedClass ? " " : "") + tagCls;
      }
      this.startSpan(cursor.from, cls);
      if (rule.opaque) return;
      var mounted = cursor.tree && cursor.tree.prop(NodeProp.mounted);
      if (mounted && mounted.overlay) {
        var inner = cursor.node.enter(mounted.overlay[0].from + start, 1);
        var innerHighlighters = this.highlighters.filter((h) => !h.scope || h.scope(mounted.tree.type));
        var hasChild2 = cursor.firstChild();
        for (var i = 0, pos = start; ; i++) {
          var next = i < mounted.overlay.length ? mounted.overlay[i] : null;
          var nextPos = next ? next.from + start : end;
          var rangeFrom = Math.max(from, pos),
            rangeTo = Math.min(to, nextPos);
          if (rangeFrom < rangeTo && hasChild2) {
            while (cursor.from < rangeTo) {
              this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);
              this.startSpan(Math.min(rangeTo, cursor.to), cls);
              if (cursor.to >= nextPos || !cursor.nextSibling()) break;
            }
          }
          if (!next || nextPos > to) break;
          pos = next.to + start;
          if (pos > from) {
            this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), inheritedClass, innerHighlighters);
            this.startSpan(pos, cls);
          }
        }
        if (hasChild2) cursor.parent();
      } else if (cursor.firstChild()) {
        do {
          if (cursor.to <= from) continue;
          if (cursor.from >= to) break;
          this.highlightRange(cursor, from, to, inheritedClass, highlighters);
          this.startSpan(Math.min(to, cursor.to), cls);
        } while (cursor.nextSibling());
        cursor.parent();
      }
    }
    constructor(at, highlighters, span) {
      this.at = at;
      this.highlighters = highlighters;
      this.span = span;
      this.class = "";
    }
  };
  __name(HighlightBuilder, "HighlightBuilder");
  function getStyleTags(node) {
    var rule = node.type.prop(ruleNodeProp);
    while (rule && rule.context && !node.matchContext(rule.context)) rule = rule.next;
    return rule || null;
  }
  __name(getStyleTags, "getStyleTags");
  var t = Tag.define;
  var comment = t();
  var name = t();
  var typeName = t(name);
  var propertyName = t(name);
  var literal = t();
  var string = t(literal);
  var number = t(literal);
  var content = t();
  var heading = t(content);
  var keyword = t();
  var operator = t();
  var punctuation = t();
  var bracket = t(punctuation);
  var meta = t();
  var tags = {
    comment,
    lineComment: t(comment),
    blockComment: t(comment),
    docComment: t(comment),
    name,
    variableName: t(name),
    typeName,
    tagName: t(typeName),
    propertyName,
    attributeName: t(propertyName),
    className: t(name),
    labelName: t(name),
    namespace: t(name),
    macroName: t(name),
    literal,
    string,
    docString: t(string),
    character: t(string),
    attributeValue: t(string),
    number,
    integer: t(number),
    float: t(number),
    bool: t(literal),
    regexp: t(literal),
    escape: t(literal),
    color: t(literal),
    url: t(literal),
    keyword,
    self: t(keyword),
    null: t(keyword),
    atom: t(keyword),
    unit: t(keyword),
    modifier: t(keyword),
    operatorKeyword: t(keyword),
    controlKeyword: t(keyword),
    definitionKeyword: t(keyword),
    moduleKeyword: t(keyword),
    operator,
    derefOperator: t(operator),
    arithmeticOperator: t(operator),
    logicOperator: t(operator),
    bitwiseOperator: t(operator),
    compareOperator: t(operator),
    updateOperator: t(operator),
    definitionOperator: t(operator),
    typeOperator: t(operator),
    controlOperator: t(operator),
    punctuation,
    separator: t(punctuation),
    bracket,
    angleBracket: t(bracket),
    squareBracket: t(bracket),
    paren: t(bracket),
    brace: t(bracket),
    content,
    heading,
    heading1: t(heading),
    heading2: t(heading),
    heading3: t(heading),
    heading4: t(heading),
    heading5: t(heading),
    heading6: t(heading),
    contentSeparator: t(content),
    list: t(content),
    quote: t(content),
    emphasis: t(content),
    strong: t(content),
    link: t(content),
    monospace: t(content),
    strikethrough: t(content),
    inserted: t(),
    deleted: t(),
    changed: t(),
    invalid: t(),
    meta,
    documentMeta: t(meta),
    annotation: t(meta),
    processingInstruction: t(meta),
    definition: Tag.defineModifier(),
    constant: Tag.defineModifier(),
    function: Tag.defineModifier(),
    standard: Tag.defineModifier(),
    local: Tag.defineModifier(),
    special: Tag.defineModifier(),
  };
  var classHighlighter = tagHighlighter([
    {
      tag: tags.link,
      class: "tok-link",
    },
    {
      tag: tags.heading,
      class: "tok-heading",
    },
    {
      tag: tags.emphasis,
      class: "tok-emphasis",
    },
    {
      tag: tags.strong,
      class: "tok-strong",
    },
    {
      tag: tags.keyword,
      class: "tok-keyword",
    },
    {
      tag: tags.atom,
      class: "tok-atom",
    },
    {
      tag: tags.bool,
      class: "tok-bool",
    },
    {
      tag: tags.url,
      class: "tok-url",
    },
    {
      tag: tags.labelName,
      class: "tok-labelName",
    },
    {
      tag: tags.inserted,
      class: "tok-inserted",
    },
    {
      tag: tags.deleted,
      class: "tok-deleted",
    },
    {
      tag: tags.literal,
      class: "tok-literal",
    },
    {
      tag: tags.string,
      class: "tok-string",
    },
    {
      tag: tags.number,
      class: "tok-number",
    },
    {
      tag: [tags.regexp, tags.escape, tags.special(tags.string)],
      class: "tok-string2",
    },
    {
      tag: tags.variableName,
      class: "tok-variableName",
    },
    {
      tag: tags.local(tags.variableName),
      class: "tok-variableName tok-local",
    },
    {
      tag: tags.definition(tags.variableName),
      class: "tok-variableName tok-definition",
    },
    {
      tag: tags.special(tags.variableName),
      class: "tok-variableName2",
    },
    {
      tag: tags.definition(tags.propertyName),
      class: "tok-propertyName tok-definition",
    },
    {
      tag: tags.typeName,
      class: "tok-typeName",
    },
    {
      tag: tags.namespace,
      class: "tok-namespace",
    },
    {
      tag: tags.className,
      class: "tok-className",
    },
    {
      tag: tags.macroName,
      class: "tok-macroName",
    },
    {
      tag: tags.propertyName,
      class: "tok-propertyName",
    },
    {
      tag: tags.operator,
      class: "tok-operator",
    },
    {
      tag: tags.comment,
      class: "tok-comment",
    },
    {
      tag: tags.meta,
      class: "tok-meta",
    },
    {
      tag: tags.invalid,
      class: "tok-invalid",
    },
    {
      tag: tags.punctuation,
      class: "tok-punctuation",
    },
  ]);
  // node_modules/@codemirror/language/dist/index.js
  var _a;
  var languageDataProp = /* @__PURE__ */ new NodeProp();
  function defineLanguageFacet(baseData) {
    return Facet.define({
      combine: baseData ? (values) => values.concat(baseData) : void 0,
    });
  }
  __name(defineLanguageFacet, "defineLanguageFacet");
  var Language = class Language {
    isActiveAt(state, pos) {
      var side = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
      return languageDataFacetAt(state, pos, side) == this.data;
    }
    findRegions(state) {
      var lang = state.facet(language);
      if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
        return [
          {
            from: 0,
            to: state.doc.length,
          },
        ];
      if (!lang || !lang.allowsNesting) return [];
      var result = [];
      var explore = /* @__PURE__ */ __name((tree, from) => {
        if (tree.prop(languageDataProp) == this.data) {
          result.push({
            from,
            to: from + tree.length,
          });
          return;
        }
        var mount = tree.prop(NodeProp.mounted);
        if (mount) {
          if (mount.tree.prop(languageDataProp) == this.data) {
            var _iteratorNormalCompletion = true,
              _didIteratorError = false,
              _iteratorError = undefined;
            if (mount.overlay)
              try {
                for (var _iterator = mount.overlay[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var r = _step.value;
                  result.push({
                    from: r.from + from,
                    to: r.to + from,
                  });
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }
            else
              result.push({
                from,
                to: from + tree.length,
              });
            return;
          } else if (mount.overlay) {
            var size = result.length;
            explore(mount.tree, mount.overlay[0].from + from);
            if (result.length > size) return;
          }
        }
        for (var i = 0; i < tree.children.length; i++) {
          var ch = tree.children[i];
          if (ch instanceof Tree) explore(ch, tree.positions[i] + from);
        }
      }, "explore");
      explore(syntaxTree(state), 0);
      return result;
    }
    get allowsNesting() {
      return true;
    }
    constructor(data, parser2, ref, ref1) {
      var extraExtensions = ref === void 0 ? [] : ref,
        name2 = ref1 === void 0 ? "" : ref1;
      this.data = data;
      this.name = name2;
      if (!EditorState.prototype.hasOwnProperty("tree"))
        Object.defineProperty(EditorState.prototype, "tree", {
          get() {
            return syntaxTree(this);
          },
        });
      this.parser = parser2;
      this.extension = [language.of(this), EditorState.languageData.of((state, pos, side) => state.facet(languageDataFacetAt(state, pos, side)))].concat(extraExtensions);
    }
  };
  __name(Language, "Language");
  Language.setState = /* @__PURE__ */ StateEffect.define();
  function languageDataFacetAt(state, pos, side) {
    var topLang = state.facet(language);
    if (!topLang) return null;
    var facet = topLang.data;
    if (topLang.allowsNesting) {
      for (var node = syntaxTree(state).topNode; node; node = node.enter(pos, side, IterMode.ExcludeBuffers)) facet = node.type.prop(languageDataProp) || facet;
    }
    return facet;
  }
  __name(languageDataFacetAt, "languageDataFacetAt");
  var LRLanguage = class LRLanguage1 extends Language {
    static define(spec) {
      var data = defineLanguageFacet(spec.languageData);
      return new LRLanguage(
        data,
        spec.parser.configure({
          props: [languageDataProp.add((type) => (type.isTop ? data : void 0))],
        }),
        spec.name
      );
    }
    configure(options, name2) {
      return new LRLanguage(this.data, this.parser.configure(options), name2 || this.name);
    }
    get allowsNesting() {
      return this.parser.hasWrappers();
    }
    constructor(data, parser2, name2) {
      super(data, parser2, [], name2);
      this.parser = parser2;
    }
  };
  __name(LRLanguage, "LRLanguage");
  function syntaxTree(state) {
    var field = state.field(Language.state, false);
    return field ? field.tree : Tree.empty;
  }
  __name(syntaxTree, "syntaxTree");
  var DocInput = class DocInput {
    syncTo(pos) {
      this.string = this.cursor.next(pos - this.cursorPos).value;
      this.cursorPos = pos + this.string.length;
      return this.cursorPos - this.string.length;
    }
    chunk(pos) {
      this.syncTo(pos);
      return this.string;
    }
    get lineChunks() {
      return true;
    }
    read(from, to) {
      var stringStart = this.cursorPos - this.string.length;
      if (from < stringStart || to >= this.cursorPos) return this.doc.sliceString(from, to);
      else return this.string.slice(from - stringStart, to - stringStart);
    }
    constructor(doc2, ref) {
      var length = ref === void 0 ? doc2.length : ref;
      this.doc = doc2;
      this.length = length;
      this.cursorPos = 0;
      this.string = "";
      this.cursor = doc2.iter();
    }
  };
  __name(DocInput, "DocInput");
  var currentContext = null;
  var ParseContext = class ParseContext1 {
    static create(parser2, state, viewport) {
      return new ParseContext(parser2, state, [], Tree.empty, 0, viewport, [], null);
    }
    startParse() {
      return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
    }
    work(until, upto) {
      if (upto != null && upto >= this.state.doc.length) upto = void 0;
      if (this.tree != Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
        this.takeTree();
        return true;
      }
      return this.withContext(() => {
        var _a2;
        if (typeof until == "number") {
          var endTime = Date.now() + until;
          until = /* @__PURE__ */ __name(() => Date.now() > endTime, "until");
        }
        if (!this.parse) this.parse = this.startParse();
        if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length) this.parse.stopAt(upto);
        for (;;) {
          var done = this.parse.advance();
          if (done) {
            this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
            this.treeLen = (_a2 = this.parse.stoppedAt) !== null && _a2 !== void 0 ? _a2 : this.state.doc.length;
            this.tree = done;
            this.parse = null;
            if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length)) this.parse = this.startParse();
            else return true;
          }
          if (until()) return false;
        }
      });
    }
    takeTree() {
      var pos, tree;
      if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
        if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos) this.parse.stopAt(pos);
        this.withContext(() => {
          while (!(tree = this.parse.advance())) {}
        });
        this.treeLen = pos;
        this.tree = tree;
        this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
        this.parse = null;
      }
    }
    withContext(f) {
      var prev = currentContext;
      currentContext = this;
      try {
        return f();
      } finally {
        currentContext = prev;
      }
    }
    withoutTempSkipped(fragments) {
      for (var r; (r = this.tempSkipped.pop()); ) fragments = cutFragments(fragments, r.from, r.to);
      return fragments;
    }
    changes(changes, newState) {
      var _this = this,
        fragments = _this.fragments,
        tree = _this.tree,
        treeLen = _this.treeLen,
        viewport = _this.viewport,
        skipped = _this.skipped;
      this.takeTree();
      if (!changes.empty) {
        var ranges = [];
        changes.iterChangedRanges((fromA, toA, fromB, toB) =>
          ranges.push({
            fromA,
            toA,
            fromB,
            toB,
          })
        );
        fragments = TreeFragment.applyChanges(fragments, ranges);
        tree = Tree.empty;
        treeLen = 0;
        viewport = {
          from: changes.mapPos(viewport.from, -1),
          to: changes.mapPos(viewport.to, 1),
        };
        if (this.skipped.length) {
          skipped = [];
          var _iteratorNormalCompletion = true,
            _didIteratorError = false,
            _iteratorError = undefined;
          try {
            for (var _iterator = this.skipped[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var r = _step.value;
              var from = changes.mapPos(r.from, 1),
                to = changes.mapPos(r.to, -1);
              if (from < to)
                skipped.push({
                  from,
                  to,
                });
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }
      }
      return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
    }
    updateViewport(viewport) {
      if (this.viewport.from == viewport.from && this.viewport.to == viewport.to) return false;
      this.viewport = viewport;
      var startLen = this.skipped.length;
      for (var i = 0; i < this.skipped.length; i++) {
        var _this_skipped_i = this.skipped[i],
          from = _this_skipped_i.from,
          to = _this_skipped_i.to;
        if (from < viewport.to && to > viewport.from) {
          this.fragments = cutFragments(this.fragments, from, to);
          this.skipped.splice(i--, 1);
        }
      }
      if (this.skipped.length >= startLen) return false;
      this.reset();
      return true;
    }
    reset() {
      if (this.parse) {
        this.takeTree();
        this.parse = null;
      }
    }
    skipUntilInView(from, to) {
      this.skipped.push({
        from,
        to,
      });
    }
    static getSkippingParser(until) {
      return new (class extends Parser {
        createParse(input, fragments, ranges) {
          var from = ranges[0].from,
            to = ranges[ranges.length - 1].to;
          var parser2 = {
            parsedPos: from,
            advance() {
              var cx = currentContext;
              if (cx) {
                var _iteratorNormalCompletion = true,
                  _didIteratorError = false,
                  _iteratorError = undefined;
                try {
                  for (var _iterator = ranges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var r = _step.value;
                    cx.tempSkipped.push(r);
                  }
                } catch (err) {
                  _didIteratorError = true;
                  _iteratorError = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                      _iterator.return();
                    }
                  } finally {
                    if (_didIteratorError) {
                      throw _iteratorError;
                    }
                  }
                }
                if (until) cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
              }
              this.parsedPos = to;
              return new Tree(NodeType.none, [], [], to - from);
            },
            stoppedAt: null,
            stopAt() {},
          };
          return parser2;
        }
      })();
    }
    isDone(upto) {
      upto = Math.min(upto, this.state.doc.length);
      var frags = this.fragments;
      return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
    }
    static get() {
      return currentContext;
    }
    constructor(parser2, state, ref, tree, treeLen, viewport, skipped, scheduleOn) {
      var fragments = ref === void 0 ? [] : ref;
      this.parser = parser2;
      this.state = state;
      this.fragments = fragments;
      this.tree = tree;
      this.treeLen = treeLen;
      this.viewport = viewport;
      this.skipped = skipped;
      this.scheduleOn = scheduleOn;
      this.parse = null;
      this.tempSkipped = [];
    }
  };
  __name(ParseContext, "ParseContext");
  function cutFragments(fragments, from, to) {
    return TreeFragment.applyChanges(fragments, [
      {
        fromA: from,
        toA: to,
        fromB: from,
        toB: to,
      },
    ]);
  }
  __name(cutFragments, "cutFragments");
  var LanguageState = class LanguageState1 {
    apply(tr) {
      if (!tr.docChanged && this.tree == this.context.tree) return this;
      var newCx = this.context.changes(tr.changes, tr.state);
      var upto = this.context.treeLen == tr.startState.doc.length ? void 0 : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
      if (!newCx.work(20, upto)) newCx.takeTree();
      return new LanguageState(newCx);
    }
    static init(state) {
      var vpTo = Math.min(3e3, state.doc.length);
      var parseState = ParseContext.create(state.facet(language).parser, state, {
        from: 0,
        to: vpTo,
      });
      if (!parseState.work(20, vpTo)) parseState.takeTree();
      return new LanguageState(parseState);
    }
    constructor(context) {
      this.context = context;
      this.tree = context.tree;
    }
  };
  __name(LanguageState, "LanguageState");
  Language.state = /* @__PURE__ */ StateField.define({
    create: LanguageState.init,
    update(value, tr) {
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = tr.effects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var e = _step.value;
          if (e.is(Language.setState)) return e.value;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      if (tr.startState.facet(language) != tr.state.facet(language)) return LanguageState.init(tr.state);
      return value.apply(tr);
    },
  });
  var requestIdle = /* @__PURE__ */ __name((callback) => {
    var timeout = setTimeout(() => callback(), 500);
    return () => clearTimeout(timeout);
  }, "requestIdle");
  if (typeof requestIdleCallback != "undefined")
    requestIdle = /* @__PURE__ */ __name((callback) => {
      var idle = -1,
        timeout = setTimeout(() => {
          idle = requestIdleCallback(callback, {
            timeout: 500 - 100,
          });
        }, 100);
      return () => (idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle));
    }, "requestIdle");
  var isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
  var parseWorker = /* @__PURE__ */ ViewPlugin.fromClass(
    /* @__PURE__ */ __name(
      class ParseWorker {
        update(update2) {
          var cx = this.view.state.field(Language.state).context;
          if (cx.updateViewport(update2.view.viewport) || this.view.viewport.to > cx.treeLen) this.scheduleWork();
          if (update2.docChanged) {
            if (this.view.hasFocus) this.chunkBudget += 50;
            this.scheduleWork();
          }
          this.checkAsyncSchedule(cx);
        }
        scheduleWork() {
          if (this.working) return;
          var state = this.view.state,
            field = state.field(Language.state);
          if (field.tree != field.context.tree || !field.context.isDone(state.doc.length)) this.working = requestIdle(this.work);
        }
        work(deadline) {
          this.working = null;
          var now = Date.now();
          if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {
            this.chunkEnd = now + 3e4;
            this.chunkBudget = 3e3;
          }
          if (this.chunkBudget <= 0) return;
          var _this_view = this.view,
            state = _this_view.state,
            _this_view_viewport = _this_view.viewport,
            vpTo = _this_view_viewport.to,
            field = state.field(Language.state);
          if (field.tree == field.context.tree && field.context.isDone(vpTo + 1e5)) return;
          var endTime = Date.now() + Math.min(this.chunkBudget, 100, deadline && !isInputPending ? Math.max(25, deadline.timeRemaining() - 5) : 1e9);
          var viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1e3;
          var done = field.context.work(() => {
            return (isInputPending && isInputPending()) || Date.now() > endTime;
          }, vpTo + (viewportFirst ? 0 : 1e5));
          this.chunkBudget -= Date.now() - now;
          if (done || this.chunkBudget <= 0) {
            field.context.takeTree();
            this.view.dispatch({
              effects: Language.setState.of(new LanguageState(field.context)),
            });
          }
          if (this.chunkBudget > 0 && !(done && !viewportFirst)) this.scheduleWork();
          this.checkAsyncSchedule(field.context);
        }
        checkAsyncSchedule(cx) {
          if (cx.scheduleOn) {
            this.workScheduled++;
            cx.scheduleOn
              .then(() => this.scheduleWork())
              .catch((err) => logException(this.view.state, err))
              .then(() => this.workScheduled--);
            cx.scheduleOn = null;
          }
        }
        destroy() {
          if (this.working) this.working();
        }
        isWorking() {
          return !!(this.working || this.workScheduled > 0);
        }
        constructor(view) {
          this.view = view;
          this.working = null;
          this.workScheduled = 0;
          this.chunkEnd = -1;
          this.chunkBudget = -1;
          this.work = this.work.bind(this);
          this.scheduleWork();
        }
      },
      "ParseWorker"
    ),
    {
      eventHandlers: {
        focus() {
          this.scheduleWork();
        },
      },
    }
  );
  var language = /* @__PURE__ */ Facet.define({
    combine(languages) {
      return languages.length ? languages[0] : null;
    },
    enables: (language3) => [
      Language.state,
      parseWorker,
      EditorView.contentAttributes.compute([language3], (state) => {
        var lang = state.facet(language3);
        return lang && lang.name
          ? {
              "data-language": lang.name,
            }
          : {};
      }),
    ],
  });
  var LanguageSupport = class LanguageSupport {
    constructor(language3, ref) {
      var support = ref === void 0 ? [] : ref;
      this.language = language3;
      this.support = support;
      this.extension = [language3, support];
    }
  };
  __name(LanguageSupport, "LanguageSupport");
  var indentUnit = /* @__PURE__ */ Facet.define({
    combine: (values) => {
      if (!values.length) return "  ";
      if (!/^(?: +|\t+)$/.test(values[0])) throw new Error("Invalid indent unit: " + JSON.stringify(values[0]));
      return values[0];
    },
  });
  function getIndentUnit(state) {
    var unit = state.facet(indentUnit);
    return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;
  }
  __name(getIndentUnit, "getIndentUnit");
  function indentString(state, cols) {
    var result = "",
      ts = state.tabSize;
    if (state.facet(indentUnit).charCodeAt(0) == 9)
      while (cols >= ts) {
        result += "	";
        cols -= ts;
      }
    for (var i = 0; i < cols; i++) result += " ";
    return result;
  }
  __name(indentString, "indentString");
  var HighlightStyle = class HighlightStyle1 {
    static define(specs, options) {
      return new HighlightStyle(specs, options || {});
    }
    constructor(specs, options) {
      this.specs = specs;
      var modSpec;
      function def(spec) {
        var cls = StyleModule.newName();
        (modSpec || (modSpec = /* @__PURE__ */ Object.create(null)))["." + cls] = spec;
        return cls;
      }
      __name(def, "def");
      var all = typeof options.all == "string" ? options.all : options.all ? def(options.all) : void 0;
      var scopeOpt = options.scope;
      this.scope = scopeOpt instanceof Language ? (type) => type.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type) => type == scopeOpt : void 0;
      this.style = tagHighlighter(
        specs.map((style) => ({
          tag: style.tag,
          class:
            style.class ||
            def(
              Object.assign({}, style, {
                tag: null,
              })
            ),
        })),
        {
          all,
        }
      ).style;
      this.module = modSpec ? new StyleModule(modSpec) : null;
      this.themeType = options.themeType;
    }
  };
  __name(HighlightStyle, "HighlightStyle");
  var highlighterFacet = /* @__PURE__ */ Facet.define();
  var fallbackHighlighter = /* @__PURE__ */ Facet.define({
    combine(values) {
      return values.length ? [values[0]] : null;
    },
  });
  function getHighlighters(state) {
    var main = state.facet(highlighterFacet);
    return main.length ? main : state.facet(fallbackHighlighter);
  }
  __name(getHighlighters, "getHighlighters");
  function syntaxHighlighting(highlighter, options) {
    var ext = [treeHighlighter],
      themeType;
    if (highlighter instanceof HighlightStyle) {
      if (highlighter.module) ext.push(EditorView.styleModule.of(highlighter.module));
      themeType = highlighter.themeType;
    }
    if (options === null || options === void 0 ? void 0 : options.fallback) ext.push(fallbackHighlighter.of(highlighter));
    else if (themeType)
      ext.push(
        highlighterFacet.computeN([EditorView.darkTheme], (state) => {
          return state.facet(EditorView.darkTheme) == (themeType == "dark") ? [highlighter] : [];
        })
      );
    else ext.push(highlighterFacet.of(highlighter));
    return ext;
  }
  __name(syntaxHighlighting, "syntaxHighlighting");
  var TreeHighlighter = class TreeHighlighter {
    update(update2) {
      var tree = syntaxTree(update2.state),
        highlighters = getHighlighters(update2.state);
      var styleChange = highlighters != getHighlighters(update2.startState);
      if (tree.length < update2.view.viewport.to && !styleChange && tree.type == this.tree.type) {
        this.decorations = this.decorations.map(update2.changes);
      } else if (tree != this.tree || update2.viewportChanged || styleChange) {
        this.tree = tree;
        this.decorations = this.buildDeco(update2.view, highlighters);
      }
    }
    buildDeco(view, highlighters) {
      if (!highlighters || !this.tree.length) return Decoration.none;
      var builder = new RangeSetBuilder();
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = view.visibleRanges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step_value = _step.value,
            from = _step_value.from,
            to = _step_value.to;
          highlightTree(
            this.tree,
            highlighters,
            (from2, to2, style) => {
              builder.add(
                from2,
                to2,
                this.markCache[style] ||
                  (this.markCache[style] = Decoration.mark({
                    class: style,
                  }))
              );
            },
            from,
            to
          );
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return builder.finish();
    }
    constructor(view) {
      this.markCache = /* @__PURE__ */ Object.create(null);
      this.tree = syntaxTree(view.state);
      this.decorations = this.buildDeco(view, getHighlighters(view.state));
    }
  };
  __name(TreeHighlighter, "TreeHighlighter");
  var treeHighlighter = /* @__PURE__ */ Prec.high(
    /* @__PURE__ */ ViewPlugin.fromClass(TreeHighlighter, {
      decorations: (v) => v.decorations,
    })
  );
  var defaultHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
    {
      tag: tags.meta,
      color: "#7a757a",
    },
    {
      tag: tags.link,
      textDecoration: "underline",
    },
    {
      tag: tags.heading,
      textDecoration: "underline",
      fontWeight: "bold",
    },
    {
      tag: tags.emphasis,
      fontStyle: "italic",
    },
    {
      tag: tags.strong,
      fontWeight: "bold",
    },
    {
      tag: tags.strikethrough,
      textDecoration: "line-through",
    },
    {
      tag: tags.keyword,
      color: "#708",
    },
    {
      tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],
      color: "#219",
    },
    {
      tag: [tags.literal, tags.inserted],
      color: "#164",
    },
    {
      tag: [tags.string, tags.deleted],
      color: "#a11",
    },
    {
      tag: [tags.regexp, tags.escape, /* @__PURE__ */ tags.special(tags.string)],
      color: "#e40",
    },
    {
      tag: /* @__PURE__ */ tags.definition(tags.variableName),
      color: "#00f",
    },
    {
      tag: /* @__PURE__ */ tags.local(tags.variableName),
      color: "#30a",
    },
    {
      tag: [tags.typeName, tags.namespace],
      color: "#085",
    },
    {
      tag: tags.className,
      color: "#167",
    },
    {
      tag: [/* @__PURE__ */ tags.special(tags.variableName), tags.macroName],
      color: "#256",
    },
    {
      tag: /* @__PURE__ */ tags.definition(tags.propertyName),
      color: "#00c",
    },
    {
      tag: tags.comment,
      color: "#940",
    },
    {
      tag: tags.invalid,
      color: "#f00",
    },
  ]);
  var baseTheme2 = /* @__PURE__ */ EditorView.baseTheme({
    "&.cm-focused .cm-matchingBracket": {
      backgroundColor: "#328c8252",
    },
    "&.cm-focused .cm-nonmatchingBracket": {
      backgroundColor: "#bb555544",
    },
  });
  var DefaultScanDist = 1e4;
  var DefaultBrackets = "()[]{}";
  var bracketMatchingConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        afterCursor: true,
        brackets: DefaultBrackets,
        maxScanDistance: DefaultScanDist,
        renderMatch: defaultRenderMatch,
      });
    },
  });
  var matchingMark = /* @__PURE__ */ Decoration.mark({
    class: "cm-matchingBracket",
  });
  var nonmatchingMark = /* @__PURE__ */ Decoration.mark({
    class: "cm-nonmatchingBracket",
  });
  function defaultRenderMatch(match) {
    var decorations2 = [];
    var mark = match.matched ? matchingMark : nonmatchingMark;
    decorations2.push(mark.range(match.start.from, match.start.to));
    if (match.end) decorations2.push(mark.range(match.end.from, match.end.to));
    return decorations2;
  }
  __name(defaultRenderMatch, "defaultRenderMatch");
  var bracketMatchingState = /* @__PURE__ */ StateField.define({
    create() {
      return Decoration.none;
    },
    update(deco, tr) {
      if (!tr.docChanged && !tr.selection) return deco;
      var decorations2 = [];
      var config = tr.state.facet(bracketMatchingConfig);
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = tr.state.selection.ranges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var range = _step.value;
          if (!range.empty) continue;
          var match = matchBrackets(tr.state, range.head, -1, config) || (range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config)) || (config.afterCursor && (matchBrackets(tr.state, range.head, 1, config) || (range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config))));
          if (match) decorations2 = decorations2.concat(config.renderMatch(match, tr.state));
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return Decoration.set(decorations2, true);
    },
    provide: (f) => EditorView.decorations.from(f),
  });
  var bracketMatchingUnique = [bracketMatchingState, baseTheme2];
  function bracketMatching() {
    var config = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return [bracketMatchingConfig.of(config), bracketMatchingUnique];
  }
  __name(bracketMatching, "bracketMatching");
  function matchingNodes(node, dir, brackets) {
    var byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);
    if (byProp) return byProp;
    if (node.name.length == 1) {
      var index = brackets.indexOf(node.name);
      if (index > -1 && index % 2 == (dir < 0 ? 1 : 0)) return [brackets[index + dir]];
    }
    return null;
  }
  __name(matchingNodes, "matchingNodes");
  function matchBrackets(state, pos, dir) {
    var config = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    var maxScanDistance = config.maxScanDistance || DefaultScanDist,
      brackets = config.brackets || DefaultBrackets;
    var tree = syntaxTree(state),
      node = tree.resolveInner(pos, dir);
    for (var cur = node; cur; cur = cur.parent) {
      var matches = matchingNodes(cur.type, dir, brackets);
      if (matches && cur.from < cur.to) return matchMarkedBrackets(state, pos, dir, cur, matches, brackets);
    }
    return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);
  }
  __name(matchBrackets, "matchBrackets");
  function matchMarkedBrackets(_state, _pos, dir, token, matching, brackets) {
    var parent = token.parent,
      firstToken = {
        from: token.from,
        to: token.to,
      };
    var depth = 0,
      cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();
    if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to)))
      do {
        if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {
          if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {
            return {
              start: firstToken,
              end: {
                from: cursor.from,
                to: cursor.to,
              },
              matched: true,
            };
          } else if (matchingNodes(cursor.type, dir, brackets)) {
            depth++;
          } else if (matchingNodes(cursor.type, -dir, brackets)) {
            if (depth == 0)
              return {
                start: firstToken,
                end:
                  cursor.from == cursor.to
                    ? void 0
                    : {
                        from: cursor.from,
                        to: cursor.to,
                      },
                matched: false,
              };
            depth--;
          }
        }
      } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());
    return {
      start: firstToken,
      matched: false,
    };
  }
  __name(matchMarkedBrackets, "matchMarkedBrackets");
  function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {
    var startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
    var bracket2 = brackets.indexOf(startCh);
    if (bracket2 < 0 || (bracket2 % 2 == 0) != dir > 0) return null;
    var startToken = {
      from: dir < 0 ? pos - 1 : pos,
      to: dir > 0 ? pos + 1 : pos,
    };
    var iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0),
      depth = 0;
    for (var distance = 0; !iter.next().done && distance <= maxScanDistance; ) {
      var text2 = iter.value;
      if (dir < 0) distance += text2.length;
      var basePos = pos + distance * dir;
      for (var pos2 = dir > 0 ? 0 : text2.length - 1, end = dir > 0 ? text2.length : -1; pos2 != end; pos2 += dir) {
        var found = brackets.indexOf(text2[pos2]);
        if (found < 0 || tree.resolveInner(basePos + pos2, 1).type != tokenType) continue;
        if ((found % 2 == 0) == dir > 0) {
          depth++;
        } else if (depth == 1) {
          return {
            start: startToken,
            end: {
              from: basePos + pos2,
              to: basePos + pos2 + 1,
            },
            matched: found >> 1 == bracket2 >> 1,
          };
        } else {
          depth--;
        }
      }
      if (dir > 0) distance += text2.length;
    }
    return iter.done
      ? {
          start: startToken,
          matched: false,
        }
      : null;
  }
  __name(matchPlainBrackets, "matchPlainBrackets");
  var noTokens = /* @__PURE__ */ Object.create(null);
  var typeArray = [NodeType.none];
  var warned = [];
  var defaultTable = /* @__PURE__ */ Object.create(null);
  for (
    var _i1 = 0,
      _iter1 = [
        ["variable", "variableName"],
        ["variable-2", "variableName.special"],
        ["string-2", "string.special"],
        ["def", "variableName.definition"],
        ["tag", "tagName"],
        ["attribute", "attributeName"],
        ["type", "typeName"],
        ["builtin", "variableName.standard"],
        ["qualifier", "modifier"],
        ["error", "invalid"],
        ["header", "heading"],
        ["property", "propertyName"],
      ];
    _i1 < _iter1.length;
    _i1++
  ) {
    var _iter__i = _slicedToArray(_iter1[_i1], 2),
      legacyName = _iter__i[0],
      name2 = _iter__i[1];
    defaultTable[legacyName] = /* @__PURE__ */ createTokenType(noTokens, name2);
  }
  function warnForPart(part, msg) {
    if (warned.indexOf(part) > -1) return;
    warned.push(part);
    console.warn(msg);
  }
  __name(warnForPart, "warnForPart");
  function createTokenType(extra, tagStr) {
    var tag = null;
    var _iteratorNormalCompletion = true,
      _didIteratorError = false,
      _iteratorError = undefined;
    try {
      for (var _iterator = tagStr.split(".")[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var part = _step.value;
        var value = extra[part] || tags[part];
        if (!value) {
          warnForPart(part, "Unknown highlighting tag ".concat(part));
        } else if (typeof value == "function") {
          if (!tag) warnForPart(part, "Modifier ".concat(part, " used at start of tag"));
          else tag = value(tag);
        } else {
          if (tag) warnForPart(part, "Tag ".concat(part, " used as modifier"));
          else tag = value;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    if (!tag) return 0;
    var name2 = tagStr.replace(/ /g, "_"),
      type = NodeType.define({
        id: typeArray.length,
        name: name2,
        props: [
          styleTags({
            [name2]: tag,
          }),
        ],
      });
    typeArray.push(type);
    return type.id;
  }
  __name(createTokenType, "createTokenType");
  // node_modules/@codemirror/commands/dist/index.js
  var fromHistory = /* @__PURE__ */ Annotation.define();
  var isolateHistory = /* @__PURE__ */ Annotation.define();
  var invertedEffects = /* @__PURE__ */ Facet.define();
  var historyConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(
        configs,
        {
          minDepth: 100,
          newGroupDelay: 500,
        },
        {
          minDepth: Math.max,
          newGroupDelay: Math.min,
        }
      );
    },
  });
  function changeEnd(changes) {
    var end = 0;
    changes.iterChangedRanges((_, to) => (end = to));
    return end;
  }
  __name(changeEnd, "changeEnd");
  var historyField_ = /* @__PURE__ */ StateField.define({
    create() {
      return HistoryState.empty;
    },
    update(state, tr) {
      var config = tr.state.facet(historyConfig);
      var fromHist = tr.annotation(fromHistory);
      if (fromHist) {
        var selection = tr.docChanged ? EditorSelection.single(changeEnd(tr.changes)) : void 0;
        var item = HistEvent.fromTransaction(tr, selection),
          from = fromHist.side;
        var other = from == 0 ? state.undone : state.done;
        if (item) other = updateBranch(other, other.length, config.minDepth, item);
        else other = addSelection(other, tr.startState.selection);
        return new HistoryState(from == 0 ? fromHist.rest : other, from == 0 ? other : fromHist.rest);
      }
      var isolate = tr.annotation(isolateHistory);
      if (isolate == "full" || isolate == "before") state = state.isolate();
      if (tr.annotation(Transaction.addToHistory) === false) return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;
      var event = HistEvent.fromTransaction(tr);
      var time = tr.annotation(Transaction.time),
        userEvent = tr.annotation(Transaction.userEvent);
      if (event) state = state.addChanges(event, time, userEvent, config.newGroupDelay, config.minDepth);
      else if (tr.selection) state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);
      if (isolate == "full" || isolate == "after") state = state.isolate();
      return state;
    },
    toJSON(value) {
      return {
        done: value.done.map((e) => e.toJSON()),
        undone: value.undone.map((e) => e.toJSON()),
      };
    },
    fromJSON(json) {
      return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));
    },
  });
  function history() {
    var config = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return [
      historyField_,
      historyConfig.of(config),
      EditorView.domEventHandlers({
        beforeinput(e, view) {
          var command = e.inputType == "historyUndo" ? undo : e.inputType == "historyRedo" ? redo : null;
          if (!command) return false;
          e.preventDefault();
          return command(view);
        },
      }),
    ];
  }
  __name(history, "history");
  function cmd(side, selection) {
    return function (param) {
      var state = param.state,
        dispatch = param.dispatch;
      if (!selection && state.readOnly) return false;
      var historyState = state.field(historyField_, false);
      if (!historyState) return false;
      var tr = historyState.pop(side, state, selection);
      if (!tr) return false;
      dispatch(tr);
      return true;
    };
  }
  __name(cmd, "cmd");
  var undo = /* @__PURE__ */ cmd(0, false);
  var redo = /* @__PURE__ */ cmd(1, false);
  var undoSelection = /* @__PURE__ */ cmd(0, true);
  var redoSelection = /* @__PURE__ */ cmd(1, true);
  var HistEvent = class HistEvent1 {
    setSelAfter(after) {
      return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
    }
    toJSON() {
      var _a2, _b, _c;
      return {
        changes: (_a2 = this.changes) === null || _a2 === void 0 ? void 0 : _a2.toJSON(),
        mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
        startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
        selectionsAfter: this.selectionsAfter.map((s) => s.toJSON()),
      };
    }
    static fromJSON(json) {
      return new HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));
    }
    static fromTransaction(tr, selection) {
      var effects = none2;
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = tr.startState.facet(invertedEffects)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var invert = _step.value;
          var result = invert(tr);
          if (result.length) effects = effects.concat(result);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      if (!effects.length && tr.changes.empty) return null;
      return new HistEvent(tr.changes.invert(tr.startState.doc), effects, void 0, selection || tr.startState.selection, none2);
    }
    static selection(selections) {
      return new HistEvent(void 0, none2, void 0, void 0, selections);
    }
    constructor(changes, effects, mapped, startSelection, selectionsAfter) {
      this.changes = changes;
      this.effects = effects;
      this.mapped = mapped;
      this.startSelection = startSelection;
      this.selectionsAfter = selectionsAfter;
    }
  };
  __name(HistEvent, "HistEvent");
  function updateBranch(branch, to, maxLen, newEvent) {
    var start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
    var newBranch = branch.slice(start, to);
    newBranch.push(newEvent);
    return newBranch;
  }
  __name(updateBranch, "updateBranch");
  function isAdjacent(a, b) {
    var ranges = [],
      isAdjacent2 = false;
    a.iterChangedRanges((f, t2) => ranges.push(f, t2));
    b.iterChangedRanges((_f, _t, f, t2) => {
      for (var i = 0; i < ranges.length; ) {
        var from = ranges[i++],
          to = ranges[i++];
        if (t2 >= from && f <= to) isAdjacent2 = true;
      }
    });
    return isAdjacent2;
  }
  __name(isAdjacent, "isAdjacent");
  function eqSelectionShape(a, b) {
    return a.ranges.length == b.ranges.length && a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;
  }
  __name(eqSelectionShape, "eqSelectionShape");
  function conc(a, b) {
    return !a.length ? b : !b.length ? a : a.concat(b);
  }
  __name(conc, "conc");
  var none2 = [];
  var MaxSelectionsPerEvent = 200;
  function addSelection(branch, selection) {
    if (!branch.length) {
      return [HistEvent.selection([selection])];
    } else {
      var lastEvent = branch[branch.length - 1];
      var sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
      if (sels.length && sels[sels.length - 1].eq(selection)) return branch;
      sels.push(selection);
      return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
    }
  }
  __name(addSelection, "addSelection");
  function popSelection(branch) {
    var last = branch[branch.length - 1];
    var newBranch = branch.slice();
    newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
    return newBranch;
  }
  __name(popSelection, "popSelection");
  function addMappingToBranch(branch, mapping) {
    if (!branch.length) return branch;
    var length = branch.length,
      selections = none2;
    while (length) {
      var event = mapEvent(branch[length - 1], mapping, selections);
      if ((event.changes && !event.changes.empty) || event.effects.length) {
        var result = branch.slice(0, length);
        result[length - 1] = event;
        return result;
      } else {
        mapping = event.mapped;
        length--;
        selections = event.selectionsAfter;
      }
    }
    return selections.length ? [HistEvent.selection(selections)] : none2;
  }
  __name(addMappingToBranch, "addMappingToBranch");
  function mapEvent(event, mapping, extraSelections) {
    var selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s) => s.map(mapping)) : none2, extraSelections);
    if (!event.changes) return HistEvent.selection(selections);
    var mappedChanges = event.changes.map(mapping),
      before = mapping.mapDesc(event.changes, true);
    var fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
    return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
  }
  __name(mapEvent, "mapEvent");
  var joinableUserEvent = /^(input\.type|delete)($|\.)/;
  var HistoryState = class HistoryState1 {
    isolate() {
      return this.prevTime ? new HistoryState(this.done, this.undone) : this;
    }
    addChanges(event, time, userEvent, newGroupDelay, maxLen) {
      var done = this.done,
        lastEvent = done[done.length - 1];
      if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && ((!lastEvent.selectionsAfter.length && time - this.prevTime < newGroupDelay && isAdjacent(lastEvent.changes, event.changes)) || userEvent == "input.type.compose")) {
        done = updateBranch(done, done.length - 1, maxLen, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none2));
      } else {
        done = updateBranch(done, done.length, maxLen, event);
      }
      return new HistoryState(done, none2, time, userEvent);
    }
    addSelection(selection, time, userEvent, newGroupDelay) {
      var last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none2;
      if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection)) return this;
      return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);
    }
    addMapping(mapping) {
      return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
    }
    pop(side, state, selection) {
      var branch = side == 0 ? this.done : this.undone;
      if (branch.length == 0) return null;
      var event = branch[branch.length - 1];
      if (selection && event.selectionsAfter.length) {
        return state.update({
          selection: event.selectionsAfter[event.selectionsAfter.length - 1],
          annotations: fromHistory.of({
            side,
            rest: popSelection(branch),
          }),
          userEvent: side == 0 ? "select.undo" : "select.redo",
          scrollIntoView: true,
        });
      } else if (!event.changes) {
        return null;
      } else {
        var rest = branch.length == 1 ? none2 : branch.slice(0, branch.length - 1);
        if (event.mapped) rest = addMappingToBranch(rest, event.mapped);
        return state.update({
          changes: event.changes,
          selection: event.startSelection,
          effects: event.effects,
          annotations: fromHistory.of({
            side,
            rest,
          }),
          filter: false,
          userEvent: side == 0 ? "undo" : "redo",
          scrollIntoView: true,
        });
      }
    }
    constructor(done, undone, ref, ref1) {
      var prevTime = ref === void 0 ? 0 : ref,
        prevUserEvent = ref1 === void 0 ? void 0 : ref1;
      this.done = done;
      this.undone = undone;
      this.prevTime = prevTime;
      this.prevUserEvent = prevUserEvent;
    }
  };
  __name(HistoryState, "HistoryState");
  HistoryState.empty = /* @__PURE__ */ new HistoryState(none2, none2);
  var historyKeymap = [
    {
      key: "Mod-z",
      run: undo,
      preventDefault: true,
    },
    {
      key: "Mod-y",
      mac: "Mod-Shift-z",
      run: redo,
      preventDefault: true,
    },
    {
      linux: "Ctrl-Shift-z",
      run: redo,
      preventDefault: true,
    },
    {
      key: "Mod-u",
      run: undoSelection,
      preventDefault: true,
    },
    {
      key: "Alt-u",
      mac: "Mod-Shift-u",
      run: redoSelection,
      preventDefault: true,
    },
  ];
  function changeBySelectedLine(state, f) {
    var atLine = -1;
    return state.changeByRange((range) => {
      var changes = [];
      for (var pos = range.from; pos <= range.to; ) {
        var line = state.doc.lineAt(pos);
        if (line.number > atLine && (range.empty || range.to > line.from)) {
          f(line, changes, range);
          atLine = line.number;
        }
        pos = line.to + 1;
      }
      var changeSet = state.changes(changes);
      return {
        changes,
        range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1)),
      };
    });
  }
  __name(changeBySelectedLine, "changeBySelectedLine");
  var indentMore = /* @__PURE__ */ __name((param) => {
    var state = param.state,
      dispatch = param.dispatch;
    if (state.readOnly) return false;
    dispatch(
      state.update(
        changeBySelectedLine(state, (line, changes) => {
          changes.push({
            from: line.from,
            insert: state.facet(indentUnit),
          });
        }),
        {
          userEvent: "input.indent",
        }
      )
    );
    return true;
  }, "indentMore");
  var indentLess = /* @__PURE__ */ __name((param) => {
    var state = param.state,
      dispatch = param.dispatch;
    if (state.readOnly) return false;
    dispatch(
      state.update(
        changeBySelectedLine(state, (line, changes) => {
          var space2 = /^\s*/.exec(line.text)[0];
          if (!space2) return;
          var col = countColumn(space2, state.tabSize),
            keep = 0;
          var insert3 = indentString(state, Math.max(0, col - getIndentUnit(state)));
          while (keep < space2.length && keep < insert3.length && space2.charCodeAt(keep) == insert3.charCodeAt(keep)) keep++;
          changes.push({
            from: line.from + keep,
            to: line.from + space2.length,
            insert: insert3.slice(keep),
          });
        }),
        {
          userEvent: "delete.dedent",
        }
      )
    );
    return true;
  }, "indentLess");
  var indentWithTab = {
    key: "Tab",
    run: indentMore,
    shift: indentLess,
  };
  // node_modules/crelt/index.es.js
  function crelt() {
    var elt = arguments[0];
    if (typeof elt == "string") elt = document.createElement(elt);
    var i = 1,
      next = arguments[1];
    if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
      for (var name2 in next)
        if (Object.prototype.hasOwnProperty.call(next, name2)) {
          var value = next[name2];
          if (typeof value == "string") elt.setAttribute(name2, value);
          else if (value != null) elt[name2] = value;
        }
      i++;
    }
    for (; i < arguments.length; i++) add(elt, arguments[i]);
    return elt;
  }
  __name(crelt, "crelt");
  function add(elt, child) {
    if (typeof child == "string") {
      elt.appendChild(document.createTextNode(child));
    } else if (child == null) {
    } else if (child.nodeType != null) {
      elt.appendChild(child);
    } else if (Array.isArray(child)) {
      for (var i = 0; i < child.length; i++) add(elt, child[i]);
    } else {
      throw new RangeError("Unsupported child node: " + child);
    }
  }
  __name(add, "add");
  // node_modules/@codemirror/lint/dist/index.js
  var SelectedDiagnostic = class SelectedDiagnostic {
    constructor(from, to, diagnostic) {
      this.from = from;
      this.to = to;
      this.diagnostic = diagnostic;
    }
  };
  __name(SelectedDiagnostic, "SelectedDiagnostic");
  var LintState = class LintState1 {
    static init(diagnostics, panel, state) {
      var markedDiagnostics = diagnostics;
      var diagnosticFilter = state.facet(lintConfig).markerFilter;
      if (diagnosticFilter) markedDiagnostics = diagnosticFilter(markedDiagnostics);
      var ranges = Decoration.set(
        markedDiagnostics.map((d) => {
          return d.from == d.to || (d.from == d.to - 1 && state.doc.lineAt(d.from).to == d.from)
            ? Decoration.widget({
                widget: new DiagnosticWidget(d),
                diagnostic: d,
              }).range(d.from)
            : Decoration.mark({
                attributes: {
                  class: "cm-lintRange cm-lintRange-" + d.severity,
                },
                diagnostic: d,
              }).range(d.from, d.to);
        }),
        true
      );
      return new LintState(ranges, panel, findDiagnostic(ranges));
    }
    constructor(diagnostics, panel, selected) {
      this.diagnostics = diagnostics;
      this.panel = panel;
      this.selected = selected;
    }
  };
  __name(LintState, "LintState");
  function findDiagnostic(diagnostics) {
    var diagnostic = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,
      after = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    var found = null;
    diagnostics.between(after, 1e9, (from, to, param) => {
      var spec = param.spec;
      if (diagnostic && spec.diagnostic != diagnostic) return;
      found = new SelectedDiagnostic(from, to, spec.diagnostic);
      return false;
    });
    return found;
  }
  __name(findDiagnostic, "findDiagnostic");
  function hideTooltip(tr, tooltip) {
    return !!(tr.effects.some((e) => e.is(setDiagnosticsEffect)) || tr.changes.touchesRange(tooltip.pos));
  }
  __name(hideTooltip, "hideTooltip");
  function maybeEnableLint(state, effects) {
    return state.field(lintState, false)
      ? effects
      : effects.concat(
          StateEffect.appendConfig.of([
            lintState,
            EditorView.decorations.compute([lintState], (state2) => {
              var _state2_field = state2.field(lintState),
                selected = _state2_field.selected,
                panel = _state2_field.panel;
              return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([activeMark.range(selected.from, selected.to)]);
            }),
            hoverTooltip(lintTooltip, {
              hideOn: hideTooltip,
            }),
            baseTheme3,
          ])
        );
  }
  __name(maybeEnableLint, "maybeEnableLint");
  function setDiagnostics(state, diagnostics) {
    return {
      effects: maybeEnableLint(state, [setDiagnosticsEffect.of(diagnostics)]),
    };
  }
  __name(setDiagnostics, "setDiagnostics");
  var setDiagnosticsEffect = /* @__PURE__ */ StateEffect.define();
  var togglePanel = /* @__PURE__ */ StateEffect.define();
  var movePanelSelection = /* @__PURE__ */ StateEffect.define();
  var lintState = /* @__PURE__ */ StateField.define({
    create() {
      return new LintState(Decoration.none, null, null);
    },
    update(value, tr) {
      if (tr.docChanged) {
        var mapped = value.diagnostics.map(tr.changes),
          selected = null;
        if (value.selected) {
          var selPos = tr.changes.mapPos(value.selected.from, 1);
          selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
        }
        value = new LintState(mapped, value.panel, selected);
      }
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = tr.effects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var effect = _step.value;
          if (effect.is(setDiagnosticsEffect)) {
            value = LintState.init(effect.value, value.panel, tr.state);
          } else if (effect.is(togglePanel)) {
            value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);
          } else if (effect.is(movePanelSelection)) {
            value = new LintState(value.diagnostics, value.panel, effect.value);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return value;
    },
    provide: (f) => [showPanel.from(f, (val) => val.panel), EditorView.decorations.from(f, (s) => s.diagnostics)],
  });
  var activeMark = /* @__PURE__ */ Decoration.mark({
    class: "cm-lintRange cm-lintRange-active",
  });
  function lintTooltip(view, pos, side) {
    var diagnostics = view.state.field(lintState).diagnostics;
    var found = [],
      stackStart = 2e8,
      stackEnd = 0;
    diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, param) => {
      var spec = param.spec;
      if (pos >= from && pos <= to && (from == to || ((pos > from || side > 0) && (pos < to || side < 0)))) {
        found.push(spec.diagnostic);
        stackStart = Math.min(from, stackStart);
        stackEnd = Math.max(to, stackEnd);
      }
    });
    var diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;
    if (diagnosticFilter) found = diagnosticFilter(found);
    if (!found.length) return null;
    return {
      pos: stackStart,
      end: stackEnd,
      above: view.state.doc.lineAt(stackStart).to < stackEnd,
      create() {
        return {
          dom: diagnosticsTooltip(view, found),
        };
      },
    };
  }
  __name(lintTooltip, "lintTooltip");
  function diagnosticsTooltip(view, diagnostics) {
    return crelt(
      "ul",
      {
        class: "cm-tooltip-lint",
      },
      diagnostics.map((d) => renderDiagnostic(view, d, false))
    );
  }
  __name(diagnosticsTooltip, "diagnosticsTooltip");
  var closeLintPanel = /* @__PURE__ */ __name((view) => {
    var field = view.state.field(lintState, false);
    if (!field || !field.panel) return false;
    view.dispatch({
      effects: togglePanel.of(false),
    });
    return true;
  }, "closeLintPanel");
  var lintPlugin = /* @__PURE__ */ ViewPlugin.fromClass(
    class {
      run() {
        var now = Date.now();
        if (now < this.lintTime - 10) {
          setTimeout(this.run, this.lintTime - now);
        } else {
          this.set = false;
          var state = this.view.state,
            sources = state.facet(lintConfig).sources;
          Promise.all(sources.map((source) => Promise.resolve(source(this.view)))).then(
            (annotations) => {
              var all = annotations.reduce((a, b) => a.concat(b));
              if (this.view.state.doc == state.doc) this.view.dispatch(setDiagnostics(this.view.state, all));
            },
            (error) => {
              logException(this.view.state, error);
            }
          );
        }
      }
      update(update2) {
        var config = update2.state.facet(lintConfig);
        if (update2.docChanged || config != update2.startState.facet(lintConfig)) {
          this.lintTime = Date.now() + config.delay;
          if (!this.set) {
            this.set = true;
            this.timeout = setTimeout(this.run, config.delay);
          }
        }
      }
      force() {
        if (this.set) {
          this.lintTime = Date.now();
          this.run();
        }
      }
      destroy() {
        clearTimeout(this.timeout);
      }
      constructor(view) {
        this.view = view;
        this.timeout = -1;
        this.set = true;
        var delay = view.state.facet(lintConfig).delay;
        this.lintTime = Date.now() + delay;
        this.run = this.run.bind(this);
        this.timeout = setTimeout(this.run, delay);
      }
    }
  );
  var lintConfig = /* @__PURE__ */ Facet.define({
    combine(input) {
      return Object.assign(
        {
          sources: input.map((i) => i.source),
        },
        combineConfig(
          input.map((i) => i.config),
          {
            delay: 750,
            markerFilter: null,
            tooltipFilter: null,
          }
        )
      );
    },
    enables: lintPlugin,
  });
  function linter(source) {
    var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return lintConfig.of({
      source,
      config,
    });
  }
  __name(linter, "linter");
  function assignKeys(actions) {
    var assigned = [];
    var _iteratorNormalCompletion = true,
      _didIteratorError = false,
      _iteratorError = undefined;
    if (actions)
      try {
        var _loop = function () {
          var _loop = function (i) {
            var ch = name2[i];
            if (/[a-zA-Z]/.test(ch) && !assigned.some((c) => c.toLowerCase() == ch.toLowerCase())) {
              assigned.push(ch);
              return "continue|actions";
            }
          };
          var _step_value = _step.value,
            name2 = _step_value.name;
          for (var i = 0; i < name2.length; i++) {
            var _ret = _loop(i);
            switch (_ret) {
              case "continue|actions":
                return "continue|actions";
            }
          }
          assigned.push("");
        };
        actions: for (var _iterator = actions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _ret = _loop();
          switch (_ret) {
            case "continue|actions":
              continue actions;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    return assigned;
  }
  __name(assignKeys, "assignKeys");
  function renderDiagnostic(view, diagnostic, inPanel) {
    var _a2;
    var keys = inPanel ? assignKeys(diagnostic.actions) : [];
    return crelt(
      "li",
      {
        class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity,
      },
      crelt(
        "span",
        {
          class: "cm-diagnosticText",
        },
        diagnostic.renderMessage ? diagnostic.renderMessage() : diagnostic.message
      ),
      (_a2 = diagnostic.actions) === null || _a2 === void 0
        ? void 0
        : _a2.map((action, i) => {
            var click = /* @__PURE__ */ __name((e) => {
              e.preventDefault();
              var found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);
              if (found) action.apply(view, found.from, found.to);
            }, "click");
            var name2 = action.name,
              keyIndex = keys[i] ? name2.indexOf(keys[i]) : -1;
            var nameElt = keyIndex < 0 ? name2 : [name2.slice(0, keyIndex), crelt("u", name2.slice(keyIndex, keyIndex + 1)), name2.slice(keyIndex + 1)];
            return crelt(
              "button",
              {
                type: "button",
                class: "cm-diagnosticAction",
                onclick: click,
                onmousedown: click,
                "aria-label": " Action: ".concat(name2).concat(keyIndex < 0 ? "" : ' (access key "'.concat(keys[i], ')"'), "."),
              },
              nameElt
            );
          }),
      diagnostic.source &&
        crelt(
          "div",
          {
            class: "cm-diagnosticSource",
          },
          diagnostic.source
        )
    );
  }
  __name(renderDiagnostic, "renderDiagnostic");
  var DiagnosticWidget = class DiagnosticWidget extends WidgetType {
    eq(other) {
      return other.diagnostic == this.diagnostic;
    }
    toDOM() {
      return crelt("span", {
        class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity,
      });
    }
    constructor(diagnostic) {
      super();
      this.diagnostic = diagnostic;
    }
  };
  __name(DiagnosticWidget, "DiagnosticWidget");
  var PanelItem = class PanelItem {
    constructor(view, diagnostic) {
      this.diagnostic = diagnostic;
      this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16);
      this.dom = renderDiagnostic(view, diagnostic, true);
      this.dom.id = this.id;
      this.dom.setAttribute("role", "option");
    }
  };
  __name(PanelItem, "PanelItem");
  var LintPanel = class LintPanel1 {
    get selectedIndex() {
      var selected = this.view.state.field(lintState).selected;
      if (!selected) return -1;
      for (var i = 0; i < this.items.length; i++) if (this.items[i].diagnostic == selected.diagnostic) return i;
      return -1;
    }
    update() {
      var _this_view_state_field = this.view.state.field(lintState),
        diagnostics = _this_view_state_field.diagnostics,
        selected = _this_view_state_field.selected;
      var i = 0,
        needsSync = false,
        newSelectedItem = null;
      diagnostics.between(0, this.view.state.doc.length, (_start, _end, param) => {
        var spec = param.spec;
        var found = -1,
          item;
        for (var j = i; j < this.items.length; j++)
          if (this.items[j].diagnostic == spec.diagnostic) {
            found = j;
            break;
          }
        if (found < 0) {
          item = new PanelItem(this.view, spec.diagnostic);
          this.items.splice(i, 0, item);
          needsSync = true;
        } else {
          item = this.items[found];
          if (found > i) {
            this.items.splice(i, found - i);
            needsSync = true;
          }
        }
        if (selected && item.diagnostic == selected.diagnostic) {
          if (!item.dom.hasAttribute("aria-selected")) {
            item.dom.setAttribute("aria-selected", "true");
            newSelectedItem = item;
          }
        } else if (item.dom.hasAttribute("aria-selected")) {
          item.dom.removeAttribute("aria-selected");
        }
        i++;
      });
      while (i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
        needsSync = true;
        this.items.pop();
      }
      if (this.items.length == 0) {
        this.items.push(
          new PanelItem(this.view, {
            from: -1,
            to: -1,
            severity: "info",
            message: this.view.state.phrase("No diagnostics"),
          })
        );
        needsSync = true;
      }
      if (newSelectedItem) {
        this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
        this.view.requestMeasure({
          key: this,
          read: () => ({
            sel: newSelectedItem.dom.getBoundingClientRect(),
            panel: this.list.getBoundingClientRect(),
          }),
          write: (param) => {
            var sel = param.sel,
              panel = param.panel;
            if (sel.top < panel.top) this.list.scrollTop -= panel.top - sel.top;
            else if (sel.bottom > panel.bottom) this.list.scrollTop += sel.bottom - panel.bottom;
          },
        });
      } else if (this.selectedIndex < 0) {
        this.list.removeAttribute("aria-activedescendant");
      }
      if (needsSync) this.sync();
    }
    sync() {
      var domPos = this.list.firstChild;
      function rm2() {
        var prev = domPos;
        domPos = prev.nextSibling;
        prev.remove();
      }
      __name(rm2, "rm");
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var item = _step.value;
          if (item.dom.parentNode == this.list) {
            while (domPos != item.dom) rm2();
            domPos = item.dom.nextSibling;
          } else {
            this.list.insertBefore(item.dom, domPos);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      while (domPos) rm2();
    }
    moveSelection(selectedIndex) {
      if (this.selectedIndex < 0) return;
      var field = this.view.state.field(lintState);
      var selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
      if (!selection) return;
      this.view.dispatch({
        selection: {
          anchor: selection.from,
          head: selection.to,
        },
        scrollIntoView: true,
        effects: movePanelSelection.of(selection),
      });
    }
    static open(view) {
      return new LintPanel(view);
    }
    constructor(view) {
      this.view = view;
      this.items = [];
      var onkeydown = /* @__PURE__ */ __name((event) => {
        if (event.keyCode == 27) {
          closeLintPanel(this.view);
          this.view.focus();
        } else if (event.keyCode == 38 || event.keyCode == 33) {
          this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
        } else if (event.keyCode == 40 || event.keyCode == 34) {
          this.moveSelection((this.selectedIndex + 1) % this.items.length);
        } else if (event.keyCode == 36) {
          this.moveSelection(0);
        } else if (event.keyCode == 35) {
          this.moveSelection(this.items.length - 1);
        } else if (event.keyCode == 13) {
          this.view.focus();
        } else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) {
          var diagnostic = this.items[this.selectedIndex].diagnostic,
            keys = assignKeys(diagnostic.actions);
          for (var i = 0; i < keys.length; i++)
            if (keys[i].toUpperCase().charCodeAt(0) == event.keyCode) {
              var found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
              if (found) diagnostic.actions[i].apply(view, found.from, found.to);
            }
        } else {
          return;
        }
        event.preventDefault();
      }, "onkeydown");
      var onclick = /* @__PURE__ */ __name((event) => {
        for (var i = 0; i < this.items.length; i++) {
          if (this.items[i].dom.contains(event.target)) this.moveSelection(i);
        }
      }, "onclick");
      this.list = crelt("ul", {
        tabIndex: 0,
        role: "listbox",
        "aria-label": this.view.state.phrase("Diagnostics"),
        onkeydown,
        onclick,
      });
      this.dom = crelt(
        "div",
        {
          class: "cm-panel-lint",
        },
        this.list,
        crelt(
          "button",
          {
            type: "button",
            name: "close",
            "aria-label": this.view.state.phrase("close"),
            onclick: () => closeLintPanel(this.view),
          },
          "\xd7"
        )
      );
      this.update();
    }
  };
  __name(LintPanel, "LintPanel");
  function svg(content2) {
    var attrs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'viewBox="0 0 40 40"';
    return 'url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" '.concat(attrs, ">").concat(encodeURIComponent(content2), "</svg>')");
  }
  __name(svg, "svg");
  function underline(color) {
    return svg('<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="'.concat(color, '" fill="none" stroke-width=".7"/>'), 'width="6" height="3"');
  }
  __name(underline, "underline");
  var baseTheme3 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-diagnostic": {
      padding: "3px 6px 3px 8px",
      marginLeft: "-1px",
      display: "block",
      whiteSpace: "pre-wrap",
    },
    ".cm-diagnostic-error": {
      borderLeft: "5px solid #d11",
    },
    ".cm-diagnostic-warning": {
      borderLeft: "5px solid orange",
    },
    ".cm-diagnostic-info": {
      borderLeft: "5px solid #999",
    },
    ".cm-diagnosticAction": {
      font: "inherit",
      border: "none",
      padding: "2px 4px",
      backgroundColor: "#444",
      color: "white",
      borderRadius: "3px",
      marginLeft: "8px",
    },
    ".cm-diagnosticSource": {
      fontSize: "70%",
      opacity: 0.7,
    },
    ".cm-lintRange": {
      backgroundPosition: "left bottom",
      backgroundRepeat: "repeat-x",
      paddingBottom: "0.7px",
    },
    ".cm-lintRange-error": {
      backgroundImage: /* @__PURE__ */ underline("#d11"),
    },
    ".cm-lintRange-warning": {
      backgroundImage: /* @__PURE__ */ underline("orange"),
    },
    ".cm-lintRange-info": {
      backgroundImage: /* @__PURE__ */ underline("#999"),
    },
    ".cm-lintRange-active": {
      backgroundColor: "#ffdd9980",
    },
    ".cm-tooltip-lint": {
      padding: 0,
      margin: 0,
    },
    ".cm-lintPoint": {
      position: "relative",
      "&:after": {
        content: '""',
        position: "absolute",
        bottom: 0,
        left: "-2px",
        borderLeft: "3px solid transparent",
        borderRight: "3px solid transparent",
        borderBottom: "4px solid #d11",
      },
    },
    ".cm-lintPoint-warning": {
      "&:after": {
        borderBottomColor: "orange",
      },
    },
    ".cm-lintPoint-info": {
      "&:after": {
        borderBottomColor: "#999",
      },
    },
    ".cm-panel.cm-panel-lint": {
      position: "relative",
      "& ul": {
        maxHeight: "100px",
        overflowY: "auto",
        "& [aria-selected]": {
          backgroundColor: "#ddd",
          "& u": {
            textDecoration: "underline",
          },
        },
        "&:focus [aria-selected]": {
          background_fallback: "#bdf",
          backgroundColor: "Highlight",
          color_fallback: "white",
          color: "HighlightText",
        },
        "& u": {
          textDecoration: "none",
        },
        padding: 0,
        margin: 0,
      },
      "& [name=close]": {
        position: "absolute",
        top: "0",
        right: "2px",
        background: "inherit",
        border: "none",
        font: "inherit",
        padding: 0,
        margin: 0,
      },
    },
  });
  // src/ui/CopyButton.svelte
  function create_fragment(ctx) {
    var button;
    var mounted;
    var dispose;
    return {
      c() {
        button = element("button");
        button.innerHTML =
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000" class="svelte-1ha11jr"><path d="M704 896H64V320h640v192h64V192c0-35-29-64-64-64H512C512 57 455 0 384 0S256 57 256 128H64c-35 0-64 29-64 64v704c0 35 29 64 64 64h640c35 0 64-29 64-64V768h-64v128zM192 192h64s64-29 64-64 29-64 64-64 64 29 64 64 32 64 64 64h64s64 29 64 64H128c0-39 28-64 64-64zm-64 512h128v-64H128v64zm448-128V448L320 640l256 192V704h320V576H576zM128 832h192v-64H128v64zm320-448H128v64h320v-64zM256 512H128v64h128v-64z"></path></svg>';
        attr(button, "class", "btn svelte-1ha11jr");
        attr(button, "id", "copy");
        attr(button, "title", "Copy bibtex");
        toggle_class(button, "copied", ctx[0]);
      },
      m(target, anchor) {
        insert(target, button, anchor);
        if (!mounted) {
          dispose = listen(button, "click", ctx[1]);
          mounted = true;
        }
      },
      p(ctx2, param) {
        var _param = _slicedToArray(param, 1),
          dirty = _param[0];
        if (dirty & 1) {
          toggle_class(button, "copied", ctx2[0]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) detach(button);
        mounted = false;
        dispose();
      },
    };
  }
  __name(create_fragment, "create_fragment");
  function instance($$self, $$props, $$invalidate) {
    var resetCopyBtnTimeout;
    var showAsCopied = false;
    var bibtex = $$props.bibtex;
    var handleCopy = /* @__PURE__ */ __name(
      /*#__PURE__*/ _asyncToGenerator(function () {
        var _a2;
        return __generator(this, function (_state) {
          switch (_state.label) {
            case 0:
              _state.trys.push([0, 2, , 3]);
              return [4, navigator.clipboard.writeText(bibtex)];
            case 1:
              _state.sent();
              $$invalidate(0, (showAsCopied = true));
              clearInterval(resetCopyBtnTimeout);
              resetCopyBtnTimeout = setTimeout(() => $$invalidate(0, (showAsCopied = false)), 3e3);
              return [3, 3];
            case 2:
              _a2 = _state.sent();
              alert("Failed to copy");
              return [3, 3];
            case 3:
              return [2];
          }
        });
      }),
      "handleCopy"
    );
    $$self.$$set = ($$props2) => {
      if ("bibtex" in $$props2) $$invalidate(2, (bibtex = $$props2.bibtex));
    };
    return [showAsCopied, handleCopy, bibtex];
  }
  __name(instance, "instance");
  var CopyButton = class CopyButton extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance, create_fragment, safe_not_equal, {
        bibtex: 2,
      });
    }
  };
  __name(CopyButton, "CopyButton");
  var CopyButton_default = CopyButton;
  // node_modules/@lezer/lr/dist/index.js
  var Stack = class Stack1 {
    toString() {
      return "["
        .concat(this.stack.filter((_, i) => i % 3 == 0).concat(this.state), "]@")
        .concat(this.pos)
        .concat(this.score ? "!" + this.score : "");
    }
    static start(p, state) {
      var pos = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var cx = p.parser.context;
      return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
    }
    get context() {
      return this.curContext ? this.curContext.context : null;
    }
    pushState(state, start) {
      this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
      this.state = state;
    }
    reduce(action) {
      var depth = action >> 19,
        type = action & 65535;
      var _this_p = this.p,
        parser2 = _this_p.parser;
      var dPrec = parser2.dynamicPrecedence(type);
      if (dPrec) this.score += dPrec;
      if (depth == 0) {
        this.pushState(parser2.getGoto(this.state, type, true), this.reducePos);
        if (type < parser2.minRepeatTerm) this.storeNode(type, this.reducePos, this.reducePos, 4, true);
        this.reduceContext(type, this.reducePos);
        return;
      }
      var base2 = this.stack.length - (depth - 1) * 3 - (action & 262144 ? 6 : 0);
      var start = this.stack[base2 - 2];
      var bufferBase = this.stack[base2 - 1],
        count = this.bufferBase + this.buffer.length - bufferBase;
      if (type < parser2.minRepeatTerm || action & 131072) {
        var pos = parser2.stateFlag(this.state, 1) ? this.pos : this.reducePos;
        this.storeNode(type, start, pos, count + 4, true);
      }
      if (action & 262144) {
        this.state = this.stack[base2];
      } else {
        var baseStateID = this.stack[base2 - 3];
        this.state = parser2.getGoto(baseStateID, type, true);
      }
      while (this.stack.length > base2) this.stack.pop();
      this.reduceContext(type, start);
    }
    storeNode(term, start, end) {
      var size = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 4,
        isReduce = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
      if (term == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
        var cur = this,
          top2 = this.buffer.length;
        if (top2 == 0 && cur.parent) {
          top2 = cur.bufferBase - cur.parent.bufferBase;
          cur = cur.parent;
        }
        if (top2 > 0 && cur.buffer[top2 - 4] == 0 && cur.buffer[top2 - 1] > -1) {
          if (start == end) return;
          if (cur.buffer[top2 - 2] >= start) {
            cur.buffer[top2 - 2] = end;
            return;
          }
        }
      }
      if (!isReduce || this.pos == end) {
        this.buffer.push(term, start, end, size);
      } else {
        var index = this.buffer.length;
        if (index > 0 && this.buffer[index - 4] != 0)
          while (index > 0 && this.buffer[index - 2] > end) {
            this.buffer[index] = this.buffer[index - 4];
            this.buffer[index + 1] = this.buffer[index - 3];
            this.buffer[index + 2] = this.buffer[index - 2];
            this.buffer[index + 3] = this.buffer[index - 1];
            index -= 4;
            if (size > 4) size -= 4;
          }
        this.buffer[index] = term;
        this.buffer[index + 1] = start;
        this.buffer[index + 2] = end;
        this.buffer[index + 3] = size;
      }
    }
    shift(action, next, nextEnd) {
      var start = this.pos;
      if (action & 131072) {
        this.pushState(action & 65535, this.pos);
      } else if ((action & 262144) == 0) {
        var nextState = action,
          _this_p = this.p,
          parser2 = _this_p.parser;
        if (nextEnd > this.pos || next <= parser2.maxNode) {
          this.pos = nextEnd;
          if (!parser2.stateFlag(nextState, 1)) this.reducePos = nextEnd;
        }
        this.pushState(nextState, start);
        this.shiftContext(next, start);
        if (next <= parser2.maxNode) this.buffer.push(next, start, nextEnd, 4);
      } else {
        this.pos = nextEnd;
        this.shiftContext(next, start);
        if (next <= this.p.parser.maxNode) this.buffer.push(next, start, nextEnd, 4);
      }
    }
    apply(action, next, nextEnd) {
      if (action & 65536) this.reduce(action);
      else this.shift(action, next, nextEnd);
    }
    useNode(value, next) {
      var index = this.p.reused.length - 1;
      if (index < 0 || this.p.reused[index] != value) {
        this.p.reused.push(value);
        index++;
      }
      var start = this.pos;
      this.reducePos = this.pos = start + value.length;
      this.pushState(next, start);
      this.buffer.push(index, start, this.reducePos, -1);
      if (this.curContext) this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
    }
    split() {
      var parent = this;
      var off = parent.buffer.length;
      while (off > 0 && parent.buffer[off - 2] > parent.reducePos) off -= 4;
      var buffer = parent.buffer.slice(off),
        base2 = parent.bufferBase + off;
      while (parent && base2 == parent.bufferBase) parent = parent.parent;
      return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base2, this.curContext, this.lookAhead, parent);
    }
    recoverByDelete(next, nextEnd) {
      var isNode = next <= this.p.parser.maxNode;
      if (isNode) this.storeNode(next, this.pos, nextEnd, 4);
      this.storeNode(0, this.pos, nextEnd, isNode ? 8 : 4);
      this.pos = this.reducePos = nextEnd;
      this.score -= 190;
    }
    canShift(term) {
      for (var sim = new SimulatedStack(this); ; ) {
        var action = this.p.parser.stateSlot(sim.state, 4) || this.p.parser.hasAction(sim.state, term);
        if (action == 0) return false;
        if ((action & 65536) == 0) return true;
        sim.reduce(action);
      }
    }
    recoverByInsert(next) {
      if (this.stack.length >= 300) return [];
      var nextStates = this.p.parser.nextStates(this.state);
      if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
        var _loop = function (i1) {
          var s = nextStates[i1 + 1];
          if (!best.some((v, i2) => i2 & 1 && v == s)) best.push(nextStates[i1], s);
        };
        var best = [];
        for (var i = 0, s; i < nextStates.length; i += 2) {
          if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next)) best.push(nextStates[i], s);
        }
        if (this.stack.length < 120) for (var i1 = 0; best.length < 4 << 1 && i1 < nextStates.length; i1 += 2) _loop(i1);
        nextStates = best;
      }
      var result = [];
      for (var i2 = 0; i2 < nextStates.length && result.length < 4; i2 += 2) {
        var s1 = nextStates[i2 + 1];
        if (s1 == this.state) continue;
        var stack = this.split();
        stack.pushState(s1, this.pos);
        stack.storeNode(0, stack.pos, stack.pos, 4, true);
        stack.shiftContext(nextStates[i2], this.pos);
        stack.score -= 200;
        result.push(stack);
      }
      return result;
    }
    forceReduce() {
      var reduce = this.p.parser.stateSlot(this.state, 5);
      if ((reduce & 65536) == 0) return false;
      var _this_p = this.p,
        parser2 = _this_p.parser;
      if (!parser2.validAction(this.state, reduce)) {
        var depth = reduce >> 19,
          term = reduce & 65535;
        var target = this.stack.length - depth * 3;
        if (target < 0 || parser2.getGoto(this.stack[target], term, false) < 0) return false;
        this.storeNode(0, this.reducePos, this.reducePos, 4, true);
        this.score -= 100;
      }
      this.reducePos = this.pos;
      this.reduce(reduce);
      return true;
    }
    forceAll() {
      while (!this.p.parser.stateFlag(this.state, 2)) {
        if (!this.forceReduce()) {
          this.storeNode(0, this.pos, this.pos, 4, true);
          break;
        }
      }
      return this;
    }
    get deadEnd() {
      if (this.stack.length != 3) return false;
      var _this_p = this.p,
        parser2 = _this_p.parser;
      return parser2.data[parser2.stateSlot(this.state, 1)] == 65535 && !parser2.stateSlot(this.state, 4);
    }
    restart() {
      this.state = this.stack[0];
      this.stack.length = 0;
    }
    sameState(other) {
      if (this.state != other.state || this.stack.length != other.stack.length) return false;
      for (var i = 0; i < this.stack.length; i += 3) if (this.stack[i] != other.stack[i]) return false;
      return true;
    }
    get parser() {
      return this.p.parser;
    }
    dialectEnabled(dialectID) {
      return this.p.parser.dialect.flags[dialectID];
    }
    shiftContext(term, start) {
      if (this.curContext) this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
    }
    reduceContext(term, start) {
      if (this.curContext) this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
    }
    emitContext() {
      var last = this.buffer.length - 1;
      if (last < 0 || this.buffer[last] != -3) this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);
    }
    emitLookAhead() {
      var last = this.buffer.length - 1;
      if (last < 0 || this.buffer[last] != -4) this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);
    }
    updateContext(context) {
      if (context != this.curContext.context) {
        var newCx = new StackContext(this.curContext.tracker, context);
        if (newCx.hash != this.curContext.hash) this.emitContext();
        this.curContext = newCx;
      }
    }
    setLookAhead(lookAhead) {
      if (lookAhead > this.lookAhead) {
        this.emitLookAhead();
        this.lookAhead = lookAhead;
      }
    }
    close() {
      if (this.curContext && this.curContext.tracker.strict) this.emitContext();
      if (this.lookAhead > 0) this.emitLookAhead();
    }
    constructor(p, stack, state, reducePos, pos, score, buffer, bufferBase, curContext, ref, parent) {
      var lookAhead = ref === void 0 ? 0 : ref;
      this.p = p;
      this.stack = stack;
      this.state = state;
      this.reducePos = reducePos;
      this.pos = pos;
      this.score = score;
      this.buffer = buffer;
      this.bufferBase = bufferBase;
      this.curContext = curContext;
      this.lookAhead = lookAhead;
      this.parent = parent;
    }
  };
  __name(Stack, "Stack");
  var StackContext = class StackContext {
    constructor(tracker, context) {
      this.tracker = tracker;
      this.context = context;
      this.hash = tracker.strict ? tracker.hash(context) : 0;
    }
  };
  __name(StackContext, "StackContext");
  var Recover;
  (function (Recover2) {
    Recover2[(Recover2["Insert"] = 200)] = "Insert";
    Recover2[(Recover2["Delete"] = 190)] = "Delete";
    Recover2[(Recover2["Reduce"] = 100)] = "Reduce";
    Recover2[(Recover2["MaxNext"] = 4)] = "MaxNext";
    Recover2[(Recover2["MaxInsertStackDepth"] = 300)] = "MaxInsertStackDepth";
    Recover2[(Recover2["DampenInsertStackDepth"] = 120)] = "DampenInsertStackDepth";
  })(Recover || (Recover = {}));
  var SimulatedStack = class SimulatedStack {
    reduce(action) {
      var term = action & 65535,
        depth = action >> 19;
      if (depth == 0) {
        if (this.stack == this.start.stack) this.stack = this.stack.slice();
        this.stack.push(this.state, 0, 0);
        this.base += 3;
      } else {
        this.base -= (depth - 1) * 3;
      }
      var goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
      this.state = goto;
    }
    constructor(start) {
      this.start = start;
      this.state = start.state;
      this.stack = start.stack;
      this.base = this.stack.length;
    }
  };
  __name(SimulatedStack, "SimulatedStack");
  var StackBufferCursor = class StackBufferCursor1 {
    static create(stack) {
      var pos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : stack.bufferBase + stack.buffer.length;
      return new StackBufferCursor(stack, pos, pos - stack.bufferBase);
    }
    maybeNext() {
      var next = this.stack.parent;
      if (next != null) {
        this.index = this.stack.bufferBase - next.bufferBase;
        this.stack = next;
        this.buffer = next.buffer;
      }
    }
    get id() {
      return this.buffer[this.index - 4];
    }
    get start() {
      return this.buffer[this.index - 3];
    }
    get end() {
      return this.buffer[this.index - 2];
    }
    get size() {
      return this.buffer[this.index - 1];
    }
    next() {
      this.index -= 4;
      this.pos -= 4;
      if (this.index == 0) this.maybeNext();
    }
    fork() {
      return new StackBufferCursor(this.stack, this.pos, this.index);
    }
    constructor(stack, pos, index) {
      this.stack = stack;
      this.pos = pos;
      this.index = index;
      this.buffer = stack.buffer;
      if (this.index == 0) this.maybeNext();
    }
  };
  __name(StackBufferCursor, "StackBufferCursor");
  var CachedToken = class CachedToken {
    constructor() {
      this.start = -1;
      this.value = -1;
      this.end = -1;
      this.extended = -1;
      this.lookAhead = 0;
      this.mask = 0;
      this.context = 0;
    }
  };
  __name(CachedToken, "CachedToken");
  var nullToken = new CachedToken();
  var InputStream = class InputStream {
    resolveOffset(offset, assoc) {
      var range = this.range,
        index = this.rangeIndex;
      var pos = this.pos + offset;
      while (pos < range.from) {
        if (!index) return null;
        var next = this.ranges[--index];
        pos -= range.from - next.to;
        range = next;
      }
      while (assoc < 0 ? pos > range.to : pos >= range.to) {
        if (index == this.ranges.length - 1) return null;
        var next1 = this.ranges[++index];
        pos += next1.from - range.to;
        range = next1;
      }
      return pos;
    }
    clipPos(pos) {
      if (pos >= this.range.from && pos < this.range.to) return pos;
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.ranges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var range = _step.value;
          if (range.to > pos) return Math.max(pos, range.from);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return this.end;
    }
    peek(offset) {
      var idx = this.chunkOff + offset,
        pos,
        result;
      if (idx >= 0 && idx < this.chunk.length) {
        pos = this.pos + offset;
        result = this.chunk.charCodeAt(idx);
      } else {
        var resolved = this.resolveOffset(offset, 1);
        if (resolved == null) return -1;
        pos = resolved;
        if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
          result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
        } else {
          var i = this.rangeIndex,
            range = this.range;
          while (range.to <= pos) range = this.ranges[++i];
          this.chunk2 = this.input.chunk((this.chunk2Pos = pos));
          if (pos + this.chunk2.length > range.to) this.chunk2 = this.chunk2.slice(0, range.to - pos);
          result = this.chunk2.charCodeAt(0);
        }
      }
      if (pos >= this.token.lookAhead) this.token.lookAhead = pos + 1;
      return result;
    }
    acceptToken(token) {
      var endOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
      if (end == null || end < this.token.start) throw new RangeError("Token end out of bounds");
      this.token.value = token;
      this.token.end = end;
    }
    getChunk() {
      if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
        var _this = this,
          chunk = _this.chunk,
          chunkPos = _this.chunkPos;
        this.chunk = this.chunk2;
        this.chunkPos = this.chunk2Pos;
        this.chunk2 = chunk;
        this.chunk2Pos = chunkPos;
        this.chunkOff = this.pos - this.chunkPos;
      } else {
        this.chunk2 = this.chunk;
        this.chunk2Pos = this.chunkPos;
        var nextChunk = this.input.chunk(this.pos);
        var end = this.pos + nextChunk.length;
        this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
        this.chunkPos = this.pos;
        this.chunkOff = 0;
      }
    }
    readNext() {
      if (this.chunkOff >= this.chunk.length) {
        this.getChunk();
        if (this.chunkOff == this.chunk.length) return (this.next = -1);
      }
      return (this.next = this.chunk.charCodeAt(this.chunkOff));
    }
    advance() {
      var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
      this.chunkOff += n;
      while (this.pos + n >= this.range.to) {
        if (this.rangeIndex == this.ranges.length - 1) return this.setDone();
        n -= this.range.to - this.pos;
        this.range = this.ranges[++this.rangeIndex];
        this.pos = this.range.from;
      }
      this.pos += n;
      if (this.pos >= this.token.lookAhead) this.token.lookAhead = this.pos + 1;
      return this.readNext();
    }
    setDone() {
      this.pos = this.chunkPos = this.end;
      this.range = this.ranges[(this.rangeIndex = this.ranges.length - 1)];
      this.chunk = "";
      return (this.next = -1);
    }
    reset(pos, token) {
      if (token) {
        this.token = token;
        token.start = pos;
        token.lookAhead = pos + 1;
        token.value = token.extended = -1;
      } else {
        this.token = nullToken;
      }
      if (this.pos != pos) {
        this.pos = pos;
        if (pos == this.end) {
          this.setDone();
          return this;
        }
        while (pos < this.range.from) this.range = this.ranges[--this.rangeIndex];
        while (pos >= this.range.to) this.range = this.ranges[++this.rangeIndex];
        if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
          this.chunkOff = pos - this.chunkPos;
        } else {
          this.chunk = "";
          this.chunkOff = 0;
        }
        this.readNext();
      }
      return this;
    }
    read(from, to) {
      if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length) return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
      if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length) return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);
      if (from >= this.range.from && to <= this.range.to) return this.input.read(from, to);
      var result = "";
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.ranges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var r = _step.value;
          if (r.from >= to) break;
          if (r.to > from) result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return result;
    }
    constructor(input, ranges) {
      this.input = input;
      this.ranges = ranges;
      this.chunk = "";
      this.chunkOff = 0;
      this.chunk2 = "";
      this.chunk2Pos = 0;
      this.next = -1;
      this.token = nullToken;
      this.rangeIndex = 0;
      this.pos = this.chunkPos = ranges[0].from;
      this.range = ranges[0];
      this.end = ranges[ranges.length - 1].to;
      this.readNext();
    }
  };
  __name(InputStream, "InputStream");
  var TokenGroup = class TokenGroup {
    token(input, stack) {
      readToken(this.data, input, stack, this.id);
    }
    constructor(data, id) {
      this.data = data;
      this.id = id;
    }
  };
  __name(TokenGroup, "TokenGroup");
  TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
  function readToken(data, input, stack, group) {
    var state = 0,
      groupMask = 1 << group,
      _stack_p = stack.p,
      parser2 = _stack_p.parser,
      dialect = parser2.dialect;
    scan: for (;;) {
      if ((groupMask & data[state]) == 0) break;
      var accEnd = data[state + 1];
      for (var i = state + 3; i < accEnd; i += 2)
        if ((data[i + 1] & groupMask) > 0) {
          var term = data[i];
          if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || parser2.overrides(term, input.token.value))) {
            input.acceptToken(term);
            break;
          }
        }
      var next = input.next,
        low = 0,
        high = data[state + 2];
      if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535 && data[accEnd + high * 3 - 3] == 65535) {
        state = data[accEnd + high * 3 - 1];
        continue scan;
      }
      for (; low < high; ) {
        var mid = (low + high) >> 1;
        var index = accEnd + mid + (mid << 1);
        var from = data[index],
          to = data[index + 1] || 65536;
        if (next < from) high = mid;
        else if (next >= to) low = mid + 1;
        else {
          state = data[index + 2];
          input.advance();
          continue scan;
        }
      }
      break;
    }
  }
  __name(readToken, "readToken");
  function decodeArray(input) {
    var Type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Uint16Array;
    if (typeof input != "string") return input;
    var array = null;
    for (var pos = 0, out = 0; pos < input.length; ) {
      var value = 0;
      for (;;) {
        var next = input.charCodeAt(pos++),
          stop = false;
        if (next == 126) {
          value = 65535;
          break;
        }
        if (next >= 92) next--;
        if (next >= 34) next--;
        var digit = next - 32;
        if (digit >= 46) {
          digit -= 46;
          stop = true;
        }
        value += digit;
        if (stop) break;
        value *= 46;
      }
      if (array) array[out++] = value;
      else array = new Type(value);
    }
    return array;
  }
  __name(decodeArray, "decodeArray");
  var verbose = typeof process != "undefined" && process.env && /\bparse\b/.test(process.env.LOG);
  var stackIDs = null;
  var Safety;
  (function (Safety2) {
    Safety2[(Safety2["Margin"] = 25)] = "Margin";
  })(Safety || (Safety = {}));
  function cutAt(tree, pos, side) {
    var cursor = tree.cursor(IterMode.IncludeAnonymous);
    cursor.moveTo(pos);
    for (;;) {
      if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
        for (;;) {
          if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError) return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25)) : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25));
          if (side < 0 ? cursor.prevSibling() : cursor.nextSibling()) break;
          if (!cursor.parent()) return side < 0 ? 0 : tree.length;
        }
    }
  }
  __name(cutAt, "cutAt");
  var FragmentCursor = class FragmentCursor {
    nextFragment() {
      var fr = (this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++]);
      if (fr) {
        this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
        this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
        while (this.trees.length) {
          this.trees.pop();
          this.start.pop();
          this.index.pop();
        }
        this.trees.push(fr.tree);
        this.start.push(-fr.offset);
        this.index.push(0);
        this.nextStart = this.safeFrom;
      } else {
        this.nextStart = 1e9;
      }
    }
    nodeAt(pos) {
      if (pos < this.nextStart) return null;
      while (this.fragment && this.safeTo <= pos) this.nextFragment();
      if (!this.fragment) return null;
      for (;;) {
        var last = this.trees.length - 1;
        if (last < 0) {
          this.nextFragment();
          return null;
        }
        var top2 = this.trees[last],
          index = this.index[last];
        if (index == top2.children.length) {
          this.trees.pop();
          this.start.pop();
          this.index.pop();
          continue;
        }
        var next = top2.children[index];
        var start = this.start[last] + top2.positions[index];
        if (start > pos) {
          this.nextStart = start;
          return null;
        }
        if (next instanceof Tree) {
          if (start == pos) {
            if (start < this.safeFrom) return null;
            var end = start + next.length;
            if (end <= this.safeTo) {
              var lookAhead = next.prop(NodeProp.lookAhead);
              if (!lookAhead || end + lookAhead < this.fragment.to) return next;
            }
          }
          this.index[last]++;
          if (start + next.length >= Math.max(this.safeFrom, pos)) {
            this.trees.push(next);
            this.start.push(start);
            this.index.push(0);
          }
        } else {
          this.index[last]++;
          this.nextStart = start + next.length;
        }
      }
    }
    constructor(fragments, nodeSet) {
      this.fragments = fragments;
      this.nodeSet = nodeSet;
      this.i = 0;
      this.fragment = null;
      this.safeFrom = -1;
      this.safeTo = -1;
      this.trees = [];
      this.start = [];
      this.index = [];
      this.nextFragment();
    }
  };
  __name(FragmentCursor, "FragmentCursor");
  var TokenCache = class TokenCache {
    getActions(stack) {
      var actionIndex = 0;
      var main = null;
      var _stack_p = stack.p,
        parser2 = _stack_p.parser,
        tokenizers = parser2.tokenizers;
      var mask = parser2.stateSlot(stack.state, 3);
      var context = stack.curContext ? stack.curContext.hash : 0;
      var lookAhead = 0;
      for (var i = 0; i < tokenizers.length; i++) {
        if (((1 << i) & mask) == 0) continue;
        var tokenizer = tokenizers[i],
          token = this.tokens[i];
        if (main && !tokenizer.fallback) continue;
        if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
          this.updateCachedToken(token, tokenizer, stack);
          token.mask = mask;
          token.context = context;
        }
        if (token.lookAhead > token.end + 25) lookAhead = Math.max(token.lookAhead, lookAhead);
        if (token.value != 0) {
          var startIndex = actionIndex;
          if (token.extended > -1) actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
          actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
          if (!tokenizer.extend) {
            main = token;
            if (actionIndex > startIndex) break;
          }
        }
      }
      while (this.actions.length > actionIndex) this.actions.pop();
      if (lookAhead) stack.setLookAhead(lookAhead);
      if (!main && stack.pos == this.stream.end) {
        main = new CachedToken();
        main.value = stack.p.parser.eofTerm;
        main.start = main.end = stack.pos;
        actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
      }
      this.mainToken = main;
      return this.actions;
    }
    getMainToken(stack) {
      if (this.mainToken) return this.mainToken;
      var main = new CachedToken(),
        pos = stack.pos,
        p = stack.p;
      main.start = pos;
      main.end = Math.min(pos + 1, p.stream.end);
      main.value = pos == p.stream.end ? p.parser.eofTerm : 0;
      return main;
    }
    updateCachedToken(token, tokenizer, stack) {
      var start = this.stream.clipPos(stack.pos);
      tokenizer.token(this.stream.reset(start, token), stack);
      if (token.value > -1) {
        var _stack_p = stack.p,
          parser2 = _stack_p.parser;
        for (var i = 0; i < parser2.specialized.length; i++)
          if (parser2.specialized[i] == token.value) {
            var result = parser2.specializers[i](this.stream.read(token.start, token.end), stack);
            if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
              if ((result & 1) == 0) token.value = result >> 1;
              else token.extended = result >> 1;
              break;
            }
          }
      } else {
        token.value = 0;
        token.end = this.stream.clipPos(start + 1);
      }
    }
    putAction(action, token, end, index) {
      for (var i = 0; i < index; i += 3) if (this.actions[i] == action) return index;
      this.actions[index++] = action;
      this.actions[index++] = token;
      this.actions[index++] = end;
      return index;
    }
    addActions(stack, token, end, index) {
      var state = stack.state,
        _stack_p = stack.p,
        parser2 = _stack_p.parser,
        data = parser2.data;
      for (var set = 0; set < 2; set++) {
        for (var i = parser2.stateSlot(state, set ? 2 : 1); ; i += 3) {
          if (data[i] == 65535) {
            if (data[i + 1] == 1) {
              i = pair(data, i + 2);
            } else {
              if (index == 0 && data[i + 1] == 2) index = this.putAction(pair(data, i + 2), token, end, index);
              break;
            }
          }
          if (data[i] == token) index = this.putAction(pair(data, i + 1), token, end, index);
        }
      }
      return index;
    }
    constructor(parser2, stream) {
      this.stream = stream;
      this.tokens = [];
      this.mainToken = null;
      this.actions = [];
      this.tokens = parser2.tokenizers.map((_) => new CachedToken());
    }
  };
  __name(TokenCache, "TokenCache");
  var Rec;
  (function (Rec2) {
    Rec2[(Rec2["Distance"] = 5)] = "Distance";
    Rec2[(Rec2["MaxRemainingPerStep"] = 3)] = "MaxRemainingPerStep";
    Rec2[(Rec2["MinBufferLengthPrune"] = 500)] = "MinBufferLengthPrune";
    Rec2[(Rec2["ForceReduceLimit"] = 10)] = "ForceReduceLimit";
    Rec2[(Rec2["CutDepth"] = 15e3)] = "CutDepth";
    Rec2[(Rec2["CutTo"] = 9e3)] = "CutTo";
  })(Rec || (Rec = {}));
  var Parse = class Parse {
    get parsedPos() {
      return this.minStackPos;
    }
    advance() {
      var stacks = this.stacks,
        pos = this.minStackPos;
      var newStacks = (this.stacks = []);
      var stopped, stoppedTokens;
      for (var i = 0; i < stacks.length; i++) {
        var stack = stacks[i];
        for (;;) {
          this.tokens.mainToken = null;
          if (stack.pos > pos) {
            newStacks.push(stack);
          } else if (this.advanceStack(stack, newStacks, stacks)) {
            continue;
          } else {
            if (!stopped) {
              stopped = [];
              stoppedTokens = [];
            }
            stopped.push(stack);
            var tok = this.tokens.getMainToken(stack);
            stoppedTokens.push(tok.value, tok.end);
          }
          break;
        }
      }
      if (!newStacks.length) {
        var finished = stopped && findFinished(stopped);
        if (finished) return this.stackToTree(finished);
        if (this.parser.strict) {
          if (verbose && stopped) console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
          throw new SyntaxError("No parse at " + pos);
        }
        if (!this.recovering) this.recovering = 5;
      }
      if (this.recovering && stopped) {
        var finished1 = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);
        if (finished1) return this.stackToTree(finished1.forceAll());
      }
      if (this.recovering) {
        var maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;
        if (newStacks.length > maxRemaining) {
          newStacks.sort((a, b) => b.score - a.score);
          while (newStacks.length > maxRemaining) newStacks.pop();
        }
        if (newStacks.some((s) => s.reducePos > pos)) this.recovering--;
      } else if (newStacks.length > 1) {
        outer: for (var i1 = 0; i1 < newStacks.length - 1; i1++) {
          var stack1 = newStacks[i1];
          for (var j = i1 + 1; j < newStacks.length; j++) {
            var other = newStacks[j];
            if (stack1.sameState(other) || (stack1.buffer.length > 500 && other.buffer.length > 500)) {
              if ((stack1.score - other.score || stack1.buffer.length - other.buffer.length) > 0) {
                newStacks.splice(j--, 1);
              } else {
                newStacks.splice(i1--, 1);
                continue outer;
              }
            }
          }
        }
      }
      this.minStackPos = newStacks[0].pos;
      for (var i2 = 1; i2 < newStacks.length; i2++) if (newStacks[i2].pos < this.minStackPos) this.minStackPos = newStacks[i2].pos;
      return null;
    }
    stopAt(pos) {
      if (this.stoppedAt != null && this.stoppedAt < pos) throw new RangeError("Can't move stoppedAt forward");
      this.stoppedAt = pos;
    }
    advanceStack(stack, stacks, split) {
      var start = stack.pos,
        _this = this,
        parser2 = _this.parser;
      var base2 = verbose ? this.stackID(stack) + " -> " : "";
      if (this.stoppedAt != null && start > this.stoppedAt) return stack.forceReduce() ? stack : null;
      if (this.fragments) {
        var strictCx = stack.curContext && stack.curContext.tracker.strict,
          cxHash = strictCx ? stack.curContext.hash : 0;
        for (var cached = this.fragments.nodeAt(start); cached; ) {
          var match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser2.getGoto(stack.state, cached.type.id) : -1;
          if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {
            stack.useNode(cached, match);
            if (verbose) console.log(base2 + this.stackID(stack) + " (via reuse of ".concat(parser2.getName(cached.type.id), ")"));
            return true;
          }
          if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0) break;
          var inner = cached.children[0];
          if (inner instanceof Tree && cached.positions[0] == 0) cached = inner;
          else break;
        }
      }
      var defaultReduce = parser2.stateSlot(stack.state, 4);
      if (defaultReduce > 0) {
        stack.reduce(defaultReduce);
        if (verbose) console.log(base2 + this.stackID(stack) + " (via always-reduce ".concat(parser2.getName(defaultReduce & 65535), ")"));
        return true;
      }
      if (stack.stack.length >= 15e3) {
        while (stack.stack.length > 9e3 && stack.forceReduce()) {}
      }
      var actions = this.tokens.getActions(stack);
      for (var i = 0; i < actions.length; ) {
        var action = actions[i++],
          term = actions[i++],
          end = actions[i++];
        var last = i == actions.length || !split;
        var localStack = last ? stack : stack.split();
        localStack.apply(action, term, end);
        if (verbose)
          console.log(
            base2 +
              this.stackID(localStack) +
              " (via "
                .concat((action & 65536) == 0 ? "shift" : "reduce of ".concat(parser2.getName(action & 65535)), " for ")
                .concat(parser2.getName(term), " @ ")
                .concat(start)
                .concat(localStack == stack ? "" : ", split", ")")
          );
        if (last) return true;
        else if (localStack.pos > start) stacks.push(localStack);
        else split.push(localStack);
      }
      return false;
    }
    advanceFully(stack, newStacks) {
      var pos = stack.pos;
      for (;;) {
        if (!this.advanceStack(stack, null, null)) return false;
        if (stack.pos > pos) {
          pushStackDedup(stack, newStacks);
          return true;
        }
      }
    }
    runRecovery(stacks, tokens, newStacks) {
      var finished = null,
        restarted = false;
      for (var i = 0; i < stacks.length; i++) {
        var stack = stacks[i],
          token = tokens[i << 1],
          tokenEnd = tokens[(i << 1) + 1];
        var base2 = verbose ? this.stackID(stack) + " -> " : "";
        if (stack.deadEnd) {
          if (restarted) continue;
          restarted = true;
          stack.restart();
          if (verbose) console.log(base2 + this.stackID(stack) + " (restarted)");
          var done = this.advanceFully(stack, newStacks);
          if (done) continue;
        }
        var force = stack.split(),
          forceBase = base2;
        for (var j = 0; force.forceReduce() && j < 10; j++) {
          if (verbose) console.log(forceBase + this.stackID(force) + " (via force-reduce)");
          var done1 = this.advanceFully(force, newStacks);
          if (done1) break;
          if (verbose) forceBase = this.stackID(force) + " -> ";
        }
        var _iteratorNormalCompletion = true,
          _didIteratorError = false,
          _iteratorError = undefined;
        try {
          for (var _iterator = stack.recoverByInsert(token)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var insert3 = _step.value;
            if (verbose) console.log(base2 + this.stackID(insert3) + " (via recover-insert)");
            this.advanceFully(insert3, newStacks);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        if (this.stream.end > stack.pos) {
          if (tokenEnd == stack.pos) {
            tokenEnd++;
            token = 0;
          }
          stack.recoverByDelete(token, tokenEnd);
          if (verbose) console.log(base2 + this.stackID(stack) + " (via recover-delete ".concat(this.parser.getName(token), ")"));
          pushStackDedup(stack, newStacks);
        } else if (!finished || finished.score < stack.score) {
          finished = stack;
        }
      }
      return finished;
    }
    stackToTree(stack) {
      stack.close();
      return Tree.build({
        buffer: StackBufferCursor.create(stack),
        nodeSet: this.parser.nodeSet,
        topID: this.topTerm,
        maxBufferLength: this.parser.bufferLength,
        reused: this.reused,
        start: this.ranges[0].from,
        length: stack.pos - this.ranges[0].from,
        minRepeatType: this.parser.minRepeatTerm,
      });
    }
    stackID(stack) {
      var id = (stackIDs || (stackIDs = /* @__PURE__ */ new WeakMap())).get(stack);
      if (!id) stackIDs.set(stack, (id = String.fromCodePoint(this.nextStackID++)));
      return id + stack;
    }
    constructor(parser2, input, fragments, ranges) {
      this.parser = parser2;
      this.input = input;
      this.ranges = ranges;
      this.recovering = 0;
      this.nextStackID = 9812;
      this.minStackPos = 0;
      this.reused = [];
      this.stoppedAt = null;
      this.stream = new InputStream(input, ranges);
      this.tokens = new TokenCache(parser2, this.stream);
      this.topTerm = parser2.top[1];
      var from = ranges[0].from;
      this.stacks = [Stack.start(this, parser2.top[0], from)];
      this.fragments = fragments.length && this.stream.end - from > parser2.bufferLength * 4 ? new FragmentCursor(fragments, parser2.nodeSet) : null;
    }
  };
  __name(Parse, "Parse");
  function pushStackDedup(stack, newStacks) {
    for (var i = 0; i < newStacks.length; i++) {
      var other = newStacks[i];
      if (other.pos == stack.pos && other.sameState(stack)) {
        if (newStacks[i].score < stack.score) newStacks[i] = stack;
        return;
      }
    }
    newStacks.push(stack);
  }
  __name(pushStackDedup, "pushStackDedup");
  var Dialect = class Dialect {
    allows(term) {
      return !this.disabled || this.disabled[term] == 0;
    }
    constructor(source, flags, disabled) {
      this.source = source;
      this.flags = flags;
      this.disabled = disabled;
    }
  };
  __name(Dialect, "Dialect");
  var LRParser = class LRParser1 extends Parser {
    createParse(input, fragments, ranges) {
      var parse = new Parse(this, input, fragments, ranges);
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      try {
        for (var _iterator = this.wrappers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var w = _step.value;
          parse = w(parse, input, fragments, ranges);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return parse;
    }
    getGoto(state, term) {
      var loose = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var table = this.goto;
      if (term >= table[0]) return -1;
      for (var pos = table[term + 1]; ; ) {
        var groupTag = table[pos++],
          last = groupTag & 1;
        var target = table[pos++];
        if (last && loose) return target;
        for (var end = pos + (groupTag >> 1); pos < end; pos++) if (table[pos] == state) return target;
        if (last) return -1;
      }
    }
    hasAction(state, terminal) {
      var data = this.data;
      for (var set = 0; set < 2; set++) {
        for (var i = this.stateSlot(state, set ? 2 : 1), next = void 0; ; i += 3) {
          if ((next = data[i]) == 65535) {
            if (data[i + 1] == 1) next = data[(i = pair(data, i + 2))];
            else if (data[i + 1] == 2) return pair(data, i + 2);
            else break;
          }
          if (next == terminal || next == 0) return pair(data, i + 1);
        }
      }
      return 0;
    }
    stateSlot(state, slot) {
      return this.states[state * 6 + slot];
    }
    stateFlag(state, flag) {
      return (this.stateSlot(state, 0) & flag) > 0;
    }
    validAction(state, action) {
      if (action == this.stateSlot(state, 4)) return true;
      for (var i = this.stateSlot(state, 1); ; i += 3) {
        if (this.data[i] == 65535) {
          if (this.data[i + 1] == 1) i = pair(this.data, i + 2);
          else return false;
        }
        if (action == pair(this.data, i + 1)) return true;
      }
    }
    nextStates(state) {
      var _this = this,
        _loop = function (i1) {
          if (_this.data[i1] == 65535) {
            if (_this.data[i1 + 1] == 1) i1 = pair(_this.data, i1 + 2);
            else return (i = i1), "break";
          }
          if ((_this.data[i1 + 2] & (65536 >> 16)) == 0) {
            var value = _this.data[i1 + 1];
            if (!result.some((v, i2) => i2 & 1 && v == value)) result.push(_this.data[i1], value);
          }
          (i = i1), void 0;
        };
      var result = [];
      for (var i = this.stateSlot(state, 1); ; i += 3) {
        var _ret = _loop(i);
        if (_ret === "break") break;
      }
      return result;
    }
    overrides(token, prev) {
      var iPrev = findOffset(this.data, this.tokenPrecTable, prev);
      return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;
    }
    configure(config) {
      var copy = Object.assign(Object.create(LRParser.prototype), this);
      if (config.props) copy.nodeSet = this.nodeSet.extend(...config.props);
      if (config.top) {
        var info = this.topRules[config.top];
        if (!info) throw new RangeError("Invalid top rule name ".concat(config.top));
        copy.top = info;
      }
      if (config.tokenizers)
        copy.tokenizers = this.tokenizers.map((t2) => {
          var found = config.tokenizers.find((r) => r.from == t2);
          return found ? found.to : t2;
        });
      if (config.specializers) {
        copy.specializers = this.specializers.slice();
        copy.specializerSpecs = this.specializerSpecs.map((s, i) => {
          var found = config.specializers.find((r) => r.from == s.external);
          if (!found) return s;
          var spec = Object.assign(Object.assign({}, s), {
            external: found.to,
          });
          copy.specializers[i] = getSpecializer(spec);
          return spec;
        });
      }
      if (config.contextTracker) copy.context = config.contextTracker;
      if (config.dialect) copy.dialect = this.parseDialect(config.dialect);
      if (config.strict != null) copy.strict = config.strict;
      if (config.wrap) copy.wrappers = copy.wrappers.concat(config.wrap);
      if (config.bufferLength != null) copy.bufferLength = config.bufferLength;
      return copy;
    }
    hasWrappers() {
      return this.wrappers.length > 0;
    }
    getName(term) {
      return this.termNames ? this.termNames[term] : String((term <= this.maxNode && this.nodeSet.types[term].name) || term);
    }
    get eofTerm() {
      return this.maxNode + 1;
    }
    get topNode() {
      return this.nodeSet.types[this.top[1]];
    }
    dynamicPrecedence(term) {
      var prec2 = this.dynamicPrecedences;
      return prec2 == null ? 0 : prec2[term] || 0;
    }
    parseDialect(dialect) {
      var values = Object.keys(this.dialects),
        flags = values.map(() => false);
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      if (dialect)
        try {
          for (var _iterator = dialect.split(" ")[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var part = _step.value;
            var id = values.indexOf(part);
            if (id >= 0) flags[id] = true;
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      var disabled = null;
      for (var i = 0; i < values.length; i++)
        if (!flags[i]) {
          for (var j = this.dialects[values[i]], id1 = void 0; (id1 = this.data[j++]) != 65535; ) (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id1] = 1;
        }
      return new Dialect(dialect, flags, disabled);
    }
    static deserialize(spec) {
      return new LRParser(spec);
    }
    constructor(spec) {
      super();
      this.wrappers = [];
      if (spec.version != 14) throw new RangeError("Parser version (".concat(spec.version, ") doesn't match runtime version (", 14, ")"));
      var nodeNames = spec.nodeNames.split(" ");
      this.minRepeatTerm = nodeNames.length;
      for (var i = 0; i < spec.repeatNodeCount; i++) nodeNames.push("");
      var topTerms = Object.keys(spec.topRules).map((r) => spec.topRules[r][1]);
      var nodeProps = [];
      for (var i1 = 0; i1 < nodeNames.length; i1++) nodeProps.push([]);
      function setProp(nodeID, prop, value) {
        nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
      }
      __name(setProp, "setProp");
      var _iteratorNormalCompletion = true,
        _didIteratorError = false,
        _iteratorError = undefined;
      if (spec.nodeProps)
        try {
          for (var _iterator = spec.nodeProps[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var propSpec = _step.value;
            var prop = propSpec[0];
            if (typeof prop == "string") prop = NodeProp[prop];
            for (var i2 = 1; i2 < propSpec.length; ) {
              var next = propSpec[i2++];
              if (next >= 0) {
                setProp(next, prop, propSpec[i2++]);
              } else {
                var value = propSpec[i2 + -next];
                for (var j = -next; j > 0; j--) setProp(propSpec[i2++], prop, value);
                i2++;
              }
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      this.nodeSet = new NodeSet(
        nodeNames.map((name2, i) =>
          NodeType.define({
            name: i >= this.minRepeatTerm ? void 0 : name2,
            id: i,
            props: nodeProps[i],
            top: topTerms.indexOf(i) > -1,
            error: i == 0,
            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1,
          })
        )
      );
      if (spec.propSources) this.nodeSet = this.nodeSet.extend(...spec.propSources);
      this.strict = false;
      this.bufferLength = DefaultBufferLength;
      var tokenArray = decodeArray(spec.tokenData);
      this.context = spec.context;
      this.specializerSpecs = spec.specialized || [];
      this.specialized = new Uint16Array(this.specializerSpecs.length);
      for (var i3 = 0; i3 < this.specializerSpecs.length; i3++) this.specialized[i3] = this.specializerSpecs[i3].term;
      this.specializers = this.specializerSpecs.map(getSpecializer);
      this.states = decodeArray(spec.states, Uint32Array);
      this.data = decodeArray(spec.stateData);
      this.goto = decodeArray(spec.goto);
      this.maxTerm = spec.maxTerm;
      this.tokenizers = spec.tokenizers.map((value) => (typeof value == "number" ? new TokenGroup(tokenArray, value) : value));
      this.topRules = spec.topRules;
      this.dialects = spec.dialects || {};
      this.dynamicPrecedences = spec.dynamicPrecedences || null;
      this.tokenPrecTable = spec.tokenPrec;
      this.termNames = spec.termNames || null;
      this.maxNode = this.nodeSet.types.length - 1;
      this.dialect = this.parseDialect();
      this.top = this.topRules[Object.keys(this.topRules)[0]];
    }
  };
  __name(LRParser, "LRParser");
  function pair(data, off) {
    return data[off] | (data[off + 1] << 16);
  }
  __name(pair, "pair");
  function findOffset(data, start, term) {
    for (var i = start, next; (next = data[i]) != 65535; i++) if (next == term) return i - start;
    return -1;
  }
  __name(findOffset, "findOffset");
  function findFinished(stacks) {
    var best = null;
    var _iteratorNormalCompletion = true,
      _didIteratorError = false,
      _iteratorError = undefined;
    try {
      for (var _iterator = stacks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var stack = _step.value;
        var stopped = stack.p.stoppedAt;
        if ((stack.pos == stack.p.stream.end || (stopped != null && stack.pos > stopped)) && stack.p.parser.stateFlag(stack.state, 2) && (!best || best.score < stack.score)) best = stack;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    return best;
  }
  __name(findFinished, "findFinished");
  function getSpecializer(spec) {
    if (spec.external) {
      var mask = spec.extend ? 1 : 0;
      return (value, stack) => (spec.external(value, stack) << 1) | mask;
    }
    return spec.get;
  }
  __name(getSpecializer, "getSpecializer");
  // src/ui/codemirrorExtensions/bibtex.ts
  var parser = LRParser.deserialize({
    version: 14,
    states:
      "'[QVQPOOOhQPO'#CsOmQPO'#CwOrQPO'#CzOOQO'#Cp'#CpOOQO'#Ci'#CiQVQPOOOwQPO'#CpO|QQO,59_O![QQO,59cO!aQSO,59fOOQO-E6g-E6gO!fQWO'#C_OOQO,59[,59[OOQO'#Cu'#CuO!qQPO'#CtO!|QPO1G.yO#RQPO'#CxO#WQPO1G.}O#]QPO1G/QO#bQWO'#CjO#mQPO,58yOOQO,58y,58yO#mQPO,58yO|QQO'#CkO#uQPO,59`OOQO7+$e7+$eO|QQO,59dOOQO7+$i7+$iO![QQO7+$lOOQO,59U,59UOOQO-E6h-E6hOOQO1G.e1G.eO$QQPO1G.eOOQO,59V,59VOOQO-E6i-E6iOOQO1G/O1G/OO$YQPO<<HWOOQO7+$P7+$PO$bQQOAN=rO$jQPOAN=rOOQOAN=rAN=rOOQO,59W,59WOOQOG23^G23^O$rQQOG23^OOQO-E6j-E6jOOQOLD(xLD(xP![QQO'#Cl",
    stateData: "$z~OcOS~OQVOTPOXQOYRO[SO~OeWO~OeXO~OeYO~Oe[O~OU^OV^OW^Oe[O~OWaO~OZcO~OSgOe[OffO~OjhOfhXohX~OfjO~OmkO~OflO~OomO~OSnOe^Xf^X~Oe[OfpO~OjhOfhaoha~Oe[OfvO~OfyOowO~OWaOf{O~Of{Oo|O~OWaOf!OO~O",
    goto: "#^oPPPpPPPPPPPPP!O!U!`!fPPP!lPP!p!t!zP!p#RP!pQ]VU^WhkXd[egqQUORZUQe[SoeqRqgQi_RsiQxuR}xTTOUTSOUQ`WRtkS_WkRrhQbXQumVzw|!P",
    nodeNames: " Program CommentCommand Braced BraceContent PreambleCommand Quoted Number Identifier StringCommand Command Key Comment",
    maxTerm: 31,
    skippedNodes: [0],
    repeatNodeCount: 4,
    tokenData:
      "!<f~R|OX#{X^$g^p#{pq$gqr#{rs&]st+[t|#{|}+r}!Q#{!Q![,Y![!_#{!_!`,v!`!b#{!b!c-^!c!}Kx!}#R#{#R#SKx#S#T#{#T#bKx#b#cNO#c#oKx#o#p!<[#p#q#{#q#r!<a#r#y#{#y#z$g#z$f#{$f$g$g$g#BY#{#BY#BZ$g#BZ$IS#{$IS$I_$g$I_$I|#{$I|$JO$g$JO$JT#{$JT$JU$g$JU$KV#{$KV$KW$g$KW&FU#{&FU&FV$g&FV;'S#{;'S;=`$a<%lO#{W$QTSWO#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{W$dP;=`<%l#{~$niSWc~OX#{X^$g^p#{pq$gq#o#{#p#q#{#r#y#{#y#z$g#z$f#{$f$g$g$g#BY#{#BY#BZ$g#BZ$IS#{$IS$I_$g$I_$I|#{$I|$JO$g$JO$JT#{$JT$JU$g$JU$KV#{$KV$KW$g$KW&FU#{&FU&FV$g&FV;'S#{;'S;=`$a<%lO#{Y&bZSWOr&]rs'Ts#O&]#O#P'k#P#o&]#o#p)]#p#q&]#q#r)]#r;'S&];'S;=`+U<%lO&]Y'[TUQSWO#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{Y'pZSWOr&]rs(cs#O&]#O#P'k#P#o&]#o#p)]#p#q&]#q#r)]#r;'S&];'S;=`+U<%lO&]Y(jZUQSWOr&]rs'Ts#O&]#O#P'k#P#o&]#o#p)]#p#q&]#q#r)]#r;'S&];'S;=`+U<%lO&]Q)`VOr)]rs)us#O)]#O#P)z#P;'S)];'S;=`+O<%lO)]Q)zOUQQ)}VOr)]rs*ds#O)]#O#P)z#P;'S)];'S;=`+O<%lO)]Q*iVUQOr)]rs)us#O)]#O#P)z#P;'S)];'S;=`+O<%lO)]Q+RP;=`<%l)]Y+XP;=`<%l&]X+cTjPSWO#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X+yToPSWO#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{Y,aVVQSWO!Q#{!Q![,Y![#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X,}TmPSWO#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{~-cfSWO!c#{!c!e.w!e!f0{!f!r.w!r!s9|!s!u.w!u!vDW!v!}.w!}#R#{#R#S.w#S#T#{#T#V.w#V#W0{#W#d.w#d#e9|#e#g.w#g#hDW#h#o.w#p#q#{#r;'S#{;'S;=`$a<%lO#{~.|^SWO}#{}!O/x!O!Q#{!Q![/x![!c#{!c!}/x!}#R#{#R#S/x#S#T#{#T#o/x#p#q#{#r;'S#{;'S;=`$a<%lO#{~0P^Y~SWO}#{}!O/x!O!Q#{!Q![/x![!c#{!c!}/x!}#R#{#R#S/x#S#T#{#T#o/x#p#q#{#r;'S#{;'S;=`$a<%lO#{~1QbSWO}#{}!O/x!O!Q#{!Q![/x![!c#{!c!q/x!q!r2Y!r!}/x!}#R#{#R#S/x#S#T#{#T#c/x#c#d2Y#d#o/x#p#q#{#r;'S#{;'S;=`$a<%lO#{~2abY~SWO}#{}!O/x!O!Q#{!Q![/x![!c#{!c!o/x!o!p3i!p!}/x!}#R#{#R#S/x#S#T#{#T#a/x#a#b3i#b#o/x#p#q#{#r;'S#{;'S;=`$a<%lO#{~3pbY~SWO}#{}!O/x!O!Q#{!Q![/x![!c#{!c!o/x!o!p4x!p!}/x!}#R#{#R#S/x#S#T#{#T#a/x#a#b4x#b#o/x#p#q#{#r;'S#{;'S;=`$a<%lO#{~5PbY~SWO}#{}!O/x!O!Q#{!Q![/x![!c#{!c!g/x!g!h6X!h!}/x!}#R#{#R#S/x#S#T#{#T#X/x#X#Y6X#Y#o/x#p#q#{#r;'S#{;'S;=`$a<%lO#{~6`bY~SWO}#{}!O/x!O!Q#{!Q![/x![!c#{!c!p/x!p!q7h!q!}/x!}#R#{#R#S/x#S#T#{#T#b/x#b#c7h#c#o/x#p#q#{#r;'S#{;'S;=`$a<%lO#{~7obY~SWO}#{}!O/x!O!Q#{!Q![/x![!c#{!c!v/x!v!w8w!w!}/x!}#R#{#R#S/x#S#T#{#T#h/x#h#i8w#i#o/x#p#q#{#r;'S#{;'S;=`$a<%lO#{~9Q^Q~Y~SWO}#{}!O/x!O!Q#{!Q![/x![!c#{!c!}/x!}#R#{#R#S/x#S#T#{#T#o/x#p#q#{#r;'S#{;'S;=`$a<%lO#{~:RbSWO}#{}!O/x!O!Q#{!Q![/x![!c#{!c!t/x!t!u;Z!u!}/x!}#R#{#R#S/x#S#T#{#T#f/x#f#g;Z#g#o/x#p#q#{#r;'S#{;'S;=`$a<%lO#{~;bbY~SWO}#{}!O/x!O!Q#{!Q![/x![!c#{!c!g/x!g!h<j!h!}/x!}#R#{#R#S/x#S#T#{#T#X/x#X#Y<j#Y#o/x#p#q#{#r;'S#{;'S;=`$a<%lO#{~<q`Y~SWO}#{}!O/x!O!Q#{!Q![/x![!c#{!c!d=s!d!}/x!}#R#{#R#S/x#S#T#{#T#U=s#U#o/x#p#q#{#r;'S#{;'S;=`$a<%lO#{~=zbY~SWO}#{}!O/x!O!Q#{!Q![/x![!c#{!c!o/x!o!p?S!p!}/x!}#R#{#R#S/x#S#T#{#T#a/x#a#b?S#b#o/x#p#q#{#r;'S#{;'S;=`$a<%lO#{~?ZbY~SWO}#{}!O/x!O!Q#{!Q![/x![!c#{!c!d/x!d!e@c!e!}/x!}#R#{#R#S/x#S#T#{#T#U/x#U#V@c#V#o/x#p#q#{#r;'S#{;'S;=`$a<%lO#{~@jbY~SWO}#{}!O/x!O!Q#{!Q![/x![!c#{!c!n/x!n!oAr!o!}/x!}#R#{#R#S/x#S#T#{#T#`/x#`#aAr#a#o/x#p#q#{#r;'S#{;'S;=`$a<%lO#{~AybY~SWO}#{}!O/x!O!Q#{!Q![/x![!c#{!c!g/x!g!hCR!h!}/x!}#R#{#R#S/x#S#T#{#T#X/x#X#YCR#Y#o/x#p#q#{#r;'S#{;'S;=`$a<%lO#{~C[^T~Y~SWO}#{}!O/x!O!Q#{!Q![/x![!c#{!c!}/x!}#R#{#R#S/x#S#T#{#T#o/x#p#q#{#r;'S#{;'S;=`$a<%lO#{~D]bSWO}#{}!O/x!O!Q#{!Q![/x![!c#{!c!v/x!v!wEe!w!}/x!}#R#{#R#S/x#S#T#{#T#h/x#h#iEe#i#o/x#p#q#{#r;'S#{;'S;=`$a<%lO#{~ElbY~SWO}#{}!O/x!O!Q#{!Q![/x![!c#{!c!t/x!t!uFt!u!}/x!}#R#{#R#S/x#S#T#{#T#f/x#f#gFt#g#o/x#p#q#{#r;'S#{;'S;=`$a<%lO#{~F{bY~SWO}#{}!O/x!O!Q#{!Q![/x![!c#{!c!k/x!k!lHT!l!}/x!}#R#{#R#S/x#S#T#{#T#]/x#]#^HT#^#o/x#p#q#{#r;'S#{;'S;=`$a<%lO#{~H[bY~SWO}#{}!O/x!O!Q#{!Q![/x![!c#{!c!p/x!p!qId!q!}/x!}#R#{#R#S/x#S#T#{#T#b/x#b#cId#c#o/x#p#q#{#r;'S#{;'S;=`$a<%lO#{~IkbY~SWO}#{}!O/x!O!Q#{!Q![/x![!c#{!c!i/x!i!jJs!j!}/x!}#R#{#R#S/x#S#T#{#T#Z/x#Z#[Js#[#o/x#p#q#{#r;'S#{;'S;=`$a<%lO#{~J|^X~Y~SWO}#{}!O/x!O!Q#{!Q![/x![!c#{!c!}/x!}#R#{#R#S/x#S#T#{#T#o/x#p#q#{#r;'S#{;'S;=`$a<%lO#{^K}^SWO}#{}!OLy!O!Q#{!Q![Ly![!c#{!c!}Ly!}#R#{#R#SLy#S#T#{#T#oLy#p#q#{#r;'S#{;'S;=`$a<%lO#{^MS^WQZSSWO}#{}!OLy!O!Q#{!Q![Ly![!c#{!c!}Ly!}#R#{#R#SLy#S#T#{#T#oLy#p#q#{#r;'S#{;'S;=`$a<%lO#{_NT`SWO}#{}!OLy!O!Q#{!Q![Ly![!c#{!c!}Ly!}#R#{#R#SLy#S#T#{#T#cLy#c#d! V#d#oLy#p#q#{#r;'S#{;'S;=`$a<%lO#{_! ``WQZSSWOp#{pq!!bq}#{}!OLy!O!Q#{!Q![Ly![!c#{!c!}Ly!}#R#{#R#SLy#S#T#{#T#oLy#p#q#{#r;'S#{;'S;=`$a<%lO#{X!!gVSWO#]#{#]#^!!|#^#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!#RVSWO#W#{#W#X!#h#X#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!#mVSWO#X#{#X#Y!$S#Y#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!$XVSWO#T#{#T#U!$n#U#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!$sVSWOp#{pq!%Yq#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!%_VSWO#k#{#k#l!%t#l#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!%yVSWO#[#{#[#]!&`#]#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!&eVSWO#m#{#m#n!&z#n#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!'PVSWOp#{pq!'fq#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!'kVSWO#h#{#h#i!(Q#i#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!(VVSWO#[#{#[#]!(l#]#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!(qVSWO#]#{#]#^!)W#^#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!)]VSWO#g#{#g#h!)r#h#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!)wVSWOp#{pq!*^q#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!*cVSWO#g#{#g#h!*x#h#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!*}VSWO#h#{#h#i!+d#i#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!+iVSWO#f#{#f#g!,O#g#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!,TVSWO#]#{#]#^!,j#^#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!,oVSWO#b#{#b#c!-U#c#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!-ZVSWO#Z#{#Z#[!-p#[#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!-uVSWOp#{pq!.[q#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!.aVSWO#]#{#]#^!.v#^#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!.{VSWO#g#{#g#h!/b#h#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!/gVSWOp#{pq!/|q#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!0RVSWO#b#{#b#c!0h#c#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!0mVSWO#X#{#X#Y!1S#Y#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!1XVSWO#X#{#X#Y!1n#Y#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!1sVSWO#W#{#W#X!2Y#X#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!2_VSWO#X#{#X#Y!2t#Y#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!2yVSWO#W#{#W#X!3`#X#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!3eVSWOp#{pq!3zq#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!4PVSWO#U#{#U#V!4f#V#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!4kVSWO#i#{#i#j!5Q#j#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!5VVSWO#h#{#h#i!5l#i#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!5qVSWOp#{pq!6Wq#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!6]VSWO#k#{#k#l!6r#l#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!6wVSWO#[#{#[#]!7^#]#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!7cVSWO#T#{#T#U!7x#U#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!7}VSWO#h#{#h#i!8d#i#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!8iVSWO#X#{#X#Y!9O#Y#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!9TVSWO#j#{#j#k!9j#k#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!9oVSWO#X#{#X#Y!:U#Y#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!:ZVSWO#f#{#f#g!:p#g#o#{#p#q#{#r;'S#{;'S;=`$a<%lO#{X!:uXSWOp!;bpq#{q!b!;b!b!c#{!c#o!;b#p#q!;b#r;'S!;b;'S;=`!<U<%lO!;bX!;iX[PSWOp!;bpq#{q!b!;b!b!c#{!c#o!;b#p#q!;b#r;'S!;b;'S;=`!<U<%lO!;bX!<XP;=`<%l!;b~!<aOe~~!<fOf~",
    tokenizers: [0, 1, 2, 3],
    topRules: {
      Program: [0, 1],
    },
    tokenPrec: 4,
  });
  // src/ui/codemirrorExtensions/index.ts
  var language2 = LRLanguage.define({
    parser: parser.configure({
      props: [
        styleTags({
          Identifier: tags.variableName,
          Comment: tags.comment,
          Key: tags.name,
          Number: tags.number,
          BraceContent: tags.string,
          Quoted: tags.string,
          Command: tags.className,
          CommentCommand: tags.className,
          PreambleCommand: tags.className,
          StringCommand: tags.className,
          Field: tags.variableName,
        }),
      ],
    }),
  });
  var highlighting = HighlightStyle.define([
    {
      tag: tags.comment,
      color: "var(--light5)",
    },
    {
      tag: tags.name,
      color: "var(--orange)",
    },
    {
      tag: tags.number,
      color: "var(--light-blue)",
    },
    {
      tag: tags.string,
      color: "var(--green)",
    },
    {
      tag: tags.className,
      color: "var(--pink)",
    },
    {
      tag: tags.variableName,
      color: "white",
    },
  ]);
  function bibtexLanguage() {
    return new LanguageSupport(language2);
  }
  __name(bibtexLanguage, "bibtexLanguage");
  function bibtexSyntaxHighlighting() {
    return syntaxHighlighting(highlighting);
  }
  __name(bibtexSyntaxHighlighting, "bibtexSyntaxHighlighting");
  // src/ui/Editor.svelte
  function create_fragment2(ctx) {
    var main;
    var copybutton;
    var current;
    copybutton = new CopyButton_default({
      props: {
        bibtex: ctx[0],
      },
    });
    return {
      c() {
        main = element("main");
        create_component(copybutton.$$.fragment);
        attr(main, "id", "editor");
        attr(main, "class", "svelte-x4zh2g");
      },
      m(target, anchor) {
        insert(target, main, anchor);
        mount_component(copybutton, main, null);
        ctx[5](main);
        current = true;
      },
      p(ctx2, param) {
        var _param = _slicedToArray(param, 1),
          dirty = _param[0];
        var copybutton_changes = {};
        if (dirty & 1) copybutton_changes.bibtex = ctx2[0];
        copybutton.$set(copybutton_changes);
      },
      i(local) {
        if (current) return;
        transition_in(copybutton.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(copybutton.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) detach(main);
        destroy_component(copybutton);
        ctx[5](null);
      },
    };
  }
  __name(create_fragment2, "create_fragment");
  function instance2($$self, $$props, $$invalidate) {
    var bibtex = $$props.bibtex;
    var error = $$props.error;
    var editorRef;
    var cmEditor;
    var lintCompartment;
    onMount(() => {
      var onUpdate = EditorView.updateListener.of((v) => {
        if (cmEditor && v.docChanged) {
          $$invalidate(0, (bibtex = cmEditor.state.doc.toString()));
        }
      });
      $$invalidate(4, (lintCompartment = new Compartment()));
      $$invalidate(
        3,
        (cmEditor = new EditorView({
          parent: editorRef,
          state: EditorState.create({
            doc: bibtex,
            extensions: [lineNumbers(), highlightActiveLineGutter(), dropCursor(), EditorState.allowMultipleSelections.of(true), bracketMatching(), drawSelection(), bibtexLanguage(), bibtexSyntaxHighlighting(), keymap.of([...historyKeymap, indentWithTab]), history(), onUpdate, lintCompartment.of([])],
          }),
        }))
      );
      cmEditor.focus();
      window.cmEditor = cmEditor;
    });
    function main_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        editorRef = $$value;
        $$invalidate(1, editorRef);
      });
    }
    __name(main_binding, "main_binding");
    $$self.$$set = ($$props2) => {
      if ("bibtex" in $$props2) $$invalidate(0, (bibtex = $$props2.bibtex));
      if ("error" in $$props2) $$invalidate(2, (error = $$props2.error));
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 28) {
        $: {
          cmEditor === null || cmEditor === void 0
            ? void 0
            : cmEditor.dispatch({
                effects: lintCompartment.reconfigure(
                  linter(() => {
                    if (error && cmEditor) {
                      var line = cmEditor.state.doc.line(error.line);
                      var from = line.from;
                      var to = line.to;
                      return [
                        {
                          from,
                          to,
                          severity: "error",
                          message: "Syntax Error",
                        },
                      ];
                    } else {
                      return [];
                    }
                  })
                ),
              });
        }
      }
      if ($$self.$$.dirty & 9) {
        $: {
          if (cmEditor && bibtex !== cmEditor.state.doc.toString()) {
            cmEditor.dispatch({
              changes: {
                from: 0,
                to: cmEditor.state.doc.length,
                insert: bibtex,
              },
            });
          }
        }
      }
    };
    return [bibtex, editorRef, error, cmEditor, lintCompartment, main_binding];
  }
  __name(instance2, "instance");
  var Editor = class Editor extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance2, create_fragment2, safe_not_equal, {
        bibtex: 0,
        error: 2,
      });
    }
  };
  __name(Editor, "Editor");
  var Editor_default = Editor;
  // src/ui/Collapsible.svelte
  function create_fragment3(ctx) {
    var details;
    var summary;
    var t0;
    var t1;
    var current;
    var default_slot_template = ctx[3].default;
    var default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
    return {
      c() {
        details = element("details");
        summary = element("summary");
        t0 = text(ctx[0]);
        t1 = space();
        if (default_slot) default_slot.c();
        attr(summary, "class", "svelte-ee92zc");
        details.open = ctx[1];
        attr(details, "class", "svelte-ee92zc");
      },
      m(target, anchor) {
        insert(target, details, anchor);
        append(details, summary);
        append(summary, t0);
        append(details, t1);
        if (default_slot) {
          default_slot.m(details, null);
        }
        current = true;
      },
      p(ctx2, param) {
        var _param = _slicedToArray(param, 1),
          dirty = _param[0];
        if (!current || dirty & 1) set_data(t0, ctx2[0]);
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 4)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[2], !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null), null);
          }
        }
        if (!current || dirty & 2) {
          details.open = ctx2[1];
        }
      },
      i(local) {
        if (current) return;
        transition_in(default_slot, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d(detaching) {
        if (detaching) detach(details);
        if (default_slot) default_slot.d(detaching);
      },
    };
  }
  __name(create_fragment3, "create_fragment");
  function instance3($$self, $$props, $$invalidate) {
    var tmp = $$props.$$slots,
      slots = tmp === void 0 ? {} : tmp,
      $$scope = $$props.$$scope;
    var title2 = $$props.title;
    var _$$props_open = $$props.open,
      open = _$$props_open === void 0 ? false : _$$props_open;
    $$self.$$set = ($$props2) => {
      if ("title" in $$props2) $$invalidate(0, (title2 = $$props2.title));
      if ("open" in $$props2) $$invalidate(1, (open = $$props2.open));
      if ("$$scope" in $$props2) $$invalidate(2, ($$scope = $$props2.$$scope));
    };
    return [title2, open, $$scope, slots];
  }
  __name(instance3, "instance");
  var Collapsible = class Collapsible extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance3, create_fragment3, safe_not_equal, {
        title: 0,
        open: 1,
      });
    }
  };
  __name(Collapsible, "Collapsible");
  var Collapsible_default = Collapsible;
  // src/ui/Checkbox.svelte
  function create_fragment4(ctx) {
    var input;
    var mounted;
    var dispose;
    return {
      c() {
        input = element("input");
        attr(input, "type", "checkbox");
        attr(input, "name", ctx[1]);
        attr(input, "class", "svelte-doypik");
      },
      m(target, anchor) {
        insert(target, input, anchor);
        input.checked = ctx[0];
        if (!mounted) {
          dispose = [listen(input, "change", ctx[3]), listen(input, "change", ctx[4])];
          mounted = true;
        }
      },
      p(ctx2, param) {
        var _param = _slicedToArray(param, 1),
          dirty = _param[0];
        if (dirty & 2) {
          attr(input, "name", ctx2[1]);
        }
        if (dirty & 1) {
          input.checked = ctx2[0];
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) detach(input);
        mounted = false;
        run_all(dispose);
      },
    };
  }
  __name(create_fragment4, "create_fragment");
  function instance4($$self, $$props, $$invalidate) {
    var name2 = $$props.name;
    var _$$props_checked = $$props.checked,
      checked = _$$props_checked === void 0 ? void 0 : _$$props_checked;
    var dispatch = createEventDispatcher();
    function input_change_handler() {
      checked = this.checked;
      $$invalidate(0, checked);
    }
    __name(input_change_handler, "input_change_handler");
    var change_handler = /* @__PURE__ */ __name(() => dispatch("change"), "change_handler");
    $$self.$$set = ($$props2) => {
      if ("name" in $$props2) $$invalidate(1, (name2 = $$props2.name));
      if ("checked" in $$props2) $$invalidate(0, (checked = $$props2.checked));
    };
    return [checked, name2, dispatch, input_change_handler, change_handler];
  }
  __name(instance4, "instance");
  var Checkbox = class Checkbox extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance4, create_fragment4, safe_not_equal, {
        name: 1,
        checked: 0,
      });
    }
  };
  __name(Checkbox, "Checkbox");
  var Checkbox_default = Checkbox;
  // src/ui/Label.svelte
  function create_fragment5(ctx) {
    var label;
    var current;
    var default_slot_template = ctx[3].default;
    var default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
    return {
      c() {
        label = element("label");
        if (default_slot) default_slot.c();
        attr(label, "title", ctx[0]);
        attr(label, "class", "svelte-a2tm3u");
        toggle_class(label, "inset", ctx[1]);
      },
      m(target, anchor) {
        insert(target, label, anchor);
        if (default_slot) {
          default_slot.m(label, null);
        }
        current = true;
      },
      p(ctx2, param) {
        var _param = _slicedToArray(param, 1),
          dirty = _param[0];
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 4)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[2], !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null), null);
          }
        }
        if (!current || dirty & 1) {
          attr(label, "title", ctx2[0]);
        }
        if (!current || dirty & 2) {
          toggle_class(label, "inset", ctx2[1]);
        }
      },
      i(local) {
        if (current) return;
        transition_in(default_slot, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d(detaching) {
        if (detaching) detach(label);
        if (default_slot) default_slot.d(detaching);
      },
    };
  }
  __name(create_fragment5, "create_fragment");
  function instance5($$self, $$props, $$invalidate) {
    var tmp = $$props.$$slots,
      slots = tmp === void 0 ? {} : tmp,
      $$scope = $$props.$$scope;
    var tmp1 = $$props.title,
      title2 = tmp1 === void 0 ? void 0 : tmp1;
    var _$$props_inset = $$props.inset,
      inset = _$$props_inset === void 0 ? void 0 : _$$props_inset;
    $$self.$$set = ($$props2) => {
      if ("title" in $$props2) $$invalidate(0, (title2 = $$props2.title));
      if ("inset" in $$props2) $$invalidate(1, (inset = $$props2.inset));
      if ("$$scope" in $$props2) $$invalidate(2, ($$scope = $$props2.$$scope));
    };
    return [title2, inset, $$scope, slots];
  }
  __name(instance5, "instance");
  var Label = class Label extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance5, create_fragment5, safe_not_equal, {
        title: 0,
        inset: 1,
      });
    }
  };
  __name(Label, "Label");
  var Label_default = Label;
  // src/ui/SubOptions.svelte
  function create_fragment6(ctx) {
    var div;
    var current;
    var default_slot_template = ctx[1].default;
    var default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
    return {
      c() {
        div = element("div");
        if (default_slot) default_slot.c();
        attr(div, "class", "suboptions svelte-1gkj6ol");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        if (default_slot) {
          default_slot.m(div, null);
        }
        current = true;
      },
      p(ctx2, param) {
        var _param = _slicedToArray(param, 1),
          dirty = _param[0];
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[0], !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null), null);
          }
        }
      },
      i(local) {
        if (current) return;
        transition_in(default_slot, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d(detaching) {
        if (detaching) detach(div);
        if (default_slot) default_slot.d(detaching);
      },
    };
  }
  __name(create_fragment6, "create_fragment");
  function instance6($$self, $$props, $$invalidate) {
    var tmp = $$props.$$slots,
      slots = tmp === void 0 ? {} : tmp,
      $$scope = $$props.$$scope;
    $$self.$$set = ($$props2) => {
      if ("$$scope" in $$props2) $$invalidate(0, ($$scope = $$props2.$$scope));
    };
    return [$$scope, slots];
  }
  __name(instance6, "instance");
  var SubOptions = class SubOptions extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance6, create_fragment6, safe_not_equal, {});
    }
  };
  __name(SubOptions, "SubOptions");
  var SubOptions_default = SubOptions;
  // src/ui/Option.svelte
  function create_default_slot_1(ctx) {
    var checkbox;
    var updating_checked;
    var t0;
    var t1_value = ctx[3].title + "";
    var t1;
    var current;
    function checkbox_checked_binding(value) {
      ctx[6](value);
    }
    __name(checkbox_checked_binding, "checkbox_checked_binding");
    var checkbox_props = {
      name: ctx[1],
    };
    if (ctx[0] !== void 0) {
      checkbox_props.checked = ctx[0];
    }
    checkbox = new Checkbox_default({
      props: checkbox_props,
    });
    binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));
    checkbox.$on("change", ctx[7]);
    return {
      c() {
        create_component(checkbox.$$.fragment);
        t0 = space();
        t1 = text(t1_value);
      },
      m(target, anchor) {
        mount_component(checkbox, target, anchor);
        insert(target, t0, anchor);
        insert(target, t1, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        var checkbox_changes = {};
        if (dirty & 2) checkbox_changes.name = ctx2[1];
        if (!updating_checked && dirty & 1) {
          updating_checked = true;
          checkbox_changes.checked = ctx2[0];
          add_flush_callback(() => (updating_checked = false));
        }
        checkbox.$set(checkbox_changes);
      },
      i(local) {
        if (current) return;
        transition_in(checkbox.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(checkbox.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(checkbox, detaching);
        if (detaching) detach(t0);
        if (detaching) detach(t1);
      },
    };
  }
  __name(create_default_slot_1, "create_default_slot_1");
  function create_if_block(ctx) {
    var if_block_anchor;
    var current;
    var if_block = ctx[0] && create_if_block_1(ctx);
    return {
      c() {
        if (if_block) if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block) if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        if (ctx2[0]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
            if (dirty & 1) {
              transition_in(if_block, 1);
            }
          } else {
            if_block = create_if_block_1(ctx2);
            if_block.c();
            transition_in(if_block, 1);
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          group_outros();
          transition_out(if_block, 1, 1, () => {
            if_block = null;
          });
          check_outros();
        }
      },
      i(local) {
        if (current) return;
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (if_block) if_block.d(detaching);
        if (detaching) detach(if_block_anchor);
      },
    };
  }
  __name(create_if_block, "create_if_block");
  function create_if_block_1(ctx) {
    var suboptions;
    var current;
    suboptions = new SubOptions_default({
      props: {
        $$slots: {
          default: [create_default_slot],
        },
        $$scope: {
          ctx,
        },
      },
    });
    return {
      c() {
        create_component(suboptions.$$.fragment);
      },
      m(target, anchor) {
        mount_component(suboptions, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        var suboptions_changes = {};
        if (dirty & 256) {
          suboptions_changes.$$scope = {
            dirty,
            ctx: ctx2,
          };
        }
        suboptions.$set(suboptions_changes);
      },
      i(local) {
        if (current) return;
        transition_in(suboptions.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(suboptions.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(suboptions, detaching);
      },
    };
  }
  __name(create_if_block_1, "create_if_block_1");
  function create_default_slot(ctx) {
    var current;
    var default_slot_template = ctx[5].default;
    var default_slot = create_slot(default_slot_template, ctx, ctx[8], null);
    return {
      c() {
        if (default_slot) default_slot.c();
      },
      m(target, anchor) {
        if (default_slot) {
          default_slot.m(target, anchor);
        }
        current = true;
      },
      p(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 256)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[8], !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(default_slot_template, ctx2[8], dirty, null), null);
          }
        }
      },
      i(local) {
        if (current) return;
        transition_in(default_slot, local);
        current = true;
      },
      o(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d(detaching) {
        if (default_slot) default_slot.d(detaching);
      },
    };
  }
  __name(create_default_slot, "create_default_slot");
  function create_fragment7(ctx) {
    var _a2;
    var label;
    var t2;
    var if_block_anchor;
    var current;
    label = new Label_default({
      props: {
        title: (_a2 = ctx[3].description) == null ? void 0 : _a2.join("\n"),
        inset: true,
        $$slots: {
          default: [create_default_slot_1],
        },
        $$scope: {
          ctx,
        },
      },
    });
    var if_block = ctx[4].default && create_if_block(ctx);
    return {
      c() {
        create_component(label.$$.fragment);
        t2 = space();
        if (if_block) if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        mount_component(label, target, anchor);
        insert(target, t2, anchor);
        if (if_block) if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
        current = true;
      },
      p(ctx2, param) {
        var _param = _slicedToArray(param, 1),
          dirty = _param[0];
        var label_changes = {};
        if (dirty & 259) {
          label_changes.$$scope = {
            dirty,
            ctx: ctx2,
          };
        }
        label.$set(label_changes);
        if (ctx2[4].default) {
          if (if_block) {
            if_block.p(ctx2, dirty);
            if (dirty & 16) {
              transition_in(if_block, 1);
            }
          } else {
            if_block = create_if_block(ctx2);
            if_block.c();
            transition_in(if_block, 1);
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          group_outros();
          transition_out(if_block, 1, 1, () => {
            if_block = null;
          });
          check_outros();
        }
      },
      i(local) {
        if (current) return;
        transition_in(label.$$.fragment, local);
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(label.$$.fragment, local);
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        destroy_component(label, detaching);
        if (detaching) detach(t2);
        if (if_block) if_block.d(detaching);
        if (detaching) detach(if_block_anchor);
      },
    };
  }
  __name(create_fragment7, "create_fragment");
  function instance7($$self, $$props, $$invalidate) {
    var tmp = $$props.$$slots,
      slots = tmp === void 0 ? {} : tmp,
      $$scope = $$props.$$scope;
    var $$slots = compute_slots(slots);
    var option = $$props.option;
    var _$$props_checked = $$props.checked,
      checked = _$$props_checked === void 0 ? void 0 : _$$props_checked;
    var dispatch = createEventDispatcher();
    var def = optionDefinitionByKey[option];
    function checkbox_checked_binding(value) {
      checked = value;
      $$invalidate(0, checked);
    }
    __name(checkbox_checked_binding, "checkbox_checked_binding");
    var change_handler = /* @__PURE__ */ __name(() => dispatch("change", checked), "change_handler");
    $$self.$$set = ($$props2) => {
      if ("option" in $$props2) $$invalidate(1, (option = $$props2.option));
      if ("checked" in $$props2) $$invalidate(0, (checked = $$props2.checked));
      if ("$$scope" in $$props2) $$invalidate(8, ($$scope = $$props2.$$scope));
    };
    return [checked, option, dispatch, def, $$slots, slots, checkbox_checked_binding, change_handler, $$scope];
  }
  __name(instance7, "instance");
  var Option = class Option extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance7, create_fragment7, safe_not_equal, {
        option: 1,
        checked: 0,
      });
    }
  };
  __name(Option, "Option");
  var Option_default = Option;
  // src/ui/CleanupOptions.svelte
  function create_default_slot_2(ctx) {
    var t0;
    var textarea;
    var t1;
    var p;
    var mounted;
    var dispose;
    return {
      c() {
        t0 = text("Fields to omit:\n		");
        textarea = element("textarea");
        t1 = space();
        p = element("p");
        p.innerHTML = "Space delimited, e.g: <code>id type publisher author</code>";
        attr(textarea, "name", "omitList");
        attr(textarea, "class", "omit svelte-1t0249j");
        attr(textarea, "placeholder", "e.g. abstract keywords");
        attr(textarea, "spellcheck", "false");
      },
      m(target, anchor) {
        insert(target, t0, anchor);
        insert(target, textarea, anchor);
        set_input_value(textarea, ctx[1]);
        insert(target, t1, anchor);
        insert(target, p, anchor);
        if (!mounted) {
          dispose = listen(textarea, "input", ctx[9]);
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (dirty & 2) {
          set_input_value(textarea, ctx2[1]);
        }
      },
      d(detaching) {
        if (detaching) detach(t0);
        if (detaching) detach(textarea);
        if (detaching) detach(t1);
        if (detaching) detach(p);
        mounted = false;
        dispose();
      },
    };
  }
  __name(create_default_slot_2, "create_default_slot_2");
  function create_default_slot_12(ctx) {
    var label;
    var t0;
    var textarea;
    var t1;
    var p;
    var mounted;
    var dispose;
    return {
      c() {
        label = element("label");
        t0 = text("Template:\n			");
        textarea = element("textarea");
        t1 = space();
        p = element("p");
        p.innerHTML = '<a href="./manual/key-generation.html" target="_blank">Template documentation</a>';
        attr(textarea, "name", "generateKeysTemplate");
      },
      m(target, anchor) {
        insert(target, label, anchor);
        append(label, t0);
        append(label, textarea);
        set_input_value(textarea, ctx[7]);
        insert(target, t1, anchor);
        insert(target, p, anchor);
        if (!mounted) {
          dispose = listen(textarea, "input", ctx[14]);
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (dirty & 128) {
          set_input_value(textarea, ctx2[7]);
        }
      },
      d(detaching) {
        if (detaching) detach(label);
        if (detaching) detach(t1);
        if (detaching) detach(p);
        mounted = false;
        dispose();
      },
    };
  }
  __name(create_default_slot_12, "create_default_slot_1");
  function create_default_slot2(ctx) {
    var option0;
    var updating_checked;
    var t0;
    var option1;
    var updating_checked_1;
    var t1;
    var option2;
    var updating_checked_2;
    var t2;
    var option3;
    var updating_checked_3;
    var t3;
    var option4;
    var updating_checked_4;
    var t4;
    var option5;
    var updating_checked_5;
    var current;
    function option0_checked_binding(value) {
      ctx[10](value);
    }
    __name(option0_checked_binding, "option0_checked_binding");
    var option0_props = {
      option: "omit",
      $$slots: {
        default: [create_default_slot_2],
      },
      $$scope: {
        ctx,
      },
    };
    if (ctx[0] !== void 0) {
      option0_props.checked = ctx[0];
    }
    option0 = new Option_default({
      props: option0_props,
    });
    binding_callbacks.push(() => bind(option0, "checked", option0_checked_binding));
    function option1_checked_binding(value) {
      ctx[11](value);
    }
    __name(option1_checked_binding, "option1_checked_binding");
    var option1_props = {
      option: "stripComments",
    };
    if (ctx[2] !== void 0) {
      option1_props.checked = ctx[2];
    }
    option1 = new Option_default({
      props: option1_props,
    });
    binding_callbacks.push(() => bind(option1, "checked", option1_checked_binding));
    function option2_checked_binding(value) {
      ctx[12](value);
    }
    __name(option2_checked_binding, "option2_checked_binding");
    var option2_props = {
      option: "tidyComments",
    };
    if (ctx[3] !== void 0) {
      option2_props.checked = ctx[3];
    }
    option2 = new Option_default({
      props: option2_props,
    });
    binding_callbacks.push(() => bind(option2, "checked", option2_checked_binding));
    function option3_checked_binding(value) {
      ctx[13](value);
    }
    __name(option3_checked_binding, "option3_checked_binding");
    var option3_props = {
      option: "lowercase",
    };
    if (ctx[4] !== void 0) {
      option3_props.checked = ctx[4];
    }
    option3 = new Option_default({
      props: option3_props,
    });
    binding_callbacks.push(() => bind(option3, "checked", option3_checked_binding));
    function option4_checked_binding(value) {
      ctx[15](value);
    }
    __name(option4_checked_binding, "option4_checked_binding");
    var option4_props = {
      option: "generateKeys",
      $$slots: {
        default: [create_default_slot_12],
      },
      $$scope: {
        ctx,
      },
    };
    if (ctx[6] !== void 0) {
      option4_props.checked = ctx[6];
    }
    option4 = new Option_default({
      props: option4_props,
    });
    binding_callbacks.push(() => bind(option4, "checked", option4_checked_binding));
    function option5_checked_binding(value) {
      ctx[16](value);
    }
    __name(option5_checked_binding, "option5_checked_binding");
    var option5_props = {
      option: "trailingCommas",
    };
    if (ctx[5] !== void 0) {
      option5_props.checked = ctx[5];
    }
    option5 = new Option_default({
      props: option5_props,
    });
    binding_callbacks.push(() => bind(option5, "checked", option5_checked_binding));
    return {
      c() {
        create_component(option0.$$.fragment);
        t0 = space();
        create_component(option1.$$.fragment);
        t1 = space();
        create_component(option2.$$.fragment);
        t2 = space();
        create_component(option3.$$.fragment);
        t3 = space();
        create_component(option4.$$.fragment);
        t4 = space();
        create_component(option5.$$.fragment);
      },
      m(target, anchor) {
        mount_component(option0, target, anchor);
        insert(target, t0, anchor);
        mount_component(option1, target, anchor);
        insert(target, t1, anchor);
        mount_component(option2, target, anchor);
        insert(target, t2, anchor);
        mount_component(option3, target, anchor);
        insert(target, t3, anchor);
        mount_component(option4, target, anchor);
        insert(target, t4, anchor);
        mount_component(option5, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        var option0_changes = {};
        if (dirty & 16777218) {
          option0_changes.$$scope = {
            dirty,
            ctx: ctx2,
          };
        }
        if (!updating_checked && dirty & 1) {
          updating_checked = true;
          option0_changes.checked = ctx2[0];
          add_flush_callback(() => (updating_checked = false));
        }
        option0.$set(option0_changes);
        var option1_changes = {};
        if (!updating_checked_1 && dirty & 4) {
          updating_checked_1 = true;
          option1_changes.checked = ctx2[2];
          add_flush_callback(() => (updating_checked_1 = false));
        }
        option1.$set(option1_changes);
        var option2_changes = {};
        if (!updating_checked_2 && dirty & 8) {
          updating_checked_2 = true;
          option2_changes.checked = ctx2[3];
          add_flush_callback(() => (updating_checked_2 = false));
        }
        option2.$set(option2_changes);
        var option3_changes = {};
        if (!updating_checked_3 && dirty & 16) {
          updating_checked_3 = true;
          option3_changes.checked = ctx2[4];
          add_flush_callback(() => (updating_checked_3 = false));
        }
        option3.$set(option3_changes);
        var option4_changes = {};
        if (dirty & 16777344) {
          option4_changes.$$scope = {
            dirty,
            ctx: ctx2,
          };
        }
        if (!updating_checked_4 && dirty & 64) {
          updating_checked_4 = true;
          option4_changes.checked = ctx2[6];
          add_flush_callback(() => (updating_checked_4 = false));
        }
        option4.$set(option4_changes);
        var option5_changes = {};
        if (!updating_checked_5 && dirty & 32) {
          updating_checked_5 = true;
          option5_changes.checked = ctx2[5];
          add_flush_callback(() => (updating_checked_5 = false));
        }
        option5.$set(option5_changes);
      },
      i(local) {
        if (current) return;
        transition_in(option0.$$.fragment, local);
        transition_in(option1.$$.fragment, local);
        transition_in(option2.$$.fragment, local);
        transition_in(option3.$$.fragment, local);
        transition_in(option4.$$.fragment, local);
        transition_in(option5.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(option0.$$.fragment, local);
        transition_out(option1.$$.fragment, local);
        transition_out(option2.$$.fragment, local);
        transition_out(option3.$$.fragment, local);
        transition_out(option4.$$.fragment, local);
        transition_out(option5.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(option0, detaching);
        if (detaching) detach(t0);
        destroy_component(option1, detaching);
        if (detaching) detach(t1);
        destroy_component(option2, detaching);
        if (detaching) detach(t2);
        destroy_component(option3, detaching);
        if (detaching) detach(t3);
        destroy_component(option4, detaching);
        if (detaching) detach(t4);
        destroy_component(option5, detaching);
      },
    };
  }
  __name(create_default_slot2, "create_default_slot");
  function create_fragment8(ctx) {
    var collapsible;
    var current;
    collapsible = new Collapsible_default({
      props: {
        title: "Clean up",
        open: true,
        $$slots: {
          default: [create_default_slot2],
        },
        $$scope: {
          ctx,
        },
      },
    });
    return {
      c() {
        create_component(collapsible.$$.fragment);
      },
      m(target, anchor) {
        mount_component(collapsible, target, anchor);
        current = true;
      },
      p(ctx2, param) {
        var _param = _slicedToArray(param, 1),
          dirty = _param[0];
        var collapsible_changes = {};
        if (dirty & 16777471) {
          collapsible_changes.$$scope = {
            dirty,
            ctx: ctx2,
          };
        }
        collapsible.$set(collapsible_changes);
      },
      i(local) {
        if (current) return;
        transition_in(collapsible.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(collapsible.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(collapsible, detaching);
      },
    };
  }
  __name(create_fragment8, "create_fragment");
  function instance8($$self, $$props, $$invalidate) {
    var _a2, _b, _c, _d, _e, _f, _g;
    var options = $$props.options;
    var omitChecked = options.omit !== void 0 && options.omit.length > 0;
    var omitValue = (_b = (_a2 = options.omit) === null || _a2 === void 0 ? void 0 : _a2.join(" ")) !== null && _b !== void 0 ? _b : "";
    var stripComments = (_c = options.stripComments) !== null && _c !== void 0 ? _c : false;
    var tidyComments = (_d = options.tidyComments) !== null && _d !== void 0 ? _d : false;
    var lowercase = (_e = options.lowercase) !== null && _e !== void 0 ? _e : false;
    var trailingCommasChecked = (_f = options.trailingCommas) !== null && _f !== void 0 ? _f : false;
    var generateKeysChecked = options.generateKeys !== void 0 && options.generateKeys.length > 0;
    var generateKeysValue = (_g = options.generateKeys) !== null && _g !== void 0 ? _g : "[auth:required:lower][year:required][veryshorttitle:lower][duplicateNumber]";
    function textarea_input_handler() {
      omitValue = this.value;
      $$invalidate(1, omitValue);
    }
    __name(textarea_input_handler, "textarea_input_handler");
    function option0_checked_binding(value) {
      omitChecked = value;
      $$invalidate(0, omitChecked);
    }
    __name(option0_checked_binding, "option0_checked_binding");
    function option1_checked_binding(value) {
      stripComments = value;
      $$invalidate(2, stripComments);
    }
    __name(option1_checked_binding, "option1_checked_binding");
    function option2_checked_binding(value) {
      tidyComments = value;
      $$invalidate(3, tidyComments);
    }
    __name(option2_checked_binding, "option2_checked_binding");
    function option3_checked_binding(value) {
      lowercase = value;
      $$invalidate(4, lowercase);
    }
    __name(option3_checked_binding, "option3_checked_binding");
    function textarea_input_handler_1() {
      generateKeysValue = this.value;
      $$invalidate(7, generateKeysValue);
    }
    __name(textarea_input_handler_1, "textarea_input_handler_1");
    function option4_checked_binding(value) {
      generateKeysChecked = value;
      $$invalidate(6, generateKeysChecked);
    }
    __name(option4_checked_binding, "option4_checked_binding");
    function option5_checked_binding(value) {
      trailingCommasChecked = value;
      $$invalidate(5, trailingCommasChecked);
    }
    __name(option5_checked_binding, "option5_checked_binding");
    $$self.$$set = ($$props2) => {
      if ("options" in $$props2) $$invalidate(8, (options = $$props2.options));
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 255) {
        $: {
          $$invalidate(8, (options.omit = omitChecked && omitValue.length > 0 ? omitValue.split(/[\n\t ,]+/) : void 0), options);
          $$invalidate(8, (options.stripComments = stripComments), options);
          $$invalidate(8, (options.tidyComments = tidyComments), options);
          $$invalidate(8, (options.lowercase = lowercase), options);
          $$invalidate(8, (options.trailingCommas = trailingCommasChecked), options);
          $$invalidate(8, (options.generateKeys = generateKeysChecked ? generateKeysValue : void 0), options);
        }
      }
    };
    return [omitChecked, omitValue, stripComments, tidyComments, lowercase, trailingCommasChecked, generateKeysChecked, generateKeysValue, options, textarea_input_handler, option0_checked_binding, option1_checked_binding, option2_checked_binding, option3_checked_binding, textarea_input_handler_1, option4_checked_binding, option5_checked_binding];
  }
  __name(instance8, "instance");
  var CleanupOptions = class CleanupOptions extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance8, create_fragment8, safe_not_equal, {
        options: 8,
      });
    }
  };
  __name(CleanupOptions, "CleanupOptions");
  var CleanupOptions_default = CleanupOptions;
  // src/cliUtils.ts
  var OPTIONS = new Set(optionDefinitions.flatMap((def) => Object.keys(def.cli)));
  function optionsToCLIArgs(options) {
    return optionDefinitions
      .map((def) => {
        var _a2;
        return (_a2 = def.toCLI) == null ? void 0 : _a2.call(def, options[def.key], options);
      })
      .filter((arg) => typeof arg === "string");
  }
  __name(optionsToCLIArgs, "optionsToCLIArgs");
  // src/ui/Cli.svelte
  function get_each_context(ctx, list, i) {
    var child_ctx = ctx.slice();
    child_ctx[2] = list[i][0];
    child_ctx[3] = list[i][1];
    return child_ctx;
  }
  __name(get_each_context, "get_each_context");
  function create_if_block2(ctx) {
    var t0;
    var span;
    var t1_value = ctx[3] + "";
    var t1;
    var t2;
    return {
      c() {
        t0 = text("=");
        span = element("span");
        t1 = text(t1_value);
        t2 = space();
        attr(span, "class", "opt-val svelte-1xnx1c1");
      },
      m(target, anchor) {
        insert(target, t0, anchor);
        insert(target, span, anchor);
        append(span, t1);
        insert(target, t2, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & 1 && t1_value !== (t1_value = ctx2[3] + "")) set_data(t1, t1_value);
      },
      d(detaching) {
        if (detaching) detach(t0);
        if (detaching) detach(span);
        if (detaching) detach(t2);
      },
    };
  }
  __name(create_if_block2, "create_if_block");
  function create_each_block(ctx) {
    var span;
    var t0_value = ctx[2] + "";
    var t0;
    var t1_value = " ";
    var t1;
    var if_block = ctx[3] && ctx[3].length > 0 && create_if_block2(ctx);
    return {
      c() {
        span = element("span");
        t0 = text(t0_value);
        if (if_block) if_block.c();
        t1 = text(t1_value);
        attr(span, "class", "opt-name svelte-1xnx1c1");
      },
      m(target, anchor) {
        insert(target, span, anchor);
        append(span, t0);
        if (if_block) if_block.m(target, anchor);
        insert(target, t1, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & 1 && t0_value !== (t0_value = ctx2[2] + "")) set_data(t0, t0_value);
        if (ctx2[3] && ctx2[3].length > 0) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block2(ctx2);
            if_block.c();
            if_block.m(t1.parentNode, t1);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (detaching) detach(span);
        if (if_block) if_block.d(detaching);
        if (detaching) detach(t1);
      },
    };
  }
  __name(create_each_block, "create_each_block");
  function create_default_slot3(ctx) {
    var p;
    var t1;
    var code;
    var t2;
    var t3;
    var each_value = ctx[0];
    var each_blocks = [];
    for (var i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    }
    return {
      c() {
        p = element("p");
        p.textContent = "To run this configuration on the command line:";
        t1 = space();
        code = element("code");
        t2 = text("bibtex-tidy ");
        for (var i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        t3 = text(" YOUR_FILE.bib");
        attr(code, "id", "cli");
        attr(code, "class", "svelte-1xnx1c1");
      },
      m(target, anchor) {
        insert(target, p, anchor);
        insert(target, t1, anchor);
        insert(target, code, anchor);
        append(code, t2);
        for (var i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].m(code, null);
        }
        append(code, t3);
      },
      p(ctx2, dirty) {
        if (dirty & 1) {
          each_value = ctx2[0];
          var i;
          for (i = 0; i < each_value.length; i += 1) {
            var child_ctx = get_each_context(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(code, t3);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
      },
      d(detaching) {
        if (detaching) detach(p);
        if (detaching) detach(t1);
        if (detaching) detach(code);
        destroy_each(each_blocks, detaching);
      },
    };
  }
  __name(create_default_slot3, "create_default_slot");
  function create_fragment9(ctx) {
    var collapsible;
    var current;
    collapsible = new Collapsible_default({
      props: {
        title: "CLI",
        $$slots: {
          default: [create_default_slot3],
        },
        $$scope: {
          ctx,
        },
      },
    });
    return {
      c() {
        create_component(collapsible.$$.fragment);
      },
      m(target, anchor) {
        mount_component(collapsible, target, anchor);
        current = true;
      },
      p(ctx2, param) {
        var _param = _slicedToArray(param, 1),
          dirty = _param[0];
        var collapsible_changes = {};
        if (dirty & 65) {
          collapsible_changes.$$scope = {
            dirty,
            ctx: ctx2,
          };
        }
        collapsible.$set(collapsible_changes);
      },
      i(local) {
        if (current) return;
        transition_in(collapsible.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(collapsible.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(collapsible, detaching);
      },
    };
  }
  __name(create_fragment9, "create_fragment");
  function instance9($$self, $$props, $$invalidate) {
    var options = $$props.options;
    var args;
    $$self.$$set = ($$props2) => {
      if ("options" in $$props2) $$invalidate(1, (options = $$props2.options));
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 2) {
        $: {
          $$invalidate(
            0,
            (args = optionsToCLIArgs(options).map((opt) => {
              var i = opt.indexOf("=");
              return i === -1 ? [opt] : [opt.slice(0, i), opt.slice(i + 1)];
            }))
          );
        }
      }
    };
    return [args, options];
  }
  __name(instance9, "instance");
  var Cli = class Cli extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance9, create_fragment9, safe_not_equal, {
        options: 1,
      });
    }
  };
  __name(Cli, "Cli");
  var Cli_default = Cli;
  // src/ui/Radio.svelte
  function create_fragment10(ctx) {
    var input;
    var mounted;
    var dispose;
    return {
      c() {
        input = element("input");
        attr(input, "type", "radio");
        attr(input, "name", ctx[1]);
        input.__value = ctx[2];
        input.value = input.__value;
        attr(input, "class", "svelte-qhlda7");
        ctx[4][0].push(input);
      },
      m(target, anchor) {
        insert(target, input, anchor);
        input.checked = input.__value === ctx[0];
        if (!mounted) {
          dispose = listen(input, "change", ctx[3]);
          mounted = true;
        }
      },
      p(ctx2, param) {
        var _param = _slicedToArray(param, 1),
          dirty = _param[0];
        if (dirty & 2) {
          attr(input, "name", ctx2[1]);
        }
        if (dirty & 4) {
          input.__value = ctx2[2];
          input.value = input.__value;
        }
        if (dirty & 1) {
          input.checked = input.__value === ctx2[0];
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) detach(input);
        ctx[4][0].splice(ctx[4][0].indexOf(input), 1);
        mounted = false;
        dispose();
      },
    };
  }
  __name(create_fragment10, "create_fragment");
  function instance10($$self, $$props, $$invalidate) {
    var name2 = $$props.name;
    var group = $$props.group;
    var _$$props_value = $$props.value,
      value = _$$props_value === void 0 ? void 0 : _$$props_value;
    var $$binding_groups = [[]];
    function input_change_handler() {
      group = this.__value;
      $$invalidate(0, group);
    }
    __name(input_change_handler, "input_change_handler");
    $$self.$$set = ($$props2) => {
      if ("name" in $$props2) $$invalidate(1, (name2 = $$props2.name));
      if ("group" in $$props2) $$invalidate(0, (group = $$props2.group));
      if ("value" in $$props2) $$invalidate(2, (value = $$props2.value));
    };
    return [group, name2, value, input_change_handler, $$binding_groups];
  }
  __name(instance10, "instance");
  var Radio = class Radio extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance10, create_fragment10, safe_not_equal, {
        name: 1,
        group: 0,
        value: 2,
      });
    }
  };
  __name(Radio, "Radio");
  var Radio_default = Radio;
  // src/ui/DuplicateOptions.svelte
  function create_default_slot_10(ctx) {
    var checkbox;
    var updating_checked;
    var t2;
    var current;
    function checkbox_checked_binding(value) {
      ctx[8](value);
    }
    __name(checkbox_checked_binding, "checkbox_checked_binding");
    var checkbox_props = {
      name: "uniqKEY",
    };
    if (ctx[1] !== void 0) {
      checkbox_props.checked = ctx[1];
    }
    checkbox = new Checkbox_default({
      props: checkbox_props,
    });
    binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));
    return {
      c() {
        create_component(checkbox.$$.fragment);
        t2 = text("\n			Matching Keys");
      },
      m(target, anchor) {
        mount_component(checkbox, target, anchor);
        insert(target, t2, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        var checkbox_changes = {};
        if (!updating_checked && dirty & 2) {
          updating_checked = true;
          checkbox_changes.checked = ctx2[1];
          add_flush_callback(() => (updating_checked = false));
        }
        checkbox.$set(checkbox_changes);
      },
      i(local) {
        if (current) return;
        transition_in(checkbox.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(checkbox.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(checkbox, detaching);
        if (detaching) detach(t2);
      },
    };
  }
  __name(create_default_slot_10, "create_default_slot_10");
  function create_default_slot_9(ctx) {
    var checkbox;
    var updating_checked;
    var t2;
    var current;
    function checkbox_checked_binding_1(value) {
      ctx[9](value);
    }
    __name(checkbox_checked_binding_1, "checkbox_checked_binding_1");
    var checkbox_props = {
      name: "uniqDOI",
    };
    if (ctx[2] !== void 0) {
      checkbox_props.checked = ctx[2];
    }
    checkbox = new Checkbox_default({
      props: checkbox_props,
    });
    binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding_1));
    return {
      c() {
        create_component(checkbox.$$.fragment);
        t2 = text("\n			Matching DOIs");
      },
      m(target, anchor) {
        mount_component(checkbox, target, anchor);
        insert(target, t2, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        var checkbox_changes = {};
        if (!updating_checked && dirty & 4) {
          updating_checked = true;
          checkbox_changes.checked = ctx2[2];
          add_flush_callback(() => (updating_checked = false));
        }
        checkbox.$set(checkbox_changes);
      },
      i(local) {
        if (current) return;
        transition_in(checkbox.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(checkbox.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(checkbox, detaching);
        if (detaching) detach(t2);
      },
    };
  }
  __name(create_default_slot_9, "create_default_slot_9");
  function create_default_slot_8(ctx) {
    var checkbox;
    var updating_checked;
    var t2;
    var current;
    function checkbox_checked_binding_2(value) {
      ctx[10](value);
    }
    __name(checkbox_checked_binding_2, "checkbox_checked_binding_2");
    var checkbox_props = {
      name: "uniqCIT",
    };
    if (ctx[3] !== void 0) {
      checkbox_props.checked = ctx[3];
    }
    checkbox = new Checkbox_default({
      props: checkbox_props,
    });
    binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding_2));
    return {
      c() {
        create_component(checkbox.$$.fragment);
        t2 = text("\n			Similar author and title");
      },
      m(target, anchor) {
        mount_component(checkbox, target, anchor);
        insert(target, t2, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        var checkbox_changes = {};
        if (!updating_checked && dirty & 8) {
          updating_checked = true;
          checkbox_changes.checked = ctx2[3];
          add_flush_callback(() => (updating_checked = false));
        }
        checkbox.$set(checkbox_changes);
      },
      i(local) {
        if (current) return;
        transition_in(checkbox.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(checkbox.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(checkbox, detaching);
        if (detaching) detach(t2);
      },
    };
  }
  __name(create_default_slot_8, "create_default_slot_8");
  function create_default_slot_7(ctx) {
    var checkbox;
    var updating_checked;
    var t2;
    var current;
    function checkbox_checked_binding_3(value) {
      ctx[11](value);
    }
    __name(checkbox_checked_binding_3, "checkbox_checked_binding_3");
    var checkbox_props = {
      name: "uniqABS",
    };
    if (ctx[4] !== void 0) {
      checkbox_props.checked = ctx[4];
    }
    checkbox = new Checkbox_default({
      props: checkbox_props,
    });
    binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding_3));
    return {
      c() {
        create_component(checkbox.$$.fragment);
        t2 = text("\n			Similar abstracts");
      },
      m(target, anchor) {
        mount_component(checkbox, target, anchor);
        insert(target, t2, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        var checkbox_changes = {};
        if (!updating_checked && dirty & 16) {
          updating_checked = true;
          checkbox_changes.checked = ctx2[4];
          add_flush_callback(() => (updating_checked = false));
        }
        checkbox.$set(checkbox_changes);
      },
      i(local) {
        if (current) return;
        transition_in(checkbox.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(checkbox.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(checkbox, detaching);
        if (detaching) detach(t2);
      },
    };
  }
  __name(create_default_slot_7, "create_default_slot_7");
  function create_default_slot_6(ctx) {
    var p;
    var t1;
    var label0;
    var t2;
    var label1;
    var t3;
    var label2;
    var t4;
    var label3;
    var current;
    label0 = new Label_default({
      props: {
        $$slots: {
          default: [create_default_slot_10],
        },
        $$scope: {
          ctx,
        },
      },
    });
    label1 = new Label_default({
      props: {
        $$slots: {
          default: [create_default_slot_9],
        },
        $$scope: {
          ctx,
        },
      },
    });
    label2 = new Label_default({
      props: {
        $$slots: {
          default: [create_default_slot_8],
        },
        $$scope: {
          ctx,
        },
      },
    });
    label3 = new Label_default({
      props: {
        $$slots: {
          default: [create_default_slot_7],
        },
        $$scope: {
          ctx,
        },
      },
    });
    return {
      c() {
        p = element("p");
        p.textContent = "What to check:";
        t1 = space();
        create_component(label0.$$.fragment);
        t2 = space();
        create_component(label1.$$.fragment);
        t3 = space();
        create_component(label2.$$.fragment);
        t4 = space();
        create_component(label3.$$.fragment);
      },
      m(target, anchor) {
        insert(target, p, anchor);
        insert(target, t1, anchor);
        mount_component(label0, target, anchor);
        insert(target, t2, anchor);
        mount_component(label1, target, anchor);
        insert(target, t3, anchor);
        mount_component(label2, target, anchor);
        insert(target, t4, anchor);
        mount_component(label3, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        var label0_changes = {};
        if (dirty & 134217730) {
          label0_changes.$$scope = {
            dirty,
            ctx: ctx2,
          };
        }
        label0.$set(label0_changes);
        var label1_changes = {};
        if (dirty & 134217732) {
          label1_changes.$$scope = {
            dirty,
            ctx: ctx2,
          };
        }
        label1.$set(label1_changes);
        var label2_changes = {};
        if (dirty & 134217736) {
          label2_changes.$$scope = {
            dirty,
            ctx: ctx2,
          };
        }
        label2.$set(label2_changes);
        var label3_changes = {};
        if (dirty & 134217744) {
          label3_changes.$$scope = {
            dirty,
            ctx: ctx2,
          };
        }
        label3.$set(label3_changes);
      },
      i(local) {
        if (current) return;
        transition_in(label0.$$.fragment, local);
        transition_in(label1.$$.fragment, local);
        transition_in(label2.$$.fragment, local);
        transition_in(label3.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(label0.$$.fragment, local);
        transition_out(label1.$$.fragment, local);
        transition_out(label2.$$.fragment, local);
        transition_out(label3.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) detach(p);
        if (detaching) detach(t1);
        destroy_component(label0, detaching);
        if (detaching) detach(t2);
        destroy_component(label1, detaching);
        if (detaching) detach(t3);
        destroy_component(label2, detaching);
        if (detaching) detach(t4);
        destroy_component(label3, detaching);
      },
    };
  }
  __name(create_default_slot_6, "create_default_slot_6");
  function create_default_slot_5(ctx) {
    var radio;
    var updating_group;
    var t0;
    var span;
    var current;
    function radio_group_binding(value) {
      ctx[13](value);
    }
    __name(radio_group_binding, "radio_group_binding");
    var radio_props = {
      name: "mergeStrategy",
      value: "combine",
    };
    if (ctx[6] !== void 0) {
      radio_props.group = ctx[6];
    }
    radio = new Radio_default({
      props: radio_props,
    });
    binding_callbacks.push(() => bind(radio, "group", radio_group_binding));
    return {
      c() {
        create_component(radio.$$.fragment);
        t0 = space();
        span = element("span");
        span.innerHTML = "<strong>Combine</strong><br/> \n				<small>Keep original entry and merge in fields of duplicates if they do not\n					already exist</small>";
      },
      m(target, anchor) {
        mount_component(radio, target, anchor);
        insert(target, t0, anchor);
        insert(target, span, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        var radio_changes = {};
        if (!updating_group && dirty & 64) {
          updating_group = true;
          radio_changes.group = ctx2[6];
          add_flush_callback(() => (updating_group = false));
        }
        radio.$set(radio_changes);
      },
      i(local) {
        if (current) return;
        transition_in(radio.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(radio.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(radio, detaching);
        if (detaching) detach(t0);
        if (detaching) detach(span);
      },
    };
  }
  __name(create_default_slot_5, "create_default_slot_5");
  function create_default_slot_4(ctx) {
    var radio;
    var updating_group;
    var t0;
    var span;
    var current;
    function radio_group_binding_1(value) {
      ctx[14](value);
    }
    __name(radio_group_binding_1, "radio_group_binding_1");
    var radio_props = {
      name: "mergeStrategy",
      value: "overwrite",
    };
    if (ctx[6] !== void 0) {
      radio_props.group = ctx[6];
    }
    radio = new Radio_default({
      props: radio_props,
    });
    binding_callbacks.push(() => bind(radio, "group", radio_group_binding_1));
    return {
      c() {
        create_component(radio.$$.fragment);
        t0 = space();
        span = element("span");
        span.innerHTML = "<strong>Overwrite</strong><br/> \n				<small>Keep original entry and merge in fields of duplicates, overwriting\n					existing fields if they exist</small>";
      },
      m(target, anchor) {
        mount_component(radio, target, anchor);
        insert(target, t0, anchor);
        insert(target, span, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        var radio_changes = {};
        if (!updating_group && dirty & 64) {
          updating_group = true;
          radio_changes.group = ctx2[6];
          add_flush_callback(() => (updating_group = false));
        }
        radio.$set(radio_changes);
      },
      i(local) {
        if (current) return;
        transition_in(radio.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(radio.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(radio, detaching);
        if (detaching) detach(t0);
        if (detaching) detach(span);
      },
    };
  }
  __name(create_default_slot_4, "create_default_slot_4");
  function create_default_slot_3(ctx) {
    var radio;
    var updating_group;
    var t0;
    var span;
    var current;
    function radio_group_binding_2(value) {
      ctx[15](value);
    }
    __name(radio_group_binding_2, "radio_group_binding_2");
    var radio_props = {
      name: "mergeStrategy",
      value: "first",
    };
    if (ctx[6] !== void 0) {
      radio_props.group = ctx[6];
    }
    radio = new Radio_default({
      props: radio_props,
    });
    binding_callbacks.push(() => bind(radio, "group", radio_group_binding_2));
    return {
      c() {
        create_component(radio.$$.fragment);
        t0 = space();
        span = element("span");
        span.innerHTML = "<strong>First</strong><br/> \n				<small>Only keep the original entry</small>";
      },
      m(target, anchor) {
        mount_component(radio, target, anchor);
        insert(target, t0, anchor);
        insert(target, span, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        var radio_changes = {};
        if (!updating_group && dirty & 64) {
          updating_group = true;
          radio_changes.group = ctx2[6];
          add_flush_callback(() => (updating_group = false));
        }
        radio.$set(radio_changes);
      },
      i(local) {
        if (current) return;
        transition_in(radio.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(radio.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(radio, detaching);
        if (detaching) detach(t0);
        if (detaching) detach(span);
      },
    };
  }
  __name(create_default_slot_3, "create_default_slot_3");
  function create_default_slot_22(ctx) {
    var radio;
    var updating_group;
    var t0;
    var span;
    var current;
    function radio_group_binding_3(value) {
      ctx[16](value);
    }
    __name(radio_group_binding_3, "radio_group_binding_3");
    var radio_props = {
      name: "mergeStrategy",
      value: "last",
    };
    if (ctx[6] !== void 0) {
      radio_props.group = ctx[6];
    }
    radio = new Radio_default({
      props: radio_props,
    });
    binding_callbacks.push(() => bind(radio, "group", radio_group_binding_3));
    return {
      c() {
        create_component(radio.$$.fragment);
        t0 = space();
        span = element("span");
        span.innerHTML = "<strong>Last</strong><br/> \n				<small>Only keep the last found duplicate</small>";
      },
      m(target, anchor) {
        mount_component(radio, target, anchor);
        insert(target, t0, anchor);
        insert(target, span, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        var radio_changes = {};
        if (!updating_group && dirty & 64) {
          updating_group = true;
          radio_changes.group = ctx2[6];
          add_flush_callback(() => (updating_group = false));
        }
        radio.$set(radio_changes);
      },
      i(local) {
        if (current) return;
        transition_in(radio.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(radio.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(radio, detaching);
        if (detaching) detach(t0);
        if (detaching) detach(span);
      },
    };
  }
  __name(create_default_slot_22, "create_default_slot_2");
  function create_default_slot_13(ctx) {
    var label0;
    var t0;
    var label1;
    var t1;
    var label2;
    var t2;
    var label3;
    var current;
    label0 = new Label_default({
      props: {
        $$slots: {
          default: [create_default_slot_5],
        },
        $$scope: {
          ctx,
        },
      },
    });
    label1 = new Label_default({
      props: {
        $$slots: {
          default: [create_default_slot_4],
        },
        $$scope: {
          ctx,
        },
      },
    });
    label2 = new Label_default({
      props: {
        $$slots: {
          default: [create_default_slot_3],
        },
        $$scope: {
          ctx,
        },
      },
    });
    label3 = new Label_default({
      props: {
        $$slots: {
          default: [create_default_slot_22],
        },
        $$scope: {
          ctx,
        },
      },
    });
    return {
      c() {
        create_component(label0.$$.fragment);
        t0 = space();
        create_component(label1.$$.fragment);
        t1 = space();
        create_component(label2.$$.fragment);
        t2 = space();
        create_component(label3.$$.fragment);
      },
      m(target, anchor) {
        mount_component(label0, target, anchor);
        insert(target, t0, anchor);
        mount_component(label1, target, anchor);
        insert(target, t1, anchor);
        mount_component(label2, target, anchor);
        insert(target, t2, anchor);
        mount_component(label3, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        var label0_changes = {};
        if (dirty & 134217792) {
          label0_changes.$$scope = {
            dirty,
            ctx: ctx2,
          };
        }
        label0.$set(label0_changes);
        var label1_changes = {};
        if (dirty & 134217792) {
          label1_changes.$$scope = {
            dirty,
            ctx: ctx2,
          };
        }
        label1.$set(label1_changes);
        var label2_changes = {};
        if (dirty & 134217792) {
          label2_changes.$$scope = {
            dirty,
            ctx: ctx2,
          };
        }
        label2.$set(label2_changes);
        var label3_changes = {};
        if (dirty & 134217792) {
          label3_changes.$$scope = {
            dirty,
            ctx: ctx2,
          };
        }
        label3.$set(label3_changes);
      },
      i(local) {
        if (current) return;
        transition_in(label0.$$.fragment, local);
        transition_in(label1.$$.fragment, local);
        transition_in(label2.$$.fragment, local);
        transition_in(label3.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(label0.$$.fragment, local);
        transition_out(label1.$$.fragment, local);
        transition_out(label2.$$.fragment, local);
        transition_out(label3.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(label0, detaching);
        if (detaching) detach(t0);
        destroy_component(label1, detaching);
        if (detaching) detach(t1);
        destroy_component(label2, detaching);
        if (detaching) detach(t2);
        destroy_component(label3, detaching);
      },
    };
  }
  __name(create_default_slot_13, "create_default_slot_1");
  function create_default_slot4(ctx) {
    var option0;
    var updating_checked;
    var t2;
    var option1;
    var updating_checked_1;
    var current;
    function option0_checked_binding(value) {
      ctx[12](value);
    }
    __name(option0_checked_binding, "option0_checked_binding");
    var option0_props = {
      option: "duplicates",
      $$slots: {
        default: [create_default_slot_6],
      },
      $$scope: {
        ctx,
      },
    };
    if (ctx[0] !== void 0) {
      option0_props.checked = ctx[0];
    }
    option0 = new Option_default({
      props: option0_props,
    });
    binding_callbacks.push(() => bind(option0, "checked", option0_checked_binding));
    function option1_checked_binding(value) {
      ctx[17](value);
    }
    __name(option1_checked_binding, "option1_checked_binding");
    var option1_props = {
      option: "merge",
      $$slots: {
        default: [create_default_slot_13],
      },
      $$scope: {
        ctx,
      },
    };
    if (ctx[5] !== void 0) {
      option1_props.checked = ctx[5];
    }
    option1 = new Option_default({
      props: option1_props,
    });
    binding_callbacks.push(() => bind(option1, "checked", option1_checked_binding));
    return {
      c() {
        create_component(option0.$$.fragment);
        t2 = space();
        create_component(option1.$$.fragment);
      },
      m(target, anchor) {
        mount_component(option0, target, anchor);
        insert(target, t2, anchor);
        mount_component(option1, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        var option0_changes = {};
        if (dirty & 134217758) {
          option0_changes.$$scope = {
            dirty,
            ctx: ctx2,
          };
        }
        if (!updating_checked && dirty & 1) {
          updating_checked = true;
          option0_changes.checked = ctx2[0];
          add_flush_callback(() => (updating_checked = false));
        }
        option0.$set(option0_changes);
        var option1_changes = {};
        if (dirty & 134217792) {
          option1_changes.$$scope = {
            dirty,
            ctx: ctx2,
          };
        }
        if (!updating_checked_1 && dirty & 32) {
          updating_checked_1 = true;
          option1_changes.checked = ctx2[5];
          add_flush_callback(() => (updating_checked_1 = false));
        }
        option1.$set(option1_changes);
      },
      i(local) {
        if (current) return;
        transition_in(option0.$$.fragment, local);
        transition_in(option1.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(option0.$$.fragment, local);
        transition_out(option1.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(option0, detaching);
        if (detaching) detach(t2);
        destroy_component(option1, detaching);
      },
    };
  }
  __name(create_default_slot4, "create_default_slot");
  function create_fragment11(ctx) {
    var collapsible;
    var current;
    collapsible = new Collapsible_default({
      props: {
        title: "Duplicates",
        open: true,
        $$slots: {
          default: [create_default_slot4],
        },
        $$scope: {
          ctx,
        },
      },
    });
    return {
      c() {
        create_component(collapsible.$$.fragment);
      },
      m(target, anchor) {
        mount_component(collapsible, target, anchor);
        current = true;
      },
      p(ctx2, param) {
        var _param = _slicedToArray(param, 1),
          dirty = _param[0];
        var collapsible_changes = {};
        if (dirty & 134217855) {
          collapsible_changes.$$scope = {
            dirty,
            ctx: ctx2,
          };
        }
        collapsible.$set(collapsible_changes);
      },
      i(local) {
        if (current) return;
        transition_in(collapsible.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(collapsible.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(collapsible, detaching);
      },
    };
  }
  __name(create_fragment11, "create_fragment");
  function instance11($$self, $$props, $$invalidate) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j;
    var options = $$props.options;
    var duplicateCheckChecked = options.duplicates !== void 0;
    var duplicateCheckKey = (_b = (_a2 = options.duplicates) === null || _a2 === void 0 ? void 0 : _a2.includes("key")) !== null && _b !== void 0 ? _b : true;
    var duplicateCheckDOI = (_d = (_c = options.duplicates) === null || _c === void 0 ? void 0 : _c.includes("doi")) !== null && _d !== void 0 ? _d : false;
    var duplicateCheckCitation = (_f = (_e = options.duplicates) === null || _e === void 0 ? void 0 : _e.includes("citation")) !== null && _f !== void 0 ? _f : false;
    var duplicateCheckAbstract = (_h = (_g = options.duplicates) === null || _g === void 0 ? void 0 : _g.includes("abstract")) !== null && _h !== void 0 ? _h : false;
    var mergeChecked = options.merge !== void 0;
    var mergeValue = (_j = options.merge) !== null && _j !== void 0 ? _j : "combine";
    function checkbox_checked_binding(value) {
      duplicateCheckKey = value;
      $$invalidate(1, duplicateCheckKey);
    }
    __name(checkbox_checked_binding, "checkbox_checked_binding");
    function checkbox_checked_binding_1(value) {
      duplicateCheckDOI = value;
      $$invalidate(2, duplicateCheckDOI);
    }
    __name(checkbox_checked_binding_1, "checkbox_checked_binding_1");
    function checkbox_checked_binding_2(value) {
      duplicateCheckCitation = value;
      $$invalidate(3, duplicateCheckCitation);
    }
    __name(checkbox_checked_binding_2, "checkbox_checked_binding_2");
    function checkbox_checked_binding_3(value) {
      duplicateCheckAbstract = value;
      $$invalidate(4, duplicateCheckAbstract);
    }
    __name(checkbox_checked_binding_3, "checkbox_checked_binding_3");
    function option0_checked_binding(value) {
      duplicateCheckChecked = value;
      $$invalidate(0, duplicateCheckChecked);
    }
    __name(option0_checked_binding, "option0_checked_binding");
    function radio_group_binding(value) {
      mergeValue = value;
      $$invalidate(6, mergeValue);
    }
    __name(radio_group_binding, "radio_group_binding");
    function radio_group_binding_1(value) {
      mergeValue = value;
      $$invalidate(6, mergeValue);
    }
    __name(radio_group_binding_1, "radio_group_binding_1");
    function radio_group_binding_2(value) {
      mergeValue = value;
      $$invalidate(6, mergeValue);
    }
    __name(radio_group_binding_2, "radio_group_binding_2");
    function radio_group_binding_3(value) {
      mergeValue = value;
      $$invalidate(6, mergeValue);
    }
    __name(radio_group_binding_3, "radio_group_binding_3");
    function option1_checked_binding(value) {
      mergeChecked = value;
      $$invalidate(5, mergeChecked);
    }
    __name(option1_checked_binding, "option1_checked_binding");
    $$self.$$set = ($$props2) => {
      if ("options" in $$props2) $$invalidate(7, (options = $$props2.options));
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 255) {
        $: {
          if (duplicateCheckChecked) {
            $$invalidate(7, (options.duplicates = []), options);
            if (duplicateCheckKey) options.duplicates.push("key");
            if (duplicateCheckDOI) options.duplicates.push("doi");
            if (duplicateCheckCitation) options.duplicates.push("citation");
            if (duplicateCheckAbstract) options.duplicates.push("abstract");
          } else {
            $$invalidate(7, (options.duplicates = void 0), options);
          }
          $$invalidate(7, (options.merge = mergeChecked ? mergeValue : void 0), options);
        }
      }
    };
    return [
      duplicateCheckChecked,
      duplicateCheckKey,
      duplicateCheckDOI,
      duplicateCheckCitation,
      duplicateCheckAbstract,
      mergeChecked,
      mergeValue,
      options,
      checkbox_checked_binding,
      checkbox_checked_binding_1,
      checkbox_checked_binding_2,
      checkbox_checked_binding_3,
      option0_checked_binding,
      radio_group_binding,
      radio_group_binding_1,
      radio_group_binding_2,
      radio_group_binding_3,
      option1_checked_binding,
    ];
  }
  __name(instance11, "instance");
  var DuplicateOptions = class DuplicateOptions extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance11, create_fragment11, safe_not_equal, {
        options: 7,
      });
    }
  };
  __name(DuplicateOptions, "DuplicateOptions");
  var DuplicateOptions_default = DuplicateOptions;
  // src/ui/FeedbackError.svelte
  function create_else_block_1(ctx) {
    var strong;
    var br0;
    var t1;
    var t2;
    var br1;
    var t3;
    return {
      c() {
        strong = element("strong");
        strong.textContent = "There's a problem with the bibtex";
        br0 = element("br");
        t1 = text("\n			Unknown error: ");
        t2 = text(ctx[0]);
        br1 = element("br");
        t3 = text("\n			This is probably a bug.");
      },
      m(target, anchor) {
        insert(target, strong, anchor);
        insert(target, br0, anchor);
        insert(target, t1, anchor);
        insert(target, t2, anchor);
        insert(target, br1, anchor);
        insert(target, t3, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & 1) set_data(t2, ctx2[0]);
      },
      d(detaching) {
        if (detaching) detach(strong);
        if (detaching) detach(br0);
        if (detaching) detach(t1);
        if (detaching) detach(t2);
        if (detaching) detach(br1);
        if (detaching) detach(t3);
      },
    };
  }
  __name(create_else_block_1, "create_else_block_1");
  function create_if_block3(ctx) {
    var strong;
    var br0;
    var t1;
    var t2_value = ctx[0].name + "";
    var t2;
    var t3;
    var t4_value = ctx[0].line + "";
    var t4;
    var t5;
    var t6_value = ctx[0].column + "";
    var t6;
    var br1;
    var t7;
    var if_block_anchor;
    function select_block_type_1(ctx2, dirty) {
      if (ctx2[0].hint) return create_if_block_12;
      return create_else_block;
    }
    __name(select_block_type_1, "select_block_type_1");
    var current_block_type = select_block_type_1(ctx, -1);
    var if_block = current_block_type(ctx);
    return {
      c() {
        strong = element("strong");
        strong.textContent = "There's a problem with the bibtex";
        br0 = element("br");
        t1 = space();
        t2 = text(t2_value);
        t3 = text(" on line ");
        t4 = text(t4_value);
        t5 = text(" column ");
        t6 = text(t6_value);
        br1 = element("br");
        t7 = space();
        if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        insert(target, strong, anchor);
        insert(target, br0, anchor);
        insert(target, t1, anchor);
        insert(target, t2, anchor);
        insert(target, t3, anchor);
        insert(target, t4, anchor);
        insert(target, t5, anchor);
        insert(target, t6, anchor);
        insert(target, br1, anchor);
        insert(target, t7, anchor);
        if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & 1 && t2_value !== (t2_value = ctx2[0].name + "")) set_data(t2, t2_value);
        if (dirty & 1 && t4_value !== (t4_value = ctx2[0].line + "")) set_data(t4, t4_value);
        if (dirty & 1 && t6_value !== (t6_value = ctx2[0].column + "")) set_data(t6, t6_value);
        if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block.d(1);
          if_block = current_block_type(ctx2);
          if (if_block) {
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        }
      },
      d(detaching) {
        if (detaching) detach(strong);
        if (detaching) detach(br0);
        if (detaching) detach(t1);
        if (detaching) detach(t2);
        if (detaching) detach(t3);
        if (detaching) detach(t4);
        if (detaching) detach(t5);
        if (detaching) detach(t6);
        if (detaching) detach(br1);
        if (detaching) detach(t7);
        if_block.d(detaching);
        if (detaching) detach(if_block_anchor);
      },
    };
  }
  __name(create_if_block3, "create_if_block");
  function create_else_block(ctx) {
    var t0;
    var t1_value = JSON.stringify(ctx[0].char) + "";
    var t1;
    var t2;
    var t3_value = ctx[0].node.type + "";
    var t3;
    var t4;
    return {
      c() {
        t0 = text("Unexpected ");
        t1 = text(t1_value);
        t2 = text(" in ");
        t3 = text(t3_value);
        t4 = text(".");
      },
      m(target, anchor) {
        insert(target, t0, anchor);
        insert(target, t1, anchor);
        insert(target, t2, anchor);
        insert(target, t3, anchor);
        insert(target, t4, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & 1 && t1_value !== (t1_value = JSON.stringify(ctx2[0].char) + "")) set_data(t1, t1_value);
        if (dirty & 1 && t3_value !== (t3_value = ctx2[0].node.type + "")) set_data(t3, t3_value);
      },
      d(detaching) {
        if (detaching) detach(t0);
        if (detaching) detach(t1);
        if (detaching) detach(t2);
        if (detaching) detach(t3);
        if (detaching) detach(t4);
      },
    };
  }
  __name(create_else_block, "create_else_block");
  function create_if_block_12(ctx) {
    var t_value = ctx[0].hint + "";
    var t2;
    return {
      c() {
        t2 = text(t_value);
      },
      m(target, anchor) {
        insert(target, t2, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & 1 && t_value !== (t_value = ctx2[0].hint + "")) set_data(t2, t_value);
      },
      d(detaching) {
        if (detaching) detach(t2);
      },
    };
  }
  __name(create_if_block_12, "create_if_block_1");
  function create_fragment12(ctx) {
    var div1;
    var svg2;
    var circle;
    var line0;
    var line1;
    var t2;
    var div0;
    function select_block_type(ctx2, dirty) {
      if (ctx2[0] instanceof BibTeXSyntaxError) return create_if_block3;
      return create_else_block_1;
    }
    __name(select_block_type, "select_block_type");
    var current_block_type = select_block_type(ctx, -1);
    var if_block = current_block_type(ctx);
    return {
      c() {
        div1 = element("div");
        svg2 = svg_element("svg");
        circle = svg_element("circle");
        line0 = svg_element("line");
        line1 = svg_element("line");
        t2 = space();
        div0 = element("div");
        if_block.c();
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "10");
        attr(circle, "class", "svelte-176xcb");
        attr(line0, "x1", "12");
        attr(line0, "y1", "8");
        attr(line0, "x2", "12");
        attr(line0, "y2", "12");
        attr(line0, "class", "svelte-176xcb");
        attr(line1, "x1", "12");
        attr(line1, "y1", "16");
        attr(line1, "x2", "12.01");
        attr(line1, "y2", "16");
        attr(line1, "class", "svelte-176xcb");
        attr(svg2, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg2, "width", "24");
        attr(svg2, "height", "24");
        attr(svg2, "viewBox", "0 0 24 24");
        attr(svg2, "fill", "none");
        attr(svg2, "stroke", "currentColor");
        attr(svg2, "stroke-width", "2");
        attr(svg2, "stroke-linecap", "round");
        attr(svg2, "stroke-linejoin", "round");
        attr(svg2, "class", "svelte-176xcb");
        attr(div0, "class", "text");
        attr(div1, "class", "container svelte-176xcb");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, svg2);
        append(svg2, circle);
        append(svg2, line0);
        append(svg2, line1);
        append(div1, t2);
        append(div1, div0);
        if_block.m(div0, null);
      },
      p(ctx2, param) {
        var _param = _slicedToArray(param, 1),
          dirty = _param[0];
        if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block.d(1);
          if_block = current_block_type(ctx2);
          if (if_block) {
            if_block.c();
            if_block.m(div0, null);
          }
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) detach(div1);
        if_block.d();
      },
    };
  }
  __name(create_fragment12, "create_fragment");
  function instance12($$self, $$props, $$invalidate) {
    var error = $$props.error;
    $$self.$$set = ($$props2) => {
      if ("error" in $$props2) $$invalidate(0, (error = $$props2.error));
    };
    return [error];
  }
  __name(instance12, "instance");
  var FeedbackError = class FeedbackError extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance12, create_fragment12, safe_not_equal, {
        error: 0,
      });
    }
  };
  __name(FeedbackError, "FeedbackError");
  var FeedbackError_default = FeedbackError;
  // src/ui/FeedbackSuccess.svelte
  function get_each_context2(ctx, list, i) {
    var child_ctx = ctx.slice();
    child_ctx[4] = list[i];
    return child_ctx;
  }
  __name(get_each_context2, "get_each_context");
  function get_each_context_1(ctx, list, i) {
    var child_ctx = ctx.slice();
    child_ctx[7] = list[i];
    return child_ctx;
  }
  __name(get_each_context_1, "get_each_context_1");
  function create_if_block_2(ctx) {
    var ul;
    var each_value_1 = ctx[2];
    var each_blocks = [];
    for (var i = 0; i < each_value_1.length; i += 1) {
      each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    }
    return {
      c() {
        ul = element("ul");
        for (var i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
      },
      m(target, anchor) {
        insert(target, ul, anchor);
        for (var i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].m(ul, null);
        }
      },
      p(ctx2, dirty) {
        if (dirty & 4) {
          each_value_1 = ctx2[2];
          var i;
          for (i = 0; i < each_value_1.length; i += 1) {
            var child_ctx = get_each_context_1(ctx2, each_value_1, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block_1(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(ul, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value_1.length;
        }
      },
      d(detaching) {
        if (detaching) detach(ul);
        destroy_each(each_blocks, detaching);
      },
    };
  }
  __name(create_if_block_2, "create_if_block_2");
  function create_each_block_1(ctx) {
    var li;
    var t0;
    var t1_value = ctx[7].message + "";
    var t1;
    return {
      c() {
        li = element("li");
        t0 = text("$");
        t1 = text(t1_value);
      },
      m(target, anchor) {
        insert(target, li, anchor);
        append(li, t0);
        append(li, t1);
      },
      p: noop,
      d(detaching) {
        if (detaching) detach(li);
      },
    };
  }
  __name(create_each_block_1, "create_each_block_1");
  function create_if_block4(ctx) {
    var if_block_anchor;
    function select_block_type(ctx2, dirty) {
      if (ctx2[3].length === 0) return create_if_block_13;
      return create_else_block2;
    }
    __name(select_block_type, "select_block_type");
    var current_block_type = select_block_type(ctx, -1);
    var if_block = current_block_type(ctx);
    return {
      c() {
        if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if_block.p(ctx2, dirty);
      },
      d(detaching) {
        if_block.d(detaching);
        if (detaching) detach(if_block_anchor);
      },
    };
  }
  __name(create_if_block4, "create_if_block");
  function create_else_block2(ctx) {
    var strong;
    var t2;
    var ul;
    var each_value = ctx[3];
    var each_blocks = [];
    for (var i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
    }
    return {
      c() {
        strong = element("strong");
        strong.textContent = "".concat(ctx[3].length, " merged:");
        t2 = space();
        ul = element("ul");
        for (var i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(strong, "class", "svelte-yy7yvg");
      },
      m(target, anchor) {
        insert(target, strong, anchor);
        insert(target, t2, anchor);
        insert(target, ul, anchor);
        for (var i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].m(ul, null);
        }
      },
      p(ctx2, dirty) {
        if (dirty & 8) {
          each_value = ctx2[3];
          var i;
          for (i = 0; i < each_value.length; i += 1) {
            var child_ctx = get_each_context2(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block2(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(ul, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
      },
      d(detaching) {
        if (detaching) detach(strong);
        if (detaching) detach(t2);
        if (detaching) detach(ul);
        destroy_each(each_blocks, detaching);
      },
    };
  }
  __name(create_else_block2, "create_else_block");
  function create_if_block_13(ctx) {
    var t2;
    return {
      c() {
        t2 = text("No duplicates");
      },
      m(target, anchor) {
        insert(target, t2, anchor);
      },
      p: noop,
      d(detaching) {
        if (detaching) detach(t2);
      },
    };
  }
  __name(create_if_block_13, "create_if_block_1");
  function create_each_block2(ctx) {
    var li;
    var t_value = ctx[4].message + "";
    var t2;
    return {
      c() {
        li = element("li");
        t2 = text(t_value);
      },
      m(target, anchor) {
        insert(target, li, anchor);
        append(li, t2);
      },
      p: noop,
      d(detaching) {
        if (detaching) detach(li);
      },
    };
  }
  __name(create_each_block2, "create_each_block");
  function create_fragment13(ctx) {
    var div1;
    var svg2;
    var circle;
    var line0;
    var line1;
    var t0;
    var div0;
    var strong;
    var br;
    var t2;
    var t3_value = ctx[1].count + "";
    var t3;
    var t4;
    var t5;
    var if_block0 = ctx[2].length > 0 && create_if_block_2(ctx);
    var if_block1 = ctx[0].merge && create_if_block4(ctx);
    return {
      c() {
        div1 = element("div");
        svg2 = svg_element("svg");
        circle = svg_element("circle");
        line0 = svg_element("line");
        line1 = svg_element("line");
        t0 = space();
        div0 = element("div");
        strong = element("strong");
        strong.textContent = "Successful!";
        br = element("br");
        t2 = text("\n		Tidied ");
        t3 = text(t3_value);
        t4 = text(" entries.\n\n		");
        if (if_block0) if_block0.c();
        t5 = space();
        if (if_block1) if_block1.c();
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "10");
        attr(circle, "class", "svelte-yy7yvg");
        attr(line0, "x1", "12");
        attr(line0, "y1", "16");
        attr(line0, "x2", "12");
        attr(line0, "y2", "12");
        attr(line0, "class", "svelte-yy7yvg");
        attr(line1, "x1", "12");
        attr(line1, "y1", "8");
        attr(line1, "x2", "12.01");
        attr(line1, "y2", "8");
        attr(line1, "class", "svelte-yy7yvg");
        attr(svg2, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg2, "width", "24");
        attr(svg2, "height", "24");
        attr(svg2, "viewBox", "0 0 24 24");
        attr(svg2, "fill", "none");
        attr(svg2, "stroke", "currentColor");
        attr(svg2, "stroke-width", "2");
        attr(svg2, "stroke-linecap", "round");
        attr(svg2, "stroke-linejoin", "round");
        attr(svg2, "class", "feather feather-info svelte-yy7yvg");
        attr(strong, "class", "svelte-yy7yvg");
        attr(div0, "class", "text");
        attr(div1, "class", "container svelte-yy7yvg");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, svg2);
        append(svg2, circle);
        append(svg2, line0);
        append(svg2, line1);
        append(div1, t0);
        append(div1, div0);
        append(div0, strong);
        append(div0, br);
        append(div0, t2);
        append(div0, t3);
        append(div0, t4);
        if (if_block0) if_block0.m(div0, null);
        append(div0, t5);
        if (if_block1) if_block1.m(div0, null);
      },
      p(ctx2, param) {
        var _param = _slicedToArray(param, 1),
          dirty = _param[0];
        if (dirty & 2 && t3_value !== (t3_value = ctx2[1].count + "")) set_data(t3, t3_value);
        if (ctx2[2].length > 0) if_block0.p(ctx2, dirty);
        if (ctx2[0].merge) {
          if (if_block1) {
            if_block1.p(ctx2, dirty);
          } else {
            if_block1 = create_if_block4(ctx2);
            if_block1.c();
            if_block1.m(div0, null);
          }
        } else if (if_block1) {
          if_block1.d(1);
          if_block1 = null;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) detach(div1);
        if (if_block0) if_block0.d();
        if (if_block1) if_block1.d();
      },
    };
  }
  __name(create_fragment13, "create_fragment");
  function instance13($$self, $$props, $$invalidate) {
    var options = $$props.options;
    var result = $$props.result;
    var warnings = result.warnings.filter((w) => w.code !== "DUPLICATE_ENTRY");
    var dupes = result.warnings.filter((w) => w.code === "DUPLICATE_ENTRY");
    $$self.$$set = ($$props2) => {
      if ("options" in $$props2) $$invalidate(0, (options = $$props2.options));
      if ("result" in $$props2) $$invalidate(1, (result = $$props2.result));
    };
    return [options, result, warnings, dupes];
  }
  __name(instance13, "instance");
  var FeedbackSuccess = class FeedbackSuccess extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance13, create_fragment13, safe_not_equal, {
        options: 0,
        result: 1,
      });
    }
  };
  __name(FeedbackSuccess, "FeedbackSuccess");
  var FeedbackSuccess_default = FeedbackSuccess;
  // src/ui/Feedback.svelte
  function create_else_block3(ctx) {
    var feedbackerror;
    var current;
    feedbackerror = new FeedbackError_default({
      props: {
        error: ctx[1].error,
      },
    });
    return {
      c() {
        create_component(feedbackerror.$$.fragment);
      },
      m(target, anchor) {
        mount_component(feedbackerror, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        var feedbackerror_changes = {};
        if (dirty & 2) feedbackerror_changes.error = ctx2[1].error;
        feedbackerror.$set(feedbackerror_changes);
      },
      i(local) {
        if (current) return;
        transition_in(feedbackerror.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(feedbackerror.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(feedbackerror, detaching);
      },
    };
  }
  __name(create_else_block3, "create_else_block");
  function create_if_block5(ctx) {
    var feedbacksuccess;
    var current;
    feedbacksuccess = new FeedbackSuccess_default({
      props: {
        options: ctx[0],
        result: ctx[1].result,
      },
    });
    return {
      c() {
        create_component(feedbacksuccess.$$.fragment);
      },
      m(target, anchor) {
        mount_component(feedbacksuccess, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        var feedbacksuccess_changes = {};
        if (dirty & 1) feedbacksuccess_changes.options = ctx2[0];
        if (dirty & 2) feedbacksuccess_changes.result = ctx2[1].result;
        feedbacksuccess.$set(feedbacksuccess_changes);
      },
      i(local) {
        if (current) return;
        transition_in(feedbacksuccess.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(feedbacksuccess.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(feedbacksuccess, detaching);
      },
    };
  }
  __name(create_if_block5, "create_if_block");
  function create_fragment14(ctx) {
    var div;
    var current_block_type_index;
    var if_block;
    var current;
    var if_block_creators = [create_if_block5, create_else_block3];
    var if_blocks = [];
    function select_block_type(ctx2, dirty) {
      if (ctx2[1].status === "success") return 0;
      return 1;
    }
    __name(select_block_type, "select_block_type");
    current_block_type_index = select_block_type(ctx, -1);
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    return {
      c() {
        div = element("div");
        if_block.c();
        attr(div, "data-test-feedback", "");
        attr(div, "class", "svelte-1pqmac");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        if_blocks[current_block_type_index].m(div, null);
        current = true;
      },
      p(ctx2, param) {
        var _param = _slicedToArray(param, 1),
          dirty = _param[0];
        var previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type(ctx2, dirty);
        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      },
      i(local) {
        if (current) return;
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (detaching) detach(div);
        if_blocks[current_block_type_index].d();
      },
    };
  }
  __name(create_fragment14, "create_fragment");
  function instance14($$self, $$props, $$invalidate) {
    var options = $$props.options;
    var status = $$props.status;
    $$self.$$set = ($$props2) => {
      if ("options" in $$props2) $$invalidate(0, (options = $$props2.options));
      if ("status" in $$props2) $$invalidate(1, (status = $$props2.status));
    };
    return [options, status];
  }
  __name(instance14, "instance");
  var Feedback = class Feedback extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance14, create_fragment14, safe_not_equal, {
        options: 0,
        status: 1,
      });
    }
  };
  __name(Feedback, "Feedback");
  var Feedback_default = Feedback;
  // src/ui/IndentOptions.svelte
  function create_default_slot_32(ctx) {
    var radio;
    var updating_group;
    var t2;
    var current;
    function radio_group_binding(value) {
      ctx[3](value);
    }
    __name(radio_group_binding, "radio_group_binding");
    var radio_props = {
      name: "indent",
      value: "tabs",
    };
    if (ctx[0] !== void 0) {
      radio_props.group = ctx[0];
    }
    radio = new Radio_default({
      props: radio_props,
    });
    binding_callbacks.push(() => bind(radio, "group", radio_group_binding));
    return {
      c() {
        create_component(radio.$$.fragment);
        t2 = text("\n		Indent with tabs");
      },
      m(target, anchor) {
        mount_component(radio, target, anchor);
        insert(target, t2, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        var radio_changes = {};
        if (!updating_group && dirty & 1) {
          updating_group = true;
          radio_changes.group = ctx2[0];
          add_flush_callback(() => (updating_group = false));
        }
        radio.$set(radio_changes);
      },
      i(local) {
        if (current) return;
        transition_in(radio.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(radio.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(radio, detaching);
        if (detaching) detach(t2);
      },
    };
  }
  __name(create_default_slot_32, "create_default_slot_3");
  function create_default_slot_23(ctx) {
    var radio;
    var updating_group;
    var t2;
    var current;
    function radio_group_binding_1(value) {
      ctx[4](value);
    }
    __name(radio_group_binding_1, "radio_group_binding_1");
    var radio_props = {
      name: "indent",
      value: "spaces",
    };
    if (ctx[0] !== void 0) {
      radio_props.group = ctx[0];
    }
    radio = new Radio_default({
      props: radio_props,
    });
    binding_callbacks.push(() => bind(radio, "group", radio_group_binding_1));
    return {
      c() {
        create_component(radio.$$.fragment);
        t2 = text("\n		Indent with spaces");
      },
      m(target, anchor) {
        mount_component(radio, target, anchor);
        insert(target, t2, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        var radio_changes = {};
        if (!updating_group && dirty & 1) {
          updating_group = true;
          radio_changes.group = ctx2[0];
          add_flush_callback(() => (updating_group = false));
        }
        radio.$set(radio_changes);
      },
      i(local) {
        if (current) return;
        transition_in(radio.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(radio.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(radio, detaching);
        if (detaching) detach(t2);
      },
    };
  }
  __name(create_default_slot_23, "create_default_slot_2");
  function create_if_block6(ctx) {
    var suboptions;
    var current;
    suboptions = new SubOptions_default({
      props: {
        $$slots: {
          default: [create_default_slot_14],
        },
        $$scope: {
          ctx,
        },
      },
    });
    return {
      c() {
        create_component(suboptions.$$.fragment);
      },
      m(target, anchor) {
        mount_component(suboptions, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        var suboptions_changes = {};
        if (dirty & 66) {
          suboptions_changes.$$scope = {
            dirty,
            ctx: ctx2,
          };
        }
        suboptions.$set(suboptions_changes);
      },
      i(local) {
        if (current) return;
        transition_in(suboptions.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(suboptions.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(suboptions, detaching);
      },
    };
  }
  __name(create_if_block6, "create_if_block");
  function create_default_slot_14(ctx) {
    var label;
    var t2;
    var input;
    var mounted;
    var dispose;
    return {
      c() {
        label = element("label");
        t2 = text("Spaces: ");
        input = element("input");
        attr(input, "name", "spaces");
        attr(input, "type", "number");
      },
      m(target, anchor) {
        insert(target, label, anchor);
        append(label, t2);
        append(label, input);
        set_input_value(input, ctx[1]);
        if (!mounted) {
          dispose = listen(input, "input", ctx[5]);
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (dirty & 2 && to_number(input.value) !== ctx2[1]) {
          set_input_value(input, ctx2[1]);
        }
      },
      d(detaching) {
        if (detaching) detach(label);
        mounted = false;
        dispose();
      },
    };
  }
  __name(create_default_slot_14, "create_default_slot_1");
  function create_default_slot5(ctx) {
    var label0;
    var t0;
    var label1;
    var t1;
    var if_block_anchor;
    var current;
    label0 = new Label_default({
      props: {
        title: "Indent fields with tabs",
        $$slots: {
          default: [create_default_slot_32],
        },
        $$scope: {
          ctx,
        },
      },
    });
    label1 = new Label_default({
      props: {
        title: "Indent fields with spaces",
        $$slots: {
          default: [create_default_slot_23],
        },
        $$scope: {
          ctx,
        },
      },
    });
    var if_block = ctx[0] === "spaces" && create_if_block6(ctx);
    return {
      c() {
        create_component(label0.$$.fragment);
        t0 = space();
        create_component(label1.$$.fragment);
        t1 = space();
        if (if_block) if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        mount_component(label0, target, anchor);
        insert(target, t0, anchor);
        mount_component(label1, target, anchor);
        insert(target, t1, anchor);
        if (if_block) if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        var label0_changes = {};
        if (dirty & 65) {
          label0_changes.$$scope = {
            dirty,
            ctx: ctx2,
          };
        }
        label0.$set(label0_changes);
        var label1_changes = {};
        if (dirty & 65) {
          label1_changes.$$scope = {
            dirty,
            ctx: ctx2,
          };
        }
        label1.$set(label1_changes);
        if (ctx2[0] === "spaces") {
          if (if_block) {
            if_block.p(ctx2, dirty);
            if (dirty & 1) {
              transition_in(if_block, 1);
            }
          } else {
            if_block = create_if_block6(ctx2);
            if_block.c();
            transition_in(if_block, 1);
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          group_outros();
          transition_out(if_block, 1, 1, () => {
            if_block = null;
          });
          check_outros();
        }
      },
      i(local) {
        if (current) return;
        transition_in(label0.$$.fragment, local);
        transition_in(label1.$$.fragment, local);
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(label0.$$.fragment, local);
        transition_out(label1.$$.fragment, local);
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        destroy_component(label0, detaching);
        if (detaching) detach(t0);
        destroy_component(label1, detaching);
        if (detaching) detach(t1);
        if (if_block) if_block.d(detaching);
        if (detaching) detach(if_block_anchor);
      },
    };
  }
  __name(create_default_slot5, "create_default_slot");
  function create_fragment15(ctx) {
    var collapsible;
    var current;
    collapsible = new Collapsible_default({
      props: {
        title: "Indent",
        open: true,
        $$slots: {
          default: [create_default_slot5],
        },
        $$scope: {
          ctx,
        },
      },
    });
    return {
      c() {
        create_component(collapsible.$$.fragment);
      },
      m(target, anchor) {
        mount_component(collapsible, target, anchor);
        current = true;
      },
      p(ctx2, param) {
        var _param = _slicedToArray(param, 1),
          dirty = _param[0];
        var collapsible_changes = {};
        if (dirty & 67) {
          collapsible_changes.$$scope = {
            dirty,
            ctx: ctx2,
          };
        }
        collapsible.$set(collapsible_changes);
      },
      i(local) {
        if (current) return;
        transition_in(collapsible.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(collapsible.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(collapsible, detaching);
      },
    };
  }
  __name(create_fragment15, "create_fragment");
  function instance15($$self, $$props, $$invalidate) {
    var options = $$props.options;
    var indent = options.tab ? "tabs" : "spaces";
    var spaceValue = options.space;
    function radio_group_binding(value) {
      indent = value;
      $$invalidate(0, indent);
    }
    __name(radio_group_binding, "radio_group_binding");
    function radio_group_binding_1(value) {
      indent = value;
      $$invalidate(0, indent);
    }
    __name(radio_group_binding_1, "radio_group_binding_1");
    function input_input_handler() {
      spaceValue = to_number(this.value);
      $$invalidate(1, spaceValue);
    }
    __name(input_input_handler, "input_input_handler");
    $$self.$$set = ($$props2) => {
      if ("options" in $$props2) $$invalidate(2, (options = $$props2.options));
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 3) {
        $: {
          $$invalidate(2, (options.space = spaceValue), options);
          $$invalidate(2, (options.tab = indent === "tabs"), options);
        }
      }
    };
    return [indent, spaceValue, options, radio_group_binding, radio_group_binding_1, input_input_handler];
  }
  __name(instance15, "instance");
  var IndentOptions = class IndentOptions extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance15, create_fragment15, safe_not_equal, {
        options: 2,
      });
    }
  };
  __name(IndentOptions, "IndentOptions");
  var IndentOptions_default = IndentOptions;
  // src/ui/SortingOptions.svelte
  function create_default_slot_24(ctx) {
    var label;
    var t0;
    var textarea;
    var t1;
    var p;
    var mounted;
    var dispose;
    return {
      c() {
        label = element("label");
        t0 = text("Fields to sort by:\n			");
        textarea = element("textarea");
        t1 = space();
        p = element("p");
        p.innerHTML = "Space delimited, e.g: <code>key type publisher author</code>. For\n			descending order, prefix the field name with a dash, e.g.\n			<code>-year author</code>.";
        attr(textarea, "name", "sortList");
        attr(textarea, "spellcheck", "false");
      },
      m(target, anchor) {
        insert(target, label, anchor);
        append(label, t0);
        append(label, textarea);
        set_input_value(textarea, ctx[3]);
        insert(target, t1, anchor);
        insert(target, p, anchor);
        if (!mounted) {
          dispose = listen(textarea, "input", ctx[5]);
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (dirty & 8) {
          set_input_value(textarea, ctx2[3]);
        }
      },
      d(detaching) {
        if (detaching) detach(label);
        if (detaching) detach(t1);
        if (detaching) detach(p);
        mounted = false;
        dispose();
      },
    };
  }
  __name(create_default_slot_24, "create_default_slot_2");
  function create_default_slot_15(ctx) {
    var label;
    var t0;
    var textarea;
    var t1;
    var p;
    var mounted;
    var dispose;
    return {
      c() {
        label = element("label");
        t0 = text("Field order:\n			");
        textarea = element("textarea");
        t1 = space();
        p = element("p");
        p.innerHTML = "Space delimited, e.g: <code>title author year</code>";
        attr(textarea, "name", "sortFieldList");
        attr(textarea, "spellcheck", "false");
      },
      m(target, anchor) {
        insert(target, label, anchor);
        append(label, t0);
        append(label, textarea);
        set_input_value(textarea, ctx[1]);
        insert(target, t1, anchor);
        insert(target, p, anchor);
        if (!mounted) {
          dispose = listen(textarea, "input", ctx[7]);
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (dirty & 2) {
          set_input_value(textarea, ctx2[1]);
        }
      },
      d(detaching) {
        if (detaching) detach(label);
        if (detaching) detach(t1);
        if (detaching) detach(p);
        mounted = false;
        dispose();
      },
    };
  }
  __name(create_default_slot_15, "create_default_slot_1");
  function create_default_slot6(ctx) {
    var option0;
    var updating_checked;
    var t2;
    var option1;
    var updating_checked_1;
    var current;
    function option0_checked_binding(value) {
      ctx[6](value);
    }
    __name(option0_checked_binding, "option0_checked_binding");
    var option0_props = {
      option: "sort",
      $$slots: {
        default: [create_default_slot_24],
      },
      $$scope: {
        ctx,
      },
    };
    if (ctx[2] !== void 0) {
      option0_props.checked = ctx[2];
    }
    option0 = new Option_default({
      props: option0_props,
    });
    binding_callbacks.push(() => bind(option0, "checked", option0_checked_binding));
    function option1_checked_binding(value) {
      ctx[8](value);
    }
    __name(option1_checked_binding, "option1_checked_binding");
    var option1_props = {
      option: "sortFields",
      $$slots: {
        default: [create_default_slot_15],
      },
      $$scope: {
        ctx,
      },
    };
    if (ctx[0] !== void 0) {
      option1_props.checked = ctx[0];
    }
    option1 = new Option_default({
      props: option1_props,
    });
    binding_callbacks.push(() => bind(option1, "checked", option1_checked_binding));
    return {
      c() {
        create_component(option0.$$.fragment);
        t2 = space();
        create_component(option1.$$.fragment);
      },
      m(target, anchor) {
        mount_component(option0, target, anchor);
        insert(target, t2, anchor);
        mount_component(option1, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        var option0_changes = {};
        if (dirty & 2056) {
          option0_changes.$$scope = {
            dirty,
            ctx: ctx2,
          };
        }
        if (!updating_checked && dirty & 4) {
          updating_checked = true;
          option0_changes.checked = ctx2[2];
          add_flush_callback(() => (updating_checked = false));
        }
        option0.$set(option0_changes);
        var option1_changes = {};
        if (dirty & 2050) {
          option1_changes.$$scope = {
            dirty,
            ctx: ctx2,
          };
        }
        if (!updating_checked_1 && dirty & 1) {
          updating_checked_1 = true;
          option1_changes.checked = ctx2[0];
          add_flush_callback(() => (updating_checked_1 = false));
        }
        option1.$set(option1_changes);
      },
      i(local) {
        if (current) return;
        transition_in(option0.$$.fragment, local);
        transition_in(option1.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(option0.$$.fragment, local);
        transition_out(option1.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(option0, detaching);
        if (detaching) detach(t2);
        destroy_component(option1, detaching);
      },
    };
  }
  __name(create_default_slot6, "create_default_slot");
  function create_fragment16(ctx) {
    var collapsible;
    var current;
    collapsible = new Collapsible_default({
      props: {
        title: "Sorting",
        open: true,
        $$slots: {
          default: [create_default_slot6],
        },
        $$scope: {
          ctx,
        },
      },
    });
    return {
      c() {
        create_component(collapsible.$$.fragment);
      },
      m(target, anchor) {
        mount_component(collapsible, target, anchor);
        current = true;
      },
      p(ctx2, param) {
        var _param = _slicedToArray(param, 1),
          dirty = _param[0];
        var collapsible_changes = {};
        if (dirty & 2063) {
          collapsible_changes.$$scope = {
            dirty,
            ctx: ctx2,
          };
        }
        collapsible.$set(collapsible_changes);
      },
      i(local) {
        if (current) return;
        transition_in(collapsible.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(collapsible.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(collapsible, detaching);
      },
    };
  }
  __name(create_fragment16, "create_fragment");
  function instance16($$self, $$props, $$invalidate) {
    var _a2, _b;
    var options = $$props.options;
    var sortFieldsChecked = options.sortFields !== void 0 && options.sortFields.length > 0;
    var sortFieldsValue = ((_a2 = options.sortFields) !== null && _a2 !== void 0 ? _a2 : DEFAULT_FIELD_SORT).join(" ");
    var sortChecked = options.sort !== void 0 && options.sort.length > 0;
    var sortValue = ((_b = options.sort) !== null && _b !== void 0 ? _b : DEFAULT_SORT).join(" ");
    function textarea_input_handler() {
      sortValue = this.value;
      $$invalidate(3, sortValue);
    }
    __name(textarea_input_handler, "textarea_input_handler");
    function option0_checked_binding(value) {
      sortChecked = value;
      $$invalidate(2, sortChecked);
    }
    __name(option0_checked_binding, "option0_checked_binding");
    function textarea_input_handler_1() {
      sortFieldsValue = this.value;
      $$invalidate(1, sortFieldsValue);
    }
    __name(textarea_input_handler_1, "textarea_input_handler_1");
    function option1_checked_binding(value) {
      sortFieldsChecked = value;
      $$invalidate(0, sortFieldsChecked);
    }
    __name(option1_checked_binding, "option1_checked_binding");
    $$self.$$set = ($$props2) => {
      if ("options" in $$props2) $$invalidate(4, (options = $$props2.options));
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 15) {
        $: {
          $$invalidate(4, (options.sortFields = sortFieldsChecked && sortFieldsValue.length > 0 ? sortFieldsValue.split(/[\n\t ,]+/) : void 0), options);
          $$invalidate(4, (options.sort = sortChecked && sortValue.length > 0 ? sortValue.split(/[\n\t ,]+/) : void 0), options);
        }
      }
    };
    return [sortFieldsChecked, sortFieldsValue, sortChecked, sortValue, options, textarea_input_handler, option0_checked_binding, textarea_input_handler_1, option1_checked_binding];
  }
  __name(instance16, "instance");
  var SortingOptions = class SortingOptions extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance16, create_fragment16, safe_not_equal, {
        options: 4,
      });
    }
  };
  __name(SortingOptions, "SortingOptions");
  var SortingOptions_default = SortingOptions;
  // src/ui/ValueOptions.svelte
  function create_default_slot_33(ctx) {
    var label;
    var t0;
    var textarea;
    var t1;
    var p;
    var mounted;
    var dispose;
    return {
      c() {
        label = element("label");
        t0 = text("Fields to enclose in double braces:\n			");
        textarea = element("textarea");
        t1 = space();
        p = element("p");
        p.innerHTML = "Space delimited, e.g: <code>title journal</code>.";
        attr(textarea, "name", "enclosingBracesList");
        attr(textarea, "spellcheck", "false");
      },
      m(target, anchor) {
        insert(target, label, anchor);
        append(label, t0);
        append(label, textarea);
        set_input_value(textarea, ctx[11]);
        insert(target, t1, anchor);
        insert(target, p, anchor);
        if (!mounted) {
          dispose = listen(textarea, "input", ctx[16]);
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (dirty[0] & 2048) {
          set_input_value(textarea, ctx2[11]);
        }
      },
      d(detaching) {
        if (detaching) detach(label);
        if (detaching) detach(t1);
        if (detaching) detach(p);
        mounted = false;
        dispose();
      },
    };
  }
  __name(create_default_slot_33, "create_default_slot_3");
  function create_default_slot_25(ctx) {
    var label;
    var t0;
    var textarea;
    var t1;
    var p;
    var mounted;
    var dispose;
    return {
      c() {
        label = element("label");
        t0 = text("Remove braces from values of these fields:\n			");
        textarea = element("textarea");
        t1 = space();
        p = element("p");
        p.innerHTML = "Space delimited, e.g: <code>title journal</code>.";
        attr(textarea, "name", "removeBracesList");
        attr(textarea, "spellcheck", "false");
      },
      m(target, anchor) {
        insert(target, label, anchor);
        append(label, t0);
        append(label, textarea);
        set_input_value(textarea, ctx[13]);
        insert(target, t1, anchor);
        insert(target, p, anchor);
        if (!mounted) {
          dispose = listen(textarea, "input", ctx[18]);
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (dirty[0] & 8192) {
          set_input_value(textarea, ctx2[13]);
        }
      },
      d(detaching) {
        if (detaching) detach(label);
        if (detaching) detach(t1);
        if (detaching) detach(p);
        mounted = false;
        dispose();
      },
    };
  }
  __name(create_default_slot_25, "create_default_slot_2");
  function create_default_slot_16(ctx) {
    var label;
    var t0;
    var input;
    var t1;
    var p;
    var mounted;
    var dispose;
    return {
      c() {
        label = element("label");
        t0 = text("Maximum number of authors:\n			");
        input = element("input");
        t1 = space();
        p = element("p");
        p.textContent = 'Author lists longer than this will be truncated to "and others".';
        attr(input, "name", "maxAuthorsNum");
        attr(input, "type", "number");
      },
      m(target, anchor) {
        insert(target, label, anchor);
        append(label, t0);
        append(label, input);
        set_input_value(input, ctx[9]);
        insert(target, t1, anchor);
        insert(target, p, anchor);
        if (!mounted) {
          dispose = listen(input, "input", ctx[27]);
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (dirty[0] & 512 && to_number(input.value) !== ctx2[9]) {
          set_input_value(input, ctx2[9]);
        }
      },
      d(detaching) {
        if (detaching) detach(label);
        if (detaching) detach(t1);
        if (detaching) detach(p);
        mounted = false;
        dispose();
      },
    };
  }
  __name(create_default_slot_16, "create_default_slot_1");
  function create_default_slot7(ctx) {
    var div;
    var t0;
    var option0;
    var updating_checked;
    var t1;
    var option1;
    var updating_checked_1;
    var t2;
    var option2;
    var updating_checked_2;
    var t3;
    var option3;
    var updating_checked_3;
    var t4;
    var option4;
    var updating_checked_4;
    var t5;
    var option5;
    var updating_checked_5;
    var t6;
    var option6;
    var updating_checked_6;
    var t7;
    var option7;
    var updating_checked_7;
    var t8;
    var option8;
    var updating_checked_8;
    var t9;
    var option9;
    var updating_checked_9;
    var t10;
    var option10;
    var updating_checked_10;
    var current;
    function option0_checked_binding(value) {
      ctx[15](value);
    }
    __name(option0_checked_binding, "option0_checked_binding");
    var option0_props = {
      option: "curly",
    };
    if (ctx[0] !== void 0) {
      option0_props.checked = ctx[0];
    }
    option0 = new Option_default({
      props: option0_props,
    });
    binding_callbacks.push(() => bind(option0, "checked", option0_checked_binding));
    function option1_checked_binding(value) {
      ctx[17](value);
    }
    __name(option1_checked_binding, "option1_checked_binding");
    var option1_props = {
      option: "enclosingBraces",
      $$slots: {
        default: [create_default_slot_33],
      },
      $$scope: {
        ctx,
      },
    };
    if (ctx[10] !== void 0) {
      option1_props.checked = ctx[10];
    }
    option1 = new Option_default({
      props: option1_props,
    });
    binding_callbacks.push(() => bind(option1, "checked", option1_checked_binding));
    function option2_checked_binding(value) {
      ctx[19](value);
    }
    __name(option2_checked_binding, "option2_checked_binding");
    var option2_props = {
      option: "removeBraces",
      $$slots: {
        default: [create_default_slot_25],
      },
      $$scope: {
        ctx,
      },
    };
    if (ctx[12] !== void 0) {
      option2_props.checked = ctx[12];
    }
    option2 = new Option_default({
      props: option2_props,
    });
    binding_callbacks.push(() => bind(option2, "checked", option2_checked_binding));
    function option3_checked_binding(value) {
      ctx[20](value);
    }
    __name(option3_checked_binding, "option3_checked_binding");
    var option3_props = {
      option: "stripEnclosingBraces",
    };
    if (ctx[1] !== void 0) {
      option3_props.checked = ctx[1];
    }
    option3 = new Option_default({
      props: option3_props,
    });
    binding_callbacks.push(() => bind(option3, "checked", option3_checked_binding));
    function option4_checked_binding(value) {
      ctx[21](value);
    }
    __name(option4_checked_binding, "option4_checked_binding");
    var option4_props = {
      option: "numeric",
    };
    if (ctx[2] !== void 0) {
      option4_props.checked = ctx[2];
    }
    option4 = new Option_default({
      props: option4_props,
    });
    binding_callbacks.push(() => bind(option4, "checked", option4_checked_binding));
    function option5_checked_binding(value) {
      ctx[22](value);
    }
    __name(option5_checked_binding, "option5_checked_binding");
    var option5_props = {
      option: "dropAllCaps",
    };
    if (ctx[3] !== void 0) {
      option5_props.checked = ctx[3];
    }
    option5 = new Option_default({
      props: option5_props,
    });
    binding_callbacks.push(() => bind(option5, "checked", option5_checked_binding));
    function option6_checked_binding(value) {
      ctx[23](value);
    }
    __name(option6_checked_binding, "option6_checked_binding");
    var option6_props = {
      option: "escape",
    };
    if (ctx[4] !== void 0) {
      option6_props.checked = ctx[4];
    }
    option6 = new Option_default({
      props: option6_props,
    });
    binding_callbacks.push(() => bind(option6, "checked", option6_checked_binding));
    function option7_checked_binding(value) {
      ctx[24](value);
    }
    __name(option7_checked_binding, "option7_checked_binding");
    var option7_props = {
      option: "encodeUrls",
    };
    if (ctx[5] !== void 0) {
      option7_props.checked = ctx[5];
    }
    option7 = new Option_default({
      props: option7_props,
    });
    binding_callbacks.push(() => bind(option7, "checked", option7_checked_binding));
    function option8_checked_binding(value) {
      ctx[25](value);
    }
    __name(option8_checked_binding, "option8_checked_binding");
    var option8_props = {
      option: "removeEmptyFields",
    };
    if (ctx[6] !== void 0) {
      option8_props.checked = ctx[6];
    }
    option8 = new Option_default({
      props: option8_props,
    });
    binding_callbacks.push(() => bind(option8, "checked", option8_checked_binding));
    function option9_checked_binding(value) {
      ctx[26](value);
    }
    __name(option9_checked_binding, "option9_checked_binding");
    var option9_props = {
      option: "removeDuplicateFields",
    };
    if (ctx[7] !== void 0) {
      option9_props.checked = ctx[7];
    }
    option9 = new Option_default({
      props: option9_props,
    });
    binding_callbacks.push(() => bind(option9, "checked", option9_checked_binding));
    function option10_checked_binding(value) {
      ctx[28](value);
    }
    __name(option10_checked_binding, "option10_checked_binding");
    var option10_props = {
      option: "maxAuthors",
      $$slots: {
        default: [create_default_slot_16],
      },
      $$scope: {
        ctx,
      },
    };
    if (ctx[8] !== void 0) {
      option10_props.checked = ctx[8];
    }
    option10 = new Option_default({
      props: option10_props,
    });
    binding_callbacks.push(() => bind(option10, "checked", option10_checked_binding));
    return {
      c() {
        div = element("div");
        t0 = space();
        create_component(option0.$$.fragment);
        t1 = space();
        create_component(option1.$$.fragment);
        t2 = space();
        create_component(option2.$$.fragment);
        t3 = space();
        create_component(option3.$$.fragment);
        t4 = space();
        create_component(option4.$$.fragment);
        t5 = space();
        create_component(option5.$$.fragment);
        t6 = space();
        create_component(option6.$$.fragment);
        t7 = space();
        create_component(option7.$$.fragment);
        t8 = space();
        create_component(option8.$$.fragment);
        t9 = space();
        create_component(option9.$$.fragment);
        t10 = space();
        create_component(option10.$$.fragment);
        attr(div, "id", "valueOptions");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        insert(target, t0, anchor);
        mount_component(option0, target, anchor);
        insert(target, t1, anchor);
        mount_component(option1, target, anchor);
        insert(target, t2, anchor);
        mount_component(option2, target, anchor);
        insert(target, t3, anchor);
        mount_component(option3, target, anchor);
        insert(target, t4, anchor);
        mount_component(option4, target, anchor);
        insert(target, t5, anchor);
        mount_component(option5, target, anchor);
        insert(target, t6, anchor);
        mount_component(option6, target, anchor);
        insert(target, t7, anchor);
        mount_component(option7, target, anchor);
        insert(target, t8, anchor);
        mount_component(option8, target, anchor);
        insert(target, t9, anchor);
        mount_component(option9, target, anchor);
        insert(target, t10, anchor);
        mount_component(option10, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        var option0_changes = {};
        if (!updating_checked && dirty[0] & 1) {
          updating_checked = true;
          option0_changes.checked = ctx2[0];
          add_flush_callback(() => (updating_checked = false));
        }
        option0.$set(option0_changes);
        var option1_changes = {};
        if ((dirty[0] & 2048) | (dirty[1] & 2048)) {
          option1_changes.$$scope = {
            dirty,
            ctx: ctx2,
          };
        }
        if (!updating_checked_1 && dirty[0] & 1024) {
          updating_checked_1 = true;
          option1_changes.checked = ctx2[10];
          add_flush_callback(() => (updating_checked_1 = false));
        }
        option1.$set(option1_changes);
        var option2_changes = {};
        if ((dirty[0] & 8192) | (dirty[1] & 2048)) {
          option2_changes.$$scope = {
            dirty,
            ctx: ctx2,
          };
        }
        if (!updating_checked_2 && dirty[0] & 4096) {
          updating_checked_2 = true;
          option2_changes.checked = ctx2[12];
          add_flush_callback(() => (updating_checked_2 = false));
        }
        option2.$set(option2_changes);
        var option3_changes = {};
        if (!updating_checked_3 && dirty[0] & 2) {
          updating_checked_3 = true;
          option3_changes.checked = ctx2[1];
          add_flush_callback(() => (updating_checked_3 = false));
        }
        option3.$set(option3_changes);
        var option4_changes = {};
        if (!updating_checked_4 && dirty[0] & 4) {
          updating_checked_4 = true;
          option4_changes.checked = ctx2[2];
          add_flush_callback(() => (updating_checked_4 = false));
        }
        option4.$set(option4_changes);
        var option5_changes = {};
        if (!updating_checked_5 && dirty[0] & 8) {
          updating_checked_5 = true;
          option5_changes.checked = ctx2[3];
          add_flush_callback(() => (updating_checked_5 = false));
        }
        option5.$set(option5_changes);
        var option6_changes = {};
        if (!updating_checked_6 && dirty[0] & 16) {
          updating_checked_6 = true;
          option6_changes.checked = ctx2[4];
          add_flush_callback(() => (updating_checked_6 = false));
        }
        option6.$set(option6_changes);
        var option7_changes = {};
        if (!updating_checked_7 && dirty[0] & 32) {
          updating_checked_7 = true;
          option7_changes.checked = ctx2[5];
          add_flush_callback(() => (updating_checked_7 = false));
        }
        option7.$set(option7_changes);
        var option8_changes = {};
        if (!updating_checked_8 && dirty[0] & 64) {
          updating_checked_8 = true;
          option8_changes.checked = ctx2[6];
          add_flush_callback(() => (updating_checked_8 = false));
        }
        option8.$set(option8_changes);
        var option9_changes = {};
        if (!updating_checked_9 && dirty[0] & 128) {
          updating_checked_9 = true;
          option9_changes.checked = ctx2[7];
          add_flush_callback(() => (updating_checked_9 = false));
        }
        option9.$set(option9_changes);
        var option10_changes = {};
        if ((dirty[0] & 512) | (dirty[1] & 2048)) {
          option10_changes.$$scope = {
            dirty,
            ctx: ctx2,
          };
        }
        if (!updating_checked_10 && dirty[0] & 256) {
          updating_checked_10 = true;
          option10_changes.checked = ctx2[8];
          add_flush_callback(() => (updating_checked_10 = false));
        }
        option10.$set(option10_changes);
      },
      i(local) {
        if (current) return;
        transition_in(option0.$$.fragment, local);
        transition_in(option1.$$.fragment, local);
        transition_in(option2.$$.fragment, local);
        transition_in(option3.$$.fragment, local);
        transition_in(option4.$$.fragment, local);
        transition_in(option5.$$.fragment, local);
        transition_in(option6.$$.fragment, local);
        transition_in(option7.$$.fragment, local);
        transition_in(option8.$$.fragment, local);
        transition_in(option9.$$.fragment, local);
        transition_in(option10.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(option0.$$.fragment, local);
        transition_out(option1.$$.fragment, local);
        transition_out(option2.$$.fragment, local);
        transition_out(option3.$$.fragment, local);
        transition_out(option4.$$.fragment, local);
        transition_out(option5.$$.fragment, local);
        transition_out(option6.$$.fragment, local);
        transition_out(option7.$$.fragment, local);
        transition_out(option8.$$.fragment, local);
        transition_out(option9.$$.fragment, local);
        transition_out(option10.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) detach(div);
        if (detaching) detach(t0);
        destroy_component(option0, detaching);
        if (detaching) detach(t1);
        destroy_component(option1, detaching);
        if (detaching) detach(t2);
        destroy_component(option2, detaching);
        if (detaching) detach(t3);
        destroy_component(option3, detaching);
        if (detaching) detach(t4);
        destroy_component(option4, detaching);
        if (detaching) detach(t5);
        destroy_component(option5, detaching);
        if (detaching) detach(t6);
        destroy_component(option6, detaching);
        if (detaching) detach(t7);
        destroy_component(option7, detaching);
        if (detaching) detach(t8);
        destroy_component(option8, detaching);
        if (detaching) detach(t9);
        destroy_component(option9, detaching);
        if (detaching) detach(t10);
        destroy_component(option10, detaching);
      },
    };
  }
  __name(create_default_slot7, "create_default_slot");
  function create_fragment17(ctx) {
    var collapsible;
    var current;
    collapsible = new Collapsible_default({
      props: {
        open: true,
        title: "Values",
        $$slots: {
          default: [create_default_slot7],
        },
        $$scope: {
          ctx,
        },
      },
    });
    return {
      c() {
        create_component(collapsible.$$.fragment);
      },
      m(target, anchor) {
        mount_component(collapsible, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        var collapsible_changes = {};
        if ((dirty[0] & 16383) | (dirty[1] & 2048)) {
          collapsible_changes.$$scope = {
            dirty,
            ctx: ctx2,
          };
        }
        collapsible.$set(collapsible_changes);
      },
      i(local) {
        if (current) return;
        transition_in(collapsible.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(collapsible.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(collapsible, detaching);
      },
    };
  }
  __name(create_fragment17, "create_fragment");
  function instance17($$self, $$props, $$invalidate) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
    var options = $$props.options;
    var curly = (_a2 = options.curly) !== null && _a2 !== void 0 ? _a2 : false;
    var stripEnclosingBraces = (_b = options.stripEnclosingBraces) !== null && _b !== void 0 ? _b : false;
    var numeric = (_c = options.numeric) !== null && _c !== void 0 ? _c : false;
    var dropAllCaps = (_d = options.dropAllCaps) !== null && _d !== void 0 ? _d : false;
    var escape = (_e = options.escape) !== null && _e !== void 0 ? _e : false;
    var encodeUrls = (_f = options.encodeUrls) !== null && _f !== void 0 ? _f : false;
    var removeEmptyFields = (_g = options.removeEmptyFields) !== null && _g !== void 0 ? _g : false;
    var removeDuplicateFields = (_h = options.removeDuplicateFields) !== null && _h !== void 0 ? _h : false;
    var maxAuthorsChecked = options.maxAuthors !== void 0;
    var maxAuthorsValue = (_j = options.maxAuthors) !== null && _j !== void 0 ? _j : 3;
    var enclosingBracesChecked = options.enclosingBraces !== void 0 && options.enclosingBraces.length > 0;
    var enclosingBracesValue = (_l = (_k = options.enclosingBraces) === null || _k === void 0 ? void 0 : _k.join(" ")) !== null && _l !== void 0 ? _l : "title";
    var removeBracesChecked = options.removeBraces !== void 0 && options.removeBraces.length > 0;
    var removeBracesValue = (_o = (_m = options.enclosingBraces) === null || _m === void 0 ? void 0 : _m.join(" ")) !== null && _o !== void 0 ? _o : "title";
    function option0_checked_binding(value) {
      curly = value;
      $$invalidate(0, curly);
    }
    __name(option0_checked_binding, "option0_checked_binding");
    function textarea_input_handler() {
      enclosingBracesValue = this.value;
      $$invalidate(11, enclosingBracesValue);
    }
    __name(textarea_input_handler, "textarea_input_handler");
    function option1_checked_binding(value) {
      enclosingBracesChecked = value;
      $$invalidate(10, enclosingBracesChecked);
    }
    __name(option1_checked_binding, "option1_checked_binding");
    function textarea_input_handler_1() {
      removeBracesValue = this.value;
      $$invalidate(13, removeBracesValue);
    }
    __name(textarea_input_handler_1, "textarea_input_handler_1");
    function option2_checked_binding(value) {
      removeBracesChecked = value;
      $$invalidate(12, removeBracesChecked);
    }
    __name(option2_checked_binding, "option2_checked_binding");
    function option3_checked_binding(value) {
      stripEnclosingBraces = value;
      $$invalidate(1, stripEnclosingBraces);
    }
    __name(option3_checked_binding, "option3_checked_binding");
    function option4_checked_binding(value) {
      numeric = value;
      $$invalidate(2, numeric);
    }
    __name(option4_checked_binding, "option4_checked_binding");
    function option5_checked_binding(value) {
      dropAllCaps = value;
      $$invalidate(3, dropAllCaps);
    }
    __name(option5_checked_binding, "option5_checked_binding");
    function option6_checked_binding(value) {
      escape = value;
      $$invalidate(4, escape);
    }
    __name(option6_checked_binding, "option6_checked_binding");
    function option7_checked_binding(value) {
      encodeUrls = value;
      $$invalidate(5, encodeUrls);
    }
    __name(option7_checked_binding, "option7_checked_binding");
    function option8_checked_binding(value) {
      removeEmptyFields = value;
      $$invalidate(6, removeEmptyFields);
    }
    __name(option8_checked_binding, "option8_checked_binding");
    function option9_checked_binding(value) {
      removeDuplicateFields = value;
      $$invalidate(7, removeDuplicateFields);
    }
    __name(option9_checked_binding, "option9_checked_binding");
    function input_input_handler() {
      maxAuthorsValue = to_number(this.value);
      $$invalidate(9, maxAuthorsValue);
    }
    __name(input_input_handler, "input_input_handler");
    function option10_checked_binding(value) {
      maxAuthorsChecked = value;
      $$invalidate(8, maxAuthorsChecked);
    }
    __name(option10_checked_binding, "option10_checked_binding");
    $$self.$$set = ($$props2) => {
      if ("options" in $$props2) $$invalidate(14, (options = $$props2.options));
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty[0] & 16383) {
        $: {
          $$invalidate(14, (options.curly = curly), options);
          $$invalidate(14, (options.stripEnclosingBraces = stripEnclosingBraces), options);
          $$invalidate(14, (options.numeric = numeric), options);
          $$invalidate(14, (options.dropAllCaps = dropAllCaps), options);
          $$invalidate(14, (options.escape = escape), options);
          $$invalidate(14, (options.encodeUrls = encodeUrls), options);
          $$invalidate(14, (options.removeEmptyFields = removeEmptyFields), options);
          $$invalidate(14, (options.removeDuplicateFields = removeDuplicateFields), options);
          $$invalidate(14, (options.maxAuthors = maxAuthorsChecked ? maxAuthorsValue : void 0), options);
          $$invalidate(14, (options.enclosingBraces = enclosingBracesChecked && enclosingBracesValue.length > 0 ? enclosingBracesValue.split(/[\n\t ,]+/) : void 0), options);
          $$invalidate(14, (options.removeBraces = removeBracesChecked && removeBracesValue.length > 0 ? removeBracesValue.split(/[\n\t ,]+/) : void 0), options);
        }
      }
    };
    return [
      curly,
      stripEnclosingBraces,
      numeric,
      dropAllCaps,
      escape,
      encodeUrls,
      removeEmptyFields,
      removeDuplicateFields,
      maxAuthorsChecked,
      maxAuthorsValue,
      enclosingBracesChecked,
      enclosingBracesValue,
      removeBracesChecked,
      removeBracesValue,
      options,
      option0_checked_binding,
      textarea_input_handler,
      option1_checked_binding,
      textarea_input_handler_1,
      option2_checked_binding,
      option3_checked_binding,
      option4_checked_binding,
      option5_checked_binding,
      option6_checked_binding,
      option7_checked_binding,
      option8_checked_binding,
      option9_checked_binding,
      input_input_handler,
      option10_checked_binding,
    ];
  }
  __name(instance17, "instance");
  var ValueOptions = class ValueOptions extends SvelteComponent {
    constructor(options) {
      super();
      init(
        this,
        options,
        instance17,
        create_fragment17,
        safe_not_equal,
        {
          options: 14,
        },
        null,
        [-1, -1]
      );
    }
  };
  __name(ValueOptions, "ValueOptions");
  var ValueOptions_default = ValueOptions;
  // src/ui/WhitespaceOptions.svelte
  function create_default_slot_26(ctx) {
    var label;
    var t2;
    var input;
    var mounted;
    var dispose;
    return {
      c() {
        label = element("label");
        t2 = text("Column:\n			");
        input = element("input");
        attr(input, "name", "alignnum");
        attr(input, "type", "number");
      },
      m(target, anchor) {
        insert(target, label, anchor);
        append(label, t2);
        append(label, input);
        set_input_value(input, ctx[2]);
        if (!mounted) {
          dispose = listen(input, "input", ctx[5]);
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (dirty & 4 && to_number(input.value) !== ctx2[2]) {
          set_input_value(input, ctx2[2]);
        }
      },
      d(detaching) {
        if (detaching) detach(label);
        mounted = false;
        dispose();
      },
    };
  }
  __name(create_default_slot_26, "create_default_slot_2");
  function create_default_slot_17(ctx) {
    var label;
    var t2;
    var input;
    var mounted;
    var dispose;
    return {
      c() {
        label = element("label");
        t2 = text("Column:\n			");
        input = element("input");
        attr(input, "name", "wrapnum");
        attr(input, "type", "number");
      },
      m(target, anchor) {
        insert(target, label, anchor);
        append(label, t2);
        append(label, input);
        set_input_value(input, ctx[4]);
        if (!mounted) {
          dispose = listen(input, "input", ctx[7]);
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (dirty & 16 && to_number(input.value) !== ctx2[4]) {
          set_input_value(input, ctx2[4]);
        }
      },
      d(detaching) {
        if (detaching) detach(label);
        mounted = false;
        dispose();
      },
    };
  }
  __name(create_default_slot_17, "create_default_slot_1");
  function create_default_slot8(ctx) {
    var option0;
    var updating_checked;
    var t0;
    var option1;
    var updating_checked_1;
    var t1;
    var option2;
    var updating_checked_2;
    var current;
    function option0_checked_binding(value) {
      ctx[6](value);
    }
    __name(option0_checked_binding, "option0_checked_binding");
    var option0_props = {
      option: "align",
      $$slots: {
        default: [create_default_slot_26],
      },
      $$scope: {
        ctx,
      },
    };
    if (ctx[1] !== void 0) {
      option0_props.checked = ctx[1];
    }
    option0 = new Option_default({
      props: option0_props,
    });
    binding_callbacks.push(() => bind(option0, "checked", option0_checked_binding));
    function option1_checked_binding(value) {
      ctx[8](value);
    }
    __name(option1_checked_binding, "option1_checked_binding");
    var option1_props = {
      option: "wrap",
      $$slots: {
        default: [create_default_slot_17],
      },
      $$scope: {
        ctx,
      },
    };
    if (ctx[3] !== void 0) {
      option1_props.checked = ctx[3];
    }
    option1 = new Option_default({
      props: option1_props,
    });
    binding_callbacks.push(() => bind(option1, "checked", option1_checked_binding));
    function option2_checked_binding(value) {
      ctx[9](value);
    }
    __name(option2_checked_binding, "option2_checked_binding");
    var option2_props = {
      option: "blankLines",
    };
    if (ctx[0].blankLines !== void 0) {
      option2_props.checked = ctx[0].blankLines;
    }
    option2 = new Option_default({
      props: option2_props,
    });
    binding_callbacks.push(() => bind(option2, "checked", option2_checked_binding));
    return {
      c() {
        create_component(option0.$$.fragment);
        t0 = space();
        create_component(option1.$$.fragment);
        t1 = space();
        create_component(option2.$$.fragment);
      },
      m(target, anchor) {
        mount_component(option0, target, anchor);
        insert(target, t0, anchor);
        mount_component(option1, target, anchor);
        insert(target, t1, anchor);
        mount_component(option2, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        var option0_changes = {};
        if (dirty & 2052) {
          option0_changes.$$scope = {
            dirty,
            ctx: ctx2,
          };
        }
        if (!updating_checked && dirty & 2) {
          updating_checked = true;
          option0_changes.checked = ctx2[1];
          add_flush_callback(() => (updating_checked = false));
        }
        option0.$set(option0_changes);
        var option1_changes = {};
        if (dirty & 2064) {
          option1_changes.$$scope = {
            dirty,
            ctx: ctx2,
          };
        }
        if (!updating_checked_1 && dirty & 8) {
          updating_checked_1 = true;
          option1_changes.checked = ctx2[3];
          add_flush_callback(() => (updating_checked_1 = false));
        }
        option1.$set(option1_changes);
        var option2_changes = {};
        if (!updating_checked_2 && dirty & 1) {
          updating_checked_2 = true;
          option2_changes.checked = ctx2[0].blankLines;
          add_flush_callback(() => (updating_checked_2 = false));
        }
        option2.$set(option2_changes);
      },
      i(local) {
        if (current) return;
        transition_in(option0.$$.fragment, local);
        transition_in(option1.$$.fragment, local);
        transition_in(option2.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(option0.$$.fragment, local);
        transition_out(option1.$$.fragment, local);
        transition_out(option2.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(option0, detaching);
        if (detaching) detach(t0);
        destroy_component(option1, detaching);
        if (detaching) detach(t1);
        destroy_component(option2, detaching);
      },
    };
  }
  __name(create_default_slot8, "create_default_slot");
  function create_fragment18(ctx) {
    var collapsible;
    var current;
    collapsible = new Collapsible_default({
      props: {
        title: "Whitespace",
        open: true,
        $$slots: {
          default: [create_default_slot8],
        },
        $$scope: {
          ctx,
        },
      },
    });
    return {
      c() {
        create_component(collapsible.$$.fragment);
      },
      m(target, anchor) {
        mount_component(collapsible, target, anchor);
        current = true;
      },
      p(ctx2, param) {
        var _param = _slicedToArray(param, 1),
          dirty = _param[0];
        var collapsible_changes = {};
        if (dirty & 2079) {
          collapsible_changes.$$scope = {
            dirty,
            ctx: ctx2,
          };
        }
        collapsible.$set(collapsible_changes);
      },
      i(local) {
        if (current) return;
        transition_in(collapsible.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(collapsible.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(collapsible, detaching);
      },
    };
  }
  __name(create_fragment18, "create_fragment");
  function instance18($$self, $$props, $$invalidate) {
    var _a2;
    var options = $$props.options;
    var alignChecked = options.align > 1;
    var alignValue = alignChecked ? options.align : 13;
    var wrapChecked = options.wrap !== void 0;
    var wrapValue = (_a2 = options.wrap) !== null && _a2 !== void 0 ? _a2 : DEFAULT_WRAP;
    function input_input_handler() {
      alignValue = to_number(this.value);
      $$invalidate(2, alignValue);
    }
    __name(input_input_handler, "input_input_handler");
    function option0_checked_binding(value) {
      alignChecked = value;
      $$invalidate(1, alignChecked);
    }
    __name(option0_checked_binding, "option0_checked_binding");
    function input_input_handler_1() {
      wrapValue = to_number(this.value);
      $$invalidate(4, wrapValue);
    }
    __name(input_input_handler_1, "input_input_handler_1");
    function option1_checked_binding(value) {
      wrapChecked = value;
      $$invalidate(3, wrapChecked);
    }
    __name(option1_checked_binding, "option1_checked_binding");
    function option2_checked_binding(value) {
      if ($$self.$$.not_equal(options.blankLines, value)) {
        options.blankLines = value;
        $$invalidate(0, options), $$invalidate(1, alignChecked), $$invalidate(2, alignValue), $$invalidate(3, wrapChecked), $$invalidate(4, wrapValue);
      }
    }
    __name(option2_checked_binding, "option2_checked_binding");
    $$self.$$set = ($$props2) => {
      if ("options" in $$props2) $$invalidate(0, (options = $$props2.options));
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 30) {
        $: {
          $$invalidate(0, (options.align = alignChecked ? alignValue : 1), options);
          $$invalidate(0, (options.wrap = wrapChecked ? wrapValue : void 0), options);
        }
      }
    };
    return [options, alignChecked, alignValue, wrapChecked, wrapValue, input_input_handler, option0_checked_binding, input_input_handler_1, option1_checked_binding, option2_checked_binding];
  }
  __name(instance18, "instance");
  var WhitespaceOptions = class WhitespaceOptions extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance18, create_fragment18, safe_not_equal, {
        options: 0,
      });
    }
  };
  __name(WhitespaceOptions, "WhitespaceOptions");
  var WhitespaceOptions_default = WhitespaceOptions;
  // src/ui/Sidebar.svelte
  function create_if_block7(ctx) {
    var feedback;
    var current;
    feedback = new Feedback_default({
      props: {
        options: ctx[0],
        status: ctx[1],
      },
    });
    return {
      c() {
        create_component(feedback.$$.fragment);
      },
      m(target, anchor) {
        mount_component(feedback, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        var feedback_changes = {};
        if (dirty & 1) feedback_changes.options = ctx2[0];
        if (dirty & 2) feedback_changes.status = ctx2[1];
        feedback.$set(feedback_changes);
      },
      i(local) {
        if (current) return;
        transition_in(feedback.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(feedback.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(feedback, detaching);
      },
    };
  }
  __name(create_if_block7, "create_if_block");
  function create_fragment19(ctx) {
    var aside;
    var form;
    var header;
    var t7;
    var indentoptions;
    var updating_options;
    var t8;
    var whitespaceoptions;
    var updating_options_1;
    var t9;
    var valueoptions;
    var updating_options_2;
    var t10;
    var sortingoptions;
    var updating_options_3;
    var t11;
    var duplicateoptions;
    var updating_options_4;
    var t12;
    var cleanupoptions;
    var updating_options_5;
    var t13;
    var cli;
    var t14;
    var div;
    var t15;
    var button;
    var t16;
    var current;
    var mounted;
    var dispose;
    function indentoptions_options_binding(value) {
      ctx[4](value);
    }
    __name(indentoptions_options_binding, "indentoptions_options_binding");
    var indentoptions_props = {};
    if (ctx[0] !== void 0) {
      indentoptions_props.options = ctx[0];
    }
    indentoptions = new IndentOptions_default({
      props: indentoptions_props,
    });
    binding_callbacks.push(() => bind(indentoptions, "options", indentoptions_options_binding));
    function whitespaceoptions_options_binding(value) {
      ctx[5](value);
    }
    __name(whitespaceoptions_options_binding, "whitespaceoptions_options_binding");
    var whitespaceoptions_props = {};
    if (ctx[0] !== void 0) {
      whitespaceoptions_props.options = ctx[0];
    }
    whitespaceoptions = new WhitespaceOptions_default({
      props: whitespaceoptions_props,
    });
    binding_callbacks.push(() => bind(whitespaceoptions, "options", whitespaceoptions_options_binding));
    function valueoptions_options_binding(value) {
      ctx[6](value);
    }
    __name(valueoptions_options_binding, "valueoptions_options_binding");
    var valueoptions_props = {};
    if (ctx[0] !== void 0) {
      valueoptions_props.options = ctx[0];
    }
    valueoptions = new ValueOptions_default({
      props: valueoptions_props,
    });
    binding_callbacks.push(() => bind(valueoptions, "options", valueoptions_options_binding));
    function sortingoptions_options_binding(value) {
      ctx[7](value);
    }
    __name(sortingoptions_options_binding, "sortingoptions_options_binding");
    var sortingoptions_props = {};
    if (ctx[0] !== void 0) {
      sortingoptions_props.options = ctx[0];
    }
    sortingoptions = new SortingOptions_default({
      props: sortingoptions_props,
    });
    binding_callbacks.push(() => bind(sortingoptions, "options", sortingoptions_options_binding));
    function duplicateoptions_options_binding(value) {
      ctx[8](value);
    }
    __name(duplicateoptions_options_binding, "duplicateoptions_options_binding");
    var duplicateoptions_props = {};
    if (ctx[0] !== void 0) {
      duplicateoptions_props.options = ctx[0];
    }
    duplicateoptions = new DuplicateOptions_default({
      props: duplicateoptions_props,
    });
    binding_callbacks.push(() => bind(duplicateoptions, "options", duplicateoptions_options_binding));
    function cleanupoptions_options_binding(value) {
      ctx[9](value);
    }
    __name(cleanupoptions_options_binding, "cleanupoptions_options_binding");
    var cleanupoptions_props = {};
    if (ctx[0] !== void 0) {
      cleanupoptions_props.options = ctx[0];
    }
    cleanupoptions = new CleanupOptions_default({
      props: cleanupoptions_props,
    });
    binding_callbacks.push(() => bind(cleanupoptions, "options", cleanupoptions_options_binding));
    cli = new Cli_default({
      props: {
        options: ctx[0],
      },
    });
    var if_block = ctx[1] && create_if_block7(ctx);
    return {
      c() {
        aside = element("aside");
        form = element("form");
        header = element("header");
        header.innerHTML = '<h1 class="svelte-kvjsp8">BibTeX Tidy</h1> \n			<p>This tool tidies bibtex files by fixing inconsistent whitespace,\n				removing duplicates, removing unwanted fields, and sorting entries.</p> \n			<p><a class="btn" href="https://github.com/FlamingTempura/bibtex-tidy">Github</a> \n				<a class="btn" href="https://github.com/FlamingTempura/bibtex-tidy/issues">Report a bug</a></p>';
        t7 = space();
        create_component(indentoptions.$$.fragment);
        t8 = space();
        create_component(whitespaceoptions.$$.fragment);
        t9 = space();
        create_component(valueoptions.$$.fragment);
        t10 = space();
        create_component(sortingoptions.$$.fragment);
        t11 = space();
        create_component(duplicateoptions.$$.fragment);
        t12 = space();
        create_component(cleanupoptions.$$.fragment);
        t13 = space();
        create_component(cli.$$.fragment);
        t14 = space();
        div = element("div");
        if (if_block) if_block.c();
        t15 = space();
        button = element("button");
        t16 = text("Tidy");
        attr(header, "class", "intro svelte-kvjsp8");
        attr(form, "class", "svelte-kvjsp8");
        attr(button, "id", "tidy");
        button.disabled = ctx[2];
        attr(button, "class", "svelte-kvjsp8");
        attr(div, "class", "run svelte-kvjsp8");
        attr(aside, "id", "sidebar");
        attr(aside, "class", "svelte-kvjsp8");
      },
      m(target, anchor) {
        insert(target, aside, anchor);
        append(aside, form);
        append(form, header);
        append(form, t7);
        mount_component(indentoptions, form, null);
        append(form, t8);
        mount_component(whitespaceoptions, form, null);
        append(form, t9);
        mount_component(valueoptions, form, null);
        append(form, t10);
        mount_component(sortingoptions, form, null);
        append(form, t11);
        mount_component(duplicateoptions, form, null);
        append(form, t12);
        mount_component(cleanupoptions, form, null);
        append(form, t13);
        mount_component(cli, form, null);
        append(aside, t14);
        append(aside, div);
        if (if_block) if_block.m(div, null);
        append(div, t15);
        append(div, button);
        append(button, t16);
        current = true;
        if (!mounted) {
          dispose = [listen(form, "submit", submit_handler), listen(button, "click", ctx[10])];
          mounted = true;
        }
      },
      p(ctx2, param) {
        var _param = _slicedToArray(param, 1),
          dirty = _param[0];
        var indentoptions_changes = {};
        if (!updating_options && dirty & 1) {
          updating_options = true;
          indentoptions_changes.options = ctx2[0];
          add_flush_callback(() => (updating_options = false));
        }
        indentoptions.$set(indentoptions_changes);
        var whitespaceoptions_changes = {};
        if (!updating_options_1 && dirty & 1) {
          updating_options_1 = true;
          whitespaceoptions_changes.options = ctx2[0];
          add_flush_callback(() => (updating_options_1 = false));
        }
        whitespaceoptions.$set(whitespaceoptions_changes);
        var valueoptions_changes = {};
        if (!updating_options_2 && dirty & 1) {
          updating_options_2 = true;
          valueoptions_changes.options = ctx2[0];
          add_flush_callback(() => (updating_options_2 = false));
        }
        valueoptions.$set(valueoptions_changes);
        var sortingoptions_changes = {};
        if (!updating_options_3 && dirty & 1) {
          updating_options_3 = true;
          sortingoptions_changes.options = ctx2[0];
          add_flush_callback(() => (updating_options_3 = false));
        }
        sortingoptions.$set(sortingoptions_changes);
        var duplicateoptions_changes = {};
        if (!updating_options_4 && dirty & 1) {
          updating_options_4 = true;
          duplicateoptions_changes.options = ctx2[0];
          add_flush_callback(() => (updating_options_4 = false));
        }
        duplicateoptions.$set(duplicateoptions_changes);
        var cleanupoptions_changes = {};
        if (!updating_options_5 && dirty & 1) {
          updating_options_5 = true;
          cleanupoptions_changes.options = ctx2[0];
          add_flush_callback(() => (updating_options_5 = false));
        }
        cleanupoptions.$set(cleanupoptions_changes);
        var cli_changes = {};
        if (dirty & 1) cli_changes.options = ctx2[0];
        cli.$set(cli_changes);
        if (ctx2[1]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
            if (dirty & 2) {
              transition_in(if_block, 1);
            }
          } else {
            if_block = create_if_block7(ctx2);
            if_block.c();
            transition_in(if_block, 1);
            if_block.m(div, t15);
          }
        } else if (if_block) {
          group_outros();
          transition_out(if_block, 1, 1, () => {
            if_block = null;
          });
          check_outros();
        }
        if (!current || dirty & 4) {
          button.disabled = ctx2[2];
        }
      },
      i(local) {
        if (current) return;
        transition_in(indentoptions.$$.fragment, local);
        transition_in(whitespaceoptions.$$.fragment, local);
        transition_in(valueoptions.$$.fragment, local);
        transition_in(sortingoptions.$$.fragment, local);
        transition_in(duplicateoptions.$$.fragment, local);
        transition_in(cleanupoptions.$$.fragment, local);
        transition_in(cli.$$.fragment, local);
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(indentoptions.$$.fragment, local);
        transition_out(whitespaceoptions.$$.fragment, local);
        transition_out(valueoptions.$$.fragment, local);
        transition_out(sortingoptions.$$.fragment, local);
        transition_out(duplicateoptions.$$.fragment, local);
        transition_out(cleanupoptions.$$.fragment, local);
        transition_out(cli.$$.fragment, local);
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (detaching) detach(aside);
        destroy_component(indentoptions);
        destroy_component(whitespaceoptions);
        destroy_component(valueoptions);
        destroy_component(sortingoptions);
        destroy_component(duplicateoptions);
        destroy_component(cleanupoptions);
        destroy_component(cli);
        if (if_block) if_block.d();
        mounted = false;
        run_all(dispose);
      },
    };
  }
  __name(create_fragment19, "create_fragment");
  var submit_handler = /* @__PURE__ */ __name(() => false, "submit_handler");
  function instance19($$self, $$props, $$invalidate) {
    var status = $$props.status;
    var running = $$props.running;
    var options = $$props.options;
    var dispatch = createEventDispatcher();
    function indentoptions_options_binding(value) {
      options = value;
      $$invalidate(0, options);
    }
    __name(indentoptions_options_binding, "indentoptions_options_binding");
    function whitespaceoptions_options_binding(value) {
      options = value;
      $$invalidate(0, options);
    }
    __name(whitespaceoptions_options_binding, "whitespaceoptions_options_binding");
    function valueoptions_options_binding(value) {
      options = value;
      $$invalidate(0, options);
    }
    __name(valueoptions_options_binding, "valueoptions_options_binding");
    function sortingoptions_options_binding(value) {
      options = value;
      $$invalidate(0, options);
    }
    __name(sortingoptions_options_binding, "sortingoptions_options_binding");
    function duplicateoptions_options_binding(value) {
      options = value;
      $$invalidate(0, options);
    }
    __name(duplicateoptions_options_binding, "duplicateoptions_options_binding");
    function cleanupoptions_options_binding(value) {
      options = value;
      $$invalidate(0, options);
    }
    __name(cleanupoptions_options_binding, "cleanupoptions_options_binding");
    var click_handler = /* @__PURE__ */ __name(() => dispatch("tidy"), "click_handler");
    $$self.$$set = ($$props2) => {
      if ("status" in $$props2) $$invalidate(1, (status = $$props2.status));
      if ("running" in $$props2) $$invalidate(2, (running = $$props2.running));
      if ("options" in $$props2) $$invalidate(0, (options = $$props2.options));
    };
    return [options, status, running, dispatch, indentoptions_options_binding, whitespaceoptions_options_binding, valueoptions_options_binding, sortingoptions_options_binding, duplicateoptions_options_binding, cleanupoptions_options_binding, click_handler];
  }
  __name(instance19, "instance");
  var Sidebar = class Sidebar extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance19, create_fragment19, safe_not_equal, {
        status: 1,
        running: 2,
        options: 0,
      });
    }
  };
  __name(Sidebar, "Sidebar");
  var Sidebar_default = Sidebar;
  // src/ui/defaultBibtex.ts
  var DEFAULT_BIBTEX =
    'Click Tidy to clean up the entries below      \n@Book{sweig42,\n  Author =	 { Stefa{n} Sweig },\n  title =	 { The impossible book },\n  publisher =	 { Dead Poet Society},\n  year =	 1942,\n  month =        mar\n}\n@article{steward03,\n  author =	 {Martha Steward},\n  title =	 {Cooking behind bars}, publisher = "Culinary Expert Series",\n  year = {2003}\n}\n@Book{impossible,\n  Author =	 { Stefan Sweig },\n  title =	 { The impossible book },\n  publisher =	 { Dead Poet Society},\n  year =	 1942,\n  month =        mar\n}\n';
  // src/ui/App.svelte
  function create_fragment20(ctx) {
    var editor;
    var updating_bibtex;
    var t2;
    var sidebar;
    var updating_options;
    var current;
    function editor_bibtex_binding(value) {
      ctx[6](value);
    }
    __name(editor_bibtex_binding, "editor_bibtex_binding");
    var editor_props = {
      error: ctx[4],
    };
    if (ctx[2] !== void 0) {
      editor_props.bibtex = ctx[2];
    }
    editor = new Editor_default({
      props: editor_props,
    });
    binding_callbacks.push(() => bind(editor, "bibtex", editor_bibtex_binding));
    function sidebar_options_binding(value) {
      ctx[7](value);
    }
    __name(sidebar_options_binding, "sidebar_options_binding");
    var sidebar_props = {
      status: ctx[3],
      running: ctx[1],
    };
    if (ctx[0] !== void 0) {
      sidebar_props.options = ctx[0];
    }
    sidebar = new Sidebar_default({
      props: sidebar_props,
    });
    binding_callbacks.push(() => bind(sidebar, "options", sidebar_options_binding));
    sidebar.$on("tidy", ctx[5]);
    return {
      c() {
        create_component(editor.$$.fragment);
        t2 = space();
        create_component(sidebar.$$.fragment);
      },
      m(target, anchor) {
        mount_component(editor, target, anchor);
        insert(target, t2, anchor);
        mount_component(sidebar, target, anchor);
        current = true;
      },
      p(ctx2, param) {
        var _param = _slicedToArray(param, 1),
          dirty = _param[0];
        var editor_changes = {};
        if (dirty & 16) editor_changes.error = ctx2[4];
        if (!updating_bibtex && dirty & 4) {
          updating_bibtex = true;
          editor_changes.bibtex = ctx2[2];
          add_flush_callback(() => (updating_bibtex = false));
        }
        editor.$set(editor_changes);
        var sidebar_changes = {};
        if (dirty & 8) sidebar_changes.status = ctx2[3];
        if (dirty & 2) sidebar_changes.running = ctx2[1];
        if (!updating_options && dirty & 1) {
          updating_options = true;
          sidebar_changes.options = ctx2[0];
          add_flush_callback(() => (updating_options = false));
        }
        sidebar.$set(sidebar_changes);
      },
      i(local) {
        if (current) return;
        transition_in(editor.$$.fragment, local);
        transition_in(sidebar.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(editor.$$.fragment, local);
        transition_out(sidebar.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(editor, detaching);
        if (detaching) detach(t2);
        destroy_component(sidebar, detaching);
      },
    };
  }
  __name(create_fragment20, "create_fragment");
  function instance20($$self, $$props, $$invalidate) {
    var _a2;
    var optionDefaults = normalizeOptions({
      tab: true,
      align: 13,
      curly: true,
      numeric: true,
      escape: false,
      duplicates: ["key"],
      sortFields: true,
      removeDuplicateFields: false,
    });
    var running = false;
    var bibtex = DEFAULT_BIBTEX;
    var options = (_a2 = getOptionsFromURL()) !== null && _a2 !== void 0 ? _a2 : optionDefaults;
    var status;
    var error;
    function handleTidy() {
      $$invalidate(1, (running = true));
      $$invalidate(3, (status = void 0));
      $$invalidate(4, (error = void 0));
      setTimeout(() => {
        try {
          var result = tidy(bibtex, options);
          $$invalidate(2, (bibtex = result.bibtex));
          $$invalidate(
            3,
            (status = {
              status: "success",
              result,
            })
          );
        } catch (e) {
          console.error("bibtex parse problem:", e);
          $$invalidate(
            3,
            (status = {
              status: "error",
              error: e,
            })
          );
          if (e instanceof BibTeXSyntaxError) {
            $$invalidate(4, (error = e));
          }
        } finally {
          $$invalidate(1, (running = false));
        }
      }, 100);
    }
    __name(handleTidy, "handleTidy");
    function getOptionsFromURL() {
      var queryString = window.location.search;
      var urlParams = new URLSearchParams(queryString);
      var optionsJSON = urlParams.get("opt");
      if (!optionsJSON) return;
      try {
        return normalizeOptions(JSON.parse(optionsJSON));
      } catch (e) {
        console.error("Error parsing options in URL");
        return;
      }
    }
    __name(getOptionsFromURL, "getOptionsFromURL");
    window.addEventListener("popstate", () => {
      var _a3;
      $$invalidate(0, (options = (_a3 = getOptionsFromURL()) !== null && _a3 !== void 0 ? _a3 : optionDefaults));
    });
    function editor_bibtex_binding(value) {
      bibtex = value;
      $$invalidate(2, bibtex);
    }
    __name(editor_bibtex_binding, "editor_bibtex_binding");
    function sidebar_options_binding(value) {
      options = value;
      $$invalidate(0, options);
    }
    __name(sidebar_options_binding, "sidebar_options_binding");
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 1) {
        $: {
          var optionsJSON = JSON.stringify(options);
          var params = new URLSearchParams([["opt", optionsJSON]]);
          window.history.pushState(options, "", "index.html?".concat(params.toString()));
        }
      }
    };
    return [options, running, bibtex, status, error, handleTidy, editor_bibtex_binding, sidebar_options_binding];
  }
  __name(instance20, "instance");
  var App = class App extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance20, create_fragment20, safe_not_equal, {});
    }
  };
  __name(App, "App");
  var App_default = App;
  // src/ui/index.ts
  new App_default({
    target: document.body,
  });
})();
